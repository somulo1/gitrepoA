
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">vaultke-backend/internal/api/auth_handlers.go (0.0%)</option>
				
				<option value="file1">vaultke-backend/internal/api/bank_transaction_handlers.go (0.0%)</option>
				
				<option value="file2">vaultke-backend/internal/api/buyer_handlers.go (0.0%)</option>
				
				<option value="file3">vaultke-backend/internal/api/cart_handlers.go (0.0%)</option>
				
				<option value="file4">vaultke-backend/internal/api/chama_handlers.go (0.0%)</option>
				
				<option value="file5">vaultke-backend/internal/api/chat_handlers.go (0.0%)</option>
				
				<option value="file6">vaultke-backend/internal/api/contribution_handler.go (0.0%)</option>
				
				<option value="file7">vaultke-backend/internal/api/delivery_contacts_handlers.go (0.0%)</option>
				
				<option value="file8">vaultke-backend/internal/api/delivery_handlers.go (0.0%)</option>
				
				<option value="file9">vaultke-backend/internal/api/disbursement_handlers.go (0.0%)</option>
				
				<option value="file10">vaultke-backend/internal/api/dividends_handlers.go (0.0%)</option>
				
				<option value="file11">vaultke-backend/internal/api/e2ee_handlers.go (0.0%)</option>
				
				<option value="file12">vaultke-backend/internal/api/financial_reports_handlers.go (0.0%)</option>
				
				<option value="file13">vaultke-backend/internal/api/learning_admin_handlers.go (0.0%)</option>
				
				<option value="file14">vaultke-backend/internal/api/learning_handlers.go (0.0%)</option>
				
				<option value="file15">vaultke-backend/internal/api/learning_upload_handlers.go (0.0%)</option>
				
				<option value="file16">vaultke-backend/internal/api/loan_handlers.go (0.0%)</option>
				
				<option value="file17">vaultke-backend/internal/api/market_handlers.go (0.0%)</option>
				
				<option value="file18">vaultke-backend/internal/api/meeting_handlers.go (0.0%)</option>
				
				<option value="file19">vaultke-backend/internal/api/merry_go_round_handlers.go (0.0%)</option>
				
				<option value="file20">vaultke-backend/internal/api/money_request_handlers.go (0.0%)</option>
				
				<option value="file21">vaultke-backend/internal/api/mpesa_handlers.go (0.0%)</option>
				
				<option value="file22">vaultke-backend/internal/api/notification_handlers.go (0.0%)</option>
				
				<option value="file23">vaultke-backend/internal/api/order_handlers.go (0.0%)</option>
				
				<option value="file24">vaultke-backend/internal/api/placeholder.go (25.8%)</option>
				
				<option value="file25">vaultke-backend/internal/api/polls_handlers.go (0.0%)</option>
				
				<option value="file26">vaultke-backend/internal/api/product_review_handlers.go (0.0%)</option>
				
				<option value="file27">vaultke-backend/internal/api/receipt_handlers.go (0.0%)</option>
				
				<option value="file28">vaultke-backend/internal/api/reminder_handlers.go (58.1%)</option>
				
				<option value="file29">vaultke-backend/internal/api/security_handlers.go (0.0%)</option>
				
				<option value="file30">vaultke-backend/internal/api/seller_handlers.go (0.0%)</option>
				
				<option value="file31">vaultke-backend/internal/api/shares_handlers.go (0.0%)</option>
				
				<option value="file32">vaultke-backend/internal/api/support_handlers.go (0.0%)</option>
				
				<option value="file33">vaultke-backend/internal/api/transaction_handlers.go (0.0%)</option>
				
				<option value="file34">vaultke-backend/internal/api/user_search_handlers.go (0.0%)</option>
				
				<option value="file35">vaultke-backend/internal/api/users_handlers.go (24.5%)</option>
				
				<option value="file36">vaultke-backend/internal/api/vote_handlers.go (0.0%)</option>
				
				<option value="file37">vaultke-backend/internal/api/wallet_handlers.go (45.3%)</option>
				
				<option value="file38">vaultke-backend/internal/api/welfare_handlers.go (0.0%)</option>
				
				<option value="file39">vaultke-backend/internal/api/wishlist_handlers.go (0.0%)</option>
				
				<option value="file40">vaultke-backend/internal/config/config.go (0.0%)</option>
				
				<option value="file41">vaultke-backend/internal/database/database.go (52.2%)</option>
				
				<option value="file42">vaultke-backend/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file43">vaultke-backend/internal/middleware/security.go (0.0%)</option>
				
				<option value="file44">vaultke-backend/internal/models/chama.go (0.0%)</option>
				
				<option value="file45">vaultke-backend/internal/models/dividends.go (0.0%)</option>
				
				<option value="file46">vaultke-backend/internal/models/loan.go (0.0%)</option>
				
				<option value="file47">vaultke-backend/internal/models/marketplace.go (0.0%)</option>
				
				<option value="file48">vaultke-backend/internal/models/polls.go (0.0%)</option>
				
				<option value="file49">vaultke-backend/internal/models/reminder.go (0.0%)</option>
				
				<option value="file50">vaultke-backend/internal/models/shares.go (0.0%)</option>
				
				<option value="file51">vaultke-backend/internal/models/user.go (0.0%)</option>
				
				<option value="file52">vaultke-backend/internal/models/wallet.go (0.0%)</option>
				
				<option value="file53">vaultke-backend/internal/services/auth_service.go (47.2%)</option>
				
				<option value="file54">vaultke-backend/internal/services/calendar.go (0.0%)</option>
				
				<option value="file55">vaultke-backend/internal/services/cart_services.go (0.0%)</option>
				
				<option value="file56">vaultke-backend/internal/services/chama_service.go (1.4%)</option>
				
				<option value="file57">vaultke-backend/internal/services/chat_service.go (0.0%)</option>
				
				<option value="file58">vaultke-backend/internal/services/config.go (0.0%)</option>
				
				<option value="file59">vaultke-backend/internal/services/dividends_service.go (0.0%)</option>
				
				<option value="file60">vaultke-backend/internal/services/e2ee_service.go (0.0%)</option>
				
				<option value="file61">vaultke-backend/internal/services/email_service.go (6.1%)</option>
				
				<option value="file62">vaultke-backend/internal/services/livekit.go (0.0%)</option>
				
				<option value="file63">vaultke-backend/internal/services/loan_service.go (0.0%)</option>
				
				<option value="file64">vaultke-backend/internal/services/marketplace_service.go (0.7%)</option>
				
				<option value="file65">vaultke-backend/internal/services/meeting.go (0.0%)</option>
				
				<option value="file66">vaultke-backend/internal/services/mpesa_service.go (0.0%)</option>
				
				<option value="file67">vaultke-backend/internal/services/notification_scheduler.go (0.0%)</option>
				
				<option value="file68">vaultke-backend/internal/services/notification_service.go (0.0%)</option>
				
				<option value="file69">vaultke-backend/internal/services/order_service.go (0.0%)</option>
				
				<option value="file70">vaultke-backend/internal/services/password_reset_service.go (13.5%)</option>
				
				<option value="file71">vaultke-backend/internal/services/polls_service.go (0.0%)</option>
				
				<option value="file72">vaultke-backend/internal/services/product_review_service.go (0.0%)</option>
				
				<option value="file73">vaultke-backend/internal/services/reminder_service.go (40.0%)</option>
				
				<option value="file74">vaultke-backend/internal/services/scheduler.go (0.0%)</option>
				
				<option value="file75">vaultke-backend/internal/services/shares_service.go (0.0%)</option>
				
				<option value="file76">vaultke-backend/internal/services/user_service.go (0.0%)</option>
				
				<option value="file77">vaultke-backend/internal/services/wallet_service.go (17.2%)</option>
				
				<option value="file78">vaultke-backend/internal/services/websocket_service.go (14.7%)</option>
				
				<option value="file79">vaultke-backend/internal/services/whishlist_service.go (0.0%)</option>
				
				<option value="file80">vaultke-backend/internal/utils/helpers.go (1.8%)</option>
				
				<option value="file81">vaultke-backend/internal/utils/room_generator.go (0.0%)</option>
				
				<option value="file82">vaultke-backend/internal/utils/validation.go (0.0%)</option>
				
				<option value="file83">vaultke-backend/test/helpers/test_helpers.go (8.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/services"
)

// DeviceInfo represents device information extracted from request
type DeviceInfo struct {
        DeviceType string
        DeviceName string
        OS         string
        Browser    string
        Location   string
}

// extractDeviceInfo extracts device information from request headers
func extractDeviceInfo(c *gin.Context) DeviceInfo <span class="cov0" title="0">{
        // Use browser's natural User-Agent header (automatically set)
        userAgent := c.GetHeader("User-Agent")

        deviceInfo := DeviceInfo{
                DeviceType: "unknown",
                DeviceName: "Unknown Device",
                OS:         "Unknown",
                Browser:    "Unknown Browser",
                Location:   "Unknown",
        }

        // Enhanced device detection with more specific browser and device info
        userAgentLower := strings.ToLower(userAgent)

        // Detect mobile devices first
        if strings.Contains(userAgentLower, "mobile") || strings.Contains(userAgentLower, "android") || strings.Contains(userAgentLower, "iphone") || strings.Contains(userAgentLower, "ipad") </span><span class="cov0" title="0">{
                deviceInfo.DeviceType = "mobile"

                // Android devices
                if strings.Contains(userAgentLower, "android") </span><span class="cov0" title="0">{
                        deviceInfo.OS = "Android"
                        // Try to extract Android version
                        if strings.Contains(userAgent, "Android ") </span><span class="cov0" title="0">{
                                parts := strings.Split(userAgent, "Android ")
                                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                        version := strings.Split(parts[1], ";")[0]
                                        deviceInfo.OS = fmt.Sprintf("Android %s", version)
                                }</span>
                        }

                        // Detect specific Android browsers
                        <span class="cov0" title="0">if strings.Contains(userAgentLower, "chrome") &amp;&amp; !strings.Contains(userAgentLower, "edg") </span><span class="cov0" title="0">{
                                deviceInfo.Browser = "Chrome Mobile"
                                deviceInfo.DeviceName = "Android Phone • Chrome"
                        }</span> else<span class="cov0" title="0"> if strings.Contains(userAgentLower, "firefox") </span><span class="cov0" title="0">{
                                deviceInfo.Browser = "Firefox Mobile"
                                deviceInfo.DeviceName = "Android Phone • Firefox"
                        }</span> else<span class="cov0" title="0"> if strings.Contains(userAgentLower, "samsung") </span><span class="cov0" title="0">{
                                deviceInfo.Browser = "Samsung Internet"
                                deviceInfo.DeviceName = "Samsung Phone • Samsung Internet"
                        }</span> else<span class="cov0" title="0"> {
                                deviceInfo.DeviceName = "Android Device"
                        }</span>
                }

                // iOS devices
                <span class="cov0" title="0">if strings.Contains(userAgentLower, "iphone") </span><span class="cov0" title="0">{
                        deviceInfo.OS = "iOS"
                        deviceInfo.DeviceType = "mobile"
                        if strings.Contains(userAgentLower, "safari") &amp;&amp; !strings.Contains(userAgentLower, "chrome") </span><span class="cov0" title="0">{
                                deviceInfo.Browser = "Safari Mobile"
                                deviceInfo.DeviceName = "iPhone • Safari"
                        }</span> else<span class="cov0" title="0"> if strings.Contains(userAgentLower, "crios") </span><span class="cov0" title="0">{
                                deviceInfo.Browser = "Chrome Mobile"
                                deviceInfo.DeviceName = "iPhone • Chrome"
                        }</span> else<span class="cov0" title="0"> if strings.Contains(userAgentLower, "fxios") </span><span class="cov0" title="0">{
                                deviceInfo.Browser = "Firefox Mobile"
                                deviceInfo.DeviceName = "iPhone • Firefox"
                        }</span> else<span class="cov0" title="0"> {
                                deviceInfo.DeviceName = "iPhone"
                        }</span>
                }

                <span class="cov0" title="0">if strings.Contains(userAgentLower, "ipad") </span><span class="cov0" title="0">{
                        deviceInfo.OS = "iPadOS"
                        deviceInfo.DeviceType = "tablet"
                        deviceInfo.DeviceName = "iPad"
                        if strings.Contains(userAgentLower, "safari") </span><span class="cov0" title="0">{
                                deviceInfo.Browser = "Safari"
                                deviceInfo.DeviceName = "iPad • Safari"
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Desktop devices
                deviceInfo.DeviceType = "desktop"

                // Windows
                if strings.Contains(userAgentLower, "windows") </span><span class="cov0" title="0">{
                        deviceInfo.OS = "Windows"
                        if strings.Contains(userAgent, "Windows NT 10") </span><span class="cov0" title="0">{
                                deviceInfo.OS = "Windows 10/11"
                        }</span> else<span class="cov0" title="0"> if strings.Contains(userAgent, "Windows NT 6.3") </span><span class="cov0" title="0">{
                                deviceInfo.OS = "Windows 8.1"
                        }</span> else<span class="cov0" title="0"> if strings.Contains(userAgent, "Windows NT 6.1") </span><span class="cov0" title="0">{
                                deviceInfo.OS = "Windows 7"
                        }</span>
                }

                // macOS
                <span class="cov0" title="0">if strings.Contains(userAgentLower, "mac os x") || strings.Contains(userAgentLower, "macos") </span><span class="cov0" title="0">{
                        deviceInfo.OS = "macOS"
                        if strings.Contains(userAgent, "Mac OS X 10_15") </span><span class="cov0" title="0">{
                                deviceInfo.OS = "macOS Catalina+"
                        }</span>
                }

                // Linux
                <span class="cov0" title="0">if strings.Contains(userAgentLower, "linux") &amp;&amp; !strings.Contains(userAgentLower, "android") </span><span class="cov0" title="0">{
                        deviceInfo.OS = "Linux"
                }</span>

                // Browser detection for desktop
                <span class="cov0" title="0">if strings.Contains(userAgentLower, "edg/") </span><span class="cov0" title="0">{
                        deviceInfo.Browser = "Microsoft Edge"
                        deviceInfo.DeviceName = fmt.Sprintf("%s PC - Edge", deviceInfo.OS)
                }</span> else<span class="cov0" title="0"> if strings.Contains(userAgentLower, "chrome/") &amp;&amp; !strings.Contains(userAgentLower, "edg") </span><span class="cov0" title="0">{
                        deviceInfo.Browser = "Google Chrome"
                        deviceInfo.DeviceName = fmt.Sprintf("%s PC - Chrome", deviceInfo.OS)
                }</span> else<span class="cov0" title="0"> if strings.Contains(userAgentLower, "firefox/") </span><span class="cov0" title="0">{
                        deviceInfo.Browser = "Mozilla Firefox"
                        deviceInfo.DeviceName = fmt.Sprintf("%s PC - Firefox", deviceInfo.OS)
                }</span> else<span class="cov0" title="0"> if strings.Contains(userAgentLower, "safari/") &amp;&amp; !strings.Contains(userAgentLower, "chrome") </span><span class="cov0" title="0">{
                        deviceInfo.Browser = "Safari"
                        deviceInfo.DeviceName = fmt.Sprintf("%s - Safari", deviceInfo.OS)
                }</span> else<span class="cov0" title="0"> if strings.Contains(userAgentLower, "opera") </span><span class="cov0" title="0">{
                        deviceInfo.Browser = "Opera"
                        deviceInfo.DeviceName = fmt.Sprintf("%s PC - Opera", deviceInfo.OS)
                }</span>
        }

        // VaultKe mobile app detection
        <span class="cov0" title="0">if strings.Contains(userAgentLower, "vaultke") || strings.Contains(userAgentLower, "expo") </span><span class="cov0" title="0">{
                deviceInfo.Browser = "VaultKe App"
                if deviceInfo.OS == "Android" </span><span class="cov0" title="0">{
                        deviceInfo.DeviceName = "Android Phone - VaultKe App"
                }</span> else<span class="cov0" title="0"> if deviceInfo.OS == "iOS" </span><span class="cov0" title="0">{
                        deviceInfo.DeviceName = "iPhone - VaultKe App"
                }</span> else<span class="cov0" title="0"> {
                        deviceInfo.DeviceName = "Mobile Device - VaultKe App"
                }</span>
        }

        // Use enhanced device info from custom headers (sent by frontend)
        <span class="cov0" title="0">frontendDeviceType := c.GetHeader("X-Device-Type")
        frontendDeviceName := c.GetHeader("X-Device-Name")
        frontendBrowserName := c.GetHeader("X-Browser-Name")
        frontendOSName := c.GetHeader("X-OS-Name")

        // Debug: Log received headers
        fmt.Printf("Received device headers - Type: '%s', Name: '%s', Browser: '%s', OS: '%s'\n",
                frontendDeviceType, frontendDeviceName, frontendBrowserName, frontendOSName)

        // Override with frontend-detected info if available (more accurate)
        if frontendDeviceType != "" </span><span class="cov0" title="0">{
                deviceInfo.DeviceType = frontendDeviceType
        }</span>
        <span class="cov0" title="0">if frontendDeviceName != "" </span><span class="cov0" title="0">{
                deviceInfo.DeviceName = frontendDeviceName
        }</span>
        <span class="cov0" title="0">if frontendBrowserName != "" </span><span class="cov0" title="0">{
                deviceInfo.Browser = frontendBrowserName
        }</span>
        <span class="cov0" title="0">if frontendOSName != "" </span><span class="cov0" title="0">{
                deviceInfo.OS = frontendOSName
        }</span>

        // Enhanced IP detection for tunneled environments (tunnelmole, ngrok, etc.)
        <span class="cov0" title="0">ip := c.ClientIP()

        // Check multiple forwarded headers in order of preference
        // Tunnelmole and similar services use these headers to pass the real client IP
        realIP := c.GetHeader("X-Real-IP")
        forwardedFor := c.GetHeader("X-Forwarded-For")
        cfConnectingIP := c.GetHeader("CF-Connecting-IP") // Cloudflare
        trueClientIP := c.GetHeader("True-Client-IP")     // Akamai
        xClientIP := c.GetHeader("X-Client-IP")           // Some proxies

        // Use the most reliable IP source (prioritize real client IP)
        clientIP := ip
        if cfConnectingIP != "" </span><span class="cov0" title="0">{
                // Cloudflare's header is very reliable
                clientIP = cfConnectingIP
        }</span> else<span class="cov0" title="0"> if trueClientIP != "" </span><span class="cov0" title="0">{
                // Akamai's header
                clientIP = trueClientIP
        }</span> else<span class="cov0" title="0"> if realIP != "" </span><span class="cov0" title="0">{
                // Standard real IP header
                clientIP = realIP
        }</span> else<span class="cov0" title="0"> if xClientIP != "" </span><span class="cov0" title="0">{
                // Some proxy services use this
                clientIP = xClientIP
        }</span> else<span class="cov0" title="0"> if forwardedFor != "" </span><span class="cov0" title="0">{
                // X-Forwarded-For can contain multiple IPs, take the first one (original client)
                ips := strings.Split(forwardedFor, ",")
                if len(ips) &gt; 0 </span><span class="cov0" title="0">{
                        clientIP = strings.TrimSpace(ips[0])
                }</span>
        }

        // Debug: Log all IP-related headers for troubleshooting
        <span class="cov0" title="0">fmt.Printf("IP Detection Debug - ClientIP: %s, X-Real-IP: %s, X-Forwarded-For: %s, CF-Connecting-IP: %s, Final: %s\n",
                ip, realIP, forwardedFor, cfConnectingIP, clientIP)

        // Enhanced location detection with additional headers
        timezone := c.GetHeader("X-Timezone")
        connectionType := c.GetHeader("X-Connection-Type")

        // Determine location based on IP (now properly detects real client IPs)
        if clientIP == "127.0.0.1" || clientIP == "::1" </span><span class="cov0" title="0">{
                deviceInfo.Location = "Local Development (localhost)"
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(clientIP, "192.168.") || strings.HasPrefix(clientIP, "10.") ||
                (strings.HasPrefix(clientIP, "172.") &amp;&amp; len(clientIP) &gt; 8) </span><span class="cov0" title="0">{
                deviceInfo.Location = fmt.Sprintf("Private Network (%s)", clientIP)
        }</span> else<span class="cov0" title="0"> if clientIP != "" &amp;&amp; clientIP != ip </span><span class="cov0" title="0">{
                // We got a real client IP different from the proxy IP
                deviceInfo.Location = fmt.Sprintf("Client IP: %s", clientIP)
        }</span> else<span class="cov0" title="0"> {
                // Fallback to whatever IP we have
                deviceInfo.Location = fmt.Sprintf("IP: %s", clientIP)
        }</span>

        // Add timezone info to location if available
        <span class="cov0" title="0">if timezone != "" &amp;&amp; timezone != "UTC" </span><span class="cov0" title="0">{
                deviceInfo.Location = fmt.Sprintf("%s (%s)", deviceInfo.Location, timezone)
        }</span>

        // Add connection type if available
        <span class="cov0" title="0">if connectionType != "" </span><span class="cov0" title="0">{
                deviceInfo.Location = fmt.Sprintf("%s • %s", deviceInfo.Location, connectionType)
        }</span>

        // Add connection type if available
        <span class="cov0" title="0">if connectionType != "" </span><span class="cov0" title="0">{
                deviceInfo.Location = fmt.Sprintf("%s • %s", deviceInfo.Location, connectionType)
        }</span>

        <span class="cov0" title="0">return deviceInfo</span>
}

// AuthHandlers contains all authentication-related handlers
type AuthHandlers struct {
        userService *services.UserService
        authService *services.AuthService
}

// NewAuthHandlers creates new auth handlers
func NewAuthHandlers(db *sql.DB, jwtSecret string, jwtExpiration int) *AuthHandlers <span class="cov0" title="0">{
        return &amp;AuthHandlers{
                userService: services.NewUserService(db),
                authService: services.NewAuthService(jwtSecret, jwtExpiration),
        }
}</span>

// AuthResponse represents the authentication response
type AuthResponse struct {
        Success bool      `json:"success"`
        Message string    `json:"message"`
        Data    *AuthData `json:"data,omitempty"`
        Error   string    `json:"error,omitempty"`
}

// AuthData represents the data in auth response
type AuthData struct {
        User  *models.User `json:"user,omitempty"`
        Token string       `json:"token,omitempty"`
}

// Register handles user registration
func (h *AuthHandlers) Register(c *gin.Context) <span class="cov0" title="0">{
        var req models.UserRegistration
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, AuthResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Create user
        <span class="cov0" title="0">user, err := h.userService.CreateUser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, AuthResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        // Generate token
        <span class="cov0" title="0">token, err := h.authService.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, AuthResponse{
                        Success: false,
                        Error:   "Failed to generate token",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, AuthResponse{
                Success: true,
                Message: "User registered successfully. Please verify your email and phone number.",
                Data: &amp;AuthData{
                        User:  user,
                        Token: token,
                },
        })</span>
}

// Login handles user authentication
func (h *AuthHandlers) Login(c *gin.Context) <span class="cov0" title="0">{
        var req models.UserLogin
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, AuthResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Authenticate user
        <span class="cov0" title="0">user, err := h.userService.AuthenticateUser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, AuthResponse{
                        Success: false,
                        Error:   "Invalid credentials",
                })
                return
        }</span>

        // Generate token
        <span class="cov0" title="0">token, err := h.authService.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, AuthResponse{
                        Success: false,
                        Error:   "Failed to generate token",
                })
                return
        }</span>

        // Record login session with real device info
        <span class="cov0" title="0">db, exists := c.Get("db")
        if exists </span><span class="cov0" title="0">{
                deviceInfo := extractDeviceInfo(c)
                fmt.Printf("Extracted device info for user %s: %+v\n", user.ID, deviceInfo)

                // Get the best available IP address (same logic as extractDeviceInfo)
                ip := c.ClientIP()
                realIP := c.GetHeader("X-Real-IP")
                forwardedFor := c.GetHeader("X-Forwarded-For")
                cfConnectingIP := c.GetHeader("CF-Connecting-IP")
                trueClientIP := c.GetHeader("True-Client-IP")
                xClientIP := c.GetHeader("X-Client-IP")

                clientIP := ip
                if cfConnectingIP != "" </span><span class="cov0" title="0">{
                        clientIP = cfConnectingIP
                }</span> else<span class="cov0" title="0"> if trueClientIP != "" </span><span class="cov0" title="0">{
                        clientIP = trueClientIP
                }</span> else<span class="cov0" title="0"> if realIP != "" </span><span class="cov0" title="0">{
                        clientIP = realIP
                }</span> else<span class="cov0" title="0"> if xClientIP != "" </span><span class="cov0" title="0">{
                        clientIP = xClientIP
                }</span> else<span class="cov0" title="0"> if forwardedFor != "" </span><span class="cov0" title="0">{
                        ips := strings.Split(forwardedFor, ",")
                        if len(ips) &gt; 0 </span><span class="cov0" title="0">{
                                clientIP = strings.TrimSpace(ips[0])
                        }</span>
                }

                <span class="cov0" title="0">err := RecordLoginSession(
                        db.(*sql.DB),
                        user.ID,
                        deviceInfo.DeviceType,
                        deviceInfo.DeviceName,
                        deviceInfo.OS,
                        deviceInfo.Browser,
                        clientIP,
                        deviceInfo.Location,
                )
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to record login session: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Successfully called RecordLoginSession for user %s with IP %s\n", user.ID, clientIP)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Database not available in context for recording login session\n")
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                Success: true,
                Message: "Login successful",
                Data: &amp;AuthData{
                        User:  user,
                        Token: token,
                },
        })</span>
}

// Logout handles user logout
func (h *AuthHandlers) Logout(c *gin.Context) <span class="cov0" title="0">{
        // Get token from Authorization header
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, AuthResponse{
                        Success: true,
                        Message: "Logout successful", // Still return success even without token
                })
                return
        }</span>

        // Extract token (remove "Bearer " prefix)
        <span class="cov0" title="0">tokenString := ""
        if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov0" title="0">{
                tokenString = authHeader[7:]
        }</span>

        <span class="cov0" title="0">if tokenString != "" </span><span class="cov0" title="0">{
                // Add token to blacklist
                err := h.authService.BlacklistToken(tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the logout
                        // Client-side cleanup should still proceed
                        c.JSON(http.StatusOK, AuthResponse{
                                Success: true,
                                Message: "Logout successful (token cleanup failed)",
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                Success: true,
                Message: "Logout successful",
        })</span>
}

// RefreshToken handles token refresh
func (h *AuthHandlers) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        // Get token from header
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, AuthResponse{
                        Success: false,
                        Error:   "Authorization header required",
                })
                return
        }</span>

        // Extract token
        <span class="cov0" title="0">tokenString := authHeader[7:] // Remove "Bearer " prefix

        // Refresh token
        newToken, err := h.authService.RefreshToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, AuthResponse{
                        Success: false,
                        Error:   "Failed to refresh token: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                Success: true,
                Message: "Token refreshed successfully",
                Data: &amp;AuthData{
                        Token: newToken,
                },
        })</span>
}

// VerifyEmail handles email verification
func (h *AuthHandlers) VerifyEmail(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, AuthResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">err := h.userService.VerifyEmail(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, AuthResponse{
                        Success: false,
                        Error:   "Failed to verify email: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                Success: true,
                Message: "Email verified successfully",
        })</span>
}

// VerifyPhone handles phone verification
func (h *AuthHandlers) VerifyPhone(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, AuthResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">err := h.userService.VerifyPhone(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, AuthResponse{
                        Success: false,
                        Error:   "Failed to verify phone: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                Success: true,
                Message: "Phone verified successfully",
        })</span>
}

// ForgotPassword handles password reset request
func (h *AuthHandlers) ForgotPassword(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Identifier string `json:"identifier" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, AuthResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get password reset service from context
        <span class="cov0" title="0">passwordResetService, exists := c.Get("passwordResetService")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, AuthResponse{
                        Success: false,
                        Error:   "Password reset service not available",
                })
                return
        }</span>

        <span class="cov0" title="0">resetService := passwordResetService.(*services.PasswordResetService)

        // Request password reset
        err := resetService.RequestPasswordReset(req.Identifier)
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a user not found error
                if err.Error() == "user not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, AuthResponse{
                                Success: false,
                                Error:   "No account found with this email or phone number",
                        })
                        return
                }</span>

                // For other errors, log them but don't reveal details
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, AuthResponse{
                        Success: false,
                        Error:   "Failed to send reset instructions. Please try again.",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                Success: true,
                Message: "Password reset instructions sent successfully",
        })</span>
}

// ResetPassword handles password reset
func (h *AuthHandlers) ResetPassword(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Token       string `json:"token" binding:"required"`
                NewPassword string `json:"newPassword" binding:"required,min=6"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, AuthResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get password reset service from context
        <span class="cov0" title="0">passwordResetService, exists := c.Get("passwordResetService")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, AuthResponse{
                        Success: false,
                        Error:   "Password reset service not available",
                })
                return
        }</span>

        <span class="cov0" title="0">resetService := passwordResetService.(*services.PasswordResetService)

        // Reset password
        err := resetService.ResetPassword(req.Token, req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, AuthResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                Success: true,
                Message: "Password reset successfully! You can now login with your new password.",
        })</span>
}

// TestEmail handles email testing (for development only)
func (h *AuthHandlers) TestEmail(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Email string `json:"email" binding:"required,email"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, AuthResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get password reset service from context
        <span class="cov0" title="0">passwordResetService, exists := c.Get("passwordResetService")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, AuthResponse{
                        Success: false,
                        Error:   "Password reset service not available",
                })
                return
        }</span>

        <span class="cov0" title="0">resetService := passwordResetService.(*services.PasswordResetService)

        // Send test email
        err := resetService.SendPasswordResetEmail(req.Email, "Test User", "123456")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, AuthResponse{
                        Success: false,
                        Error:   "Failed to send test email: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                Success: true,
                Message: "Test email sent successfully",
        })</span>
}

// GetProfile handles getting user profile
func (h *AuthHandlers) GetProfile(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, AuthResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, AuthResponse{
                        Success: false,
                        Error:   "User not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                Success: true,
                Message: "Profile retrieved successfully",
                Data: &amp;AuthData{
                        User: user,
                },
        })</span>
}

// UpdateProfile handles updating user profile (supports both JSON and multipart form data)
func (h *AuthHandlers) UpdateProfile(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, AuthResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">contentType := c.GetHeader("Content-Type")
        var req models.UserProfileUpdate
        var err error

        // Handle multipart form data (for file uploads)
        if strings.Contains(contentType, "multipart/form-data") </span><span class="cov0" title="0">{
                err = h.handleMultipartProfileUpdate(c, &amp;req, userID)
        }</span> else<span class="cov0" title="0"> {
                // Handle JSON data
                err = c.ShouldBindJSON(&amp;req)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, AuthResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.UpdateUser(userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, AuthResponse{
                        Success: false,
                        Error:   "Failed to update profile: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                Success: true,
                Message: "Profile updated successfully",
                Data: &amp;AuthData{
                        User: user,
                },
        })</span>
}

// handleMultipartProfileUpdate processes multipart form data for profile updates
func (h *AuthHandlers) handleMultipartProfileUpdate(c *gin.Context, req *models.UserProfileUpdate, userID string) error <span class="cov0" title="0">{
        // Parse multipart form
        err := c.Request.ParseMultipartForm(10 &lt;&lt; 20) // 10 MB max
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">form := c.Request.MultipartForm

        // Handle text fields
        if values, ok := form.Value["firstName"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                req.FirstName = &amp;values[0]
        }</span>
        <span class="cov0" title="0">if values, ok := form.Value["lastName"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                req.LastName = &amp;values[0]
        }</span>
        <span class="cov0" title="0">if values, ok := form.Value["county"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                req.County = &amp;values[0]
        }</span>
        <span class="cov0" title="0">if values, ok := form.Value["town"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                req.Town = &amp;values[0]
        }</span>
        <span class="cov0" title="0">if values, ok := form.Value["bio"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                req.Bio = &amp;values[0]
        }</span>
        <span class="cov0" title="0">if values, ok := form.Value["occupation"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                req.Occupation = &amp;values[0]
        }</span>
        <span class="cov0" title="0">if values, ok := form.Value["language"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                req.Language = &amp;values[0]
        }</span>
        <span class="cov0" title="0">if values, ok := form.Value["theme"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                req.Theme = &amp;values[0]
        }</span>
        <span class="cov0" title="0">if values, ok := form.Value["businessType"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                req.BusinessType = &amp;values[0]
        }</span>
        <span class="cov0" title="0">if values, ok := form.Value["businessDescription"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                req.BusinessDescription = &amp;values[0]
        }</span>

        // Handle numeric fields
        <span class="cov0" title="0">if values, ok := form.Value["latitude"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                if lat, err := strconv.ParseFloat(values[0], 64); err == nil </span><span class="cov0" title="0">{
                        req.Latitude = &amp;lat
                }</span>
        }
        <span class="cov0" title="0">if values, ok := form.Value["longitude"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                if lng, err := strconv.ParseFloat(values[0], 64); err == nil </span><span class="cov0" title="0">{
                        req.Longitude = &amp;lng
                }</span>
        }

        // Handle date fields
        <span class="cov0" title="0">if values, ok := form.Value["dateOfBirth"]; ok &amp;&amp; len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                if dateOfBirth, err := time.Parse("2006-01-02", values[0]); err == nil </span><span class="cov0" title="0">{
                        flexDate := &amp;models.FlexibleDate{Time: dateOfBirth}
                        req.DateOfBirth = flexDate
                }</span>
        }

        // Handle file upload (profile image)
        <span class="cov0" title="0">if files, ok := form.File["profile_image"]; ok &amp;&amp; len(files) &gt; 0 </span><span class="cov0" title="0">{
                file := files[0]

                // Validate file type
                allowedTypes := map[string]bool{
                        "image/jpeg": true,
                        "image/jpg":  true,
                        "image/png":  true,
                        "image/webp": true,
                }

                if !allowedTypes[file.Header.Get("Content-Type")] </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid file type. Only JPEG, PNG, and WebP images are allowed")
                }</span>

                // Validate file size (5MB max)
                <span class="cov0" title="0">if file.Size &gt; 5*1024*1024 </span><span class="cov0" title="0">{
                        return fmt.Errorf("file too large. Maximum size is 5MB")
                }</span>

                // Create uploads directory if it doesn't exist
                <span class="cov0" title="0">uploadDir := "./uploads/avatars"
                if err := os.MkdirAll(uploadDir, 0o755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create upload directory: %w", err)
                }</span>

                // Generate unique filename
                <span class="cov0" title="0">ext := filepath.Ext(file.Filename)
                filename := fmt.Sprintf("%d_%s%s", time.Now().Unix(), userID, ext)
                filepath := filepath.Join(uploadDir, filename)

                // Open uploaded file
                src, err := file.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open uploaded file: %w", err)
                }</span>
                <span class="cov0" title="0">defer src.Close()

                // Create destination file
                dst, err := os.Create(filepath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create destination file: %w", err)
                }</span>
                <span class="cov0" title="0">defer dst.Close()

                // Copy file content
                if _, err := io.Copy(dst, src); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save file: %w", err)
                }</span>

                // Set avatar path in request
                <span class="cov0" title="0">avatarURL := "/uploads/avatars/" + filename
                req.Avatar = &amp;avatarURL</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ResendVerification handles resending verification email/SMS
func (h *AuthHandlers) ResendVerification(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, AuthResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Type string `json:"type" binding:"required"` // "email" or "phone"
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, AuthResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get user details
        <span class="cov0" title="0">user, err := h.userService.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, AuthResponse{
                        Success: false,
                        Error:   "User not found",
                })
                return
        }</span>

        <span class="cov0" title="0">switch req.Type </span>{
        case "email":<span class="cov0" title="0">
                if user.IsEmailVerified </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, AuthResponse{
                                Success: false,
                                Error:   "Email is already verified",
                        })
                        return
                }</span>

                // Get password reset service for email functionality
                <span class="cov0" title="0">passwordResetService, exists := c.Get("passwordResetService")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, AuthResponse{
                                Success: false,
                                Error:   "Email service not available",
                        })
                        return
                }</span>

                <span class="cov0" title="0">resetService := passwordResetService.(*services.PasswordResetService)

                // Generate verification code (reuse password reset functionality)
                err := resetService.SendPasswordResetEmail(user.Email, user.FirstName+" "+user.LastName, "123456")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, AuthResponse{
                                Success: false,
                                Error:   "Failed to send verification email",
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                        Success: true,
                        Message: "Verification email sent successfully",
                })</span>

        case "phone":<span class="cov0" title="0">
                if user.IsPhoneVerified </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, AuthResponse{
                                Success: false,
                                Error:   "Phone is already verified",
                        })
                        return
                }</span>

                // TODO: Implement SMS verification
                <span class="cov0" title="0">c.JSON(http.StatusOK, AuthResponse{
                        Success: true,
                        Message: "Phone verification SMS sent successfully",
                })</span>

        default:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, AuthResponse{
                        Success: false,
                        Error:   "Invalid verification type. Must be 'email' or 'phone'",
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

func InitiateBankTransfer(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Bank transfer endpoint - coming soon",
        })
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "database/sql"
        "log"
        "net/http"

        "github.com/gin-gonic/gin"
)

// GetBuyerStats returns statistics for buyers
func GetBuyerStats(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context
        userIDInterface, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>
        <span class="cov0" title="0">userID := userIDInterface.(string)

        // Get database connection
        dbInterface, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>
        <span class="cov0" title="0">db := dbInterface.(*sql.DB)

        // Get real buyer stats from database
        stats, err := getBuyerStatsFromDB(db, userID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting buyer stats: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get buyer stats"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    stats,
        })</span>
}

// getBuyerStatsFromDB retrieves real buyer statistics from the database
func getBuyerStatsFromDB(db *sql.DB, userID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := map[string]interface{}{
                "totalOrders":        0,
                "totalSpent":         0.0,
                "pendingOrders":      0,
                "deliveredOrders":    0,
                "cancelledOrders":    0,
                "favoriteCategories": []string{},
        }

        // Get order statistics
        orderQuery := `
                SELECT
                        COUNT(*) as total_orders,
                        COALESCE(SUM(total_amount), 0) as total_spent,
                        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_orders,
                        COUNT(CASE WHEN status = 'delivered' THEN 1 END) as delivered_orders,
                        COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_orders
                FROM orders
                WHERE buyer_id = ?
        `

        var totalOrders, pendingOrders, deliveredOrders, cancelledOrders int
        var totalSpent float64
        err := db.QueryRow(orderQuery, userID).Scan(&amp;totalOrders, &amp;totalSpent, &amp;pendingOrders, &amp;deliveredOrders, &amp;cancelledOrders)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stats["totalOrders"] = totalOrders
        stats["totalSpent"] = totalSpent
        stats["pendingOrders"] = pendingOrders
        stats["deliveredOrders"] = deliveredOrders
        stats["cancelledOrders"] = cancelledOrders

        // Get favorite categories (top 3 categories by order count)
        categoryQuery := `
                SELECT p.category, COUNT(*) as order_count
                FROM orders o
                JOIN order_items oi ON o.id = oi.order_id
                JOIN products p ON oi.product_id = p.id
                WHERE o.buyer_id = ? AND o.status != 'cancelled'
                GROUP BY p.category
                ORDER BY order_count DESC
                LIMIT 3
        `

        rows, err := db.Query(categoryQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return stats, nil // Return stats without categories if query fails
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var favoriteCategories []string
        for rows.Next() </span><span class="cov0" title="0">{
                var category string
                var count int

                err := rows.Scan(&amp;category, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">favoriteCategories = append(favoriteCategories, category)</span>
        }
        <span class="cov0" title="0">stats["favoriteCategories"] = favoriteCategories

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

func GetCart(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Get user's cart
        cartItems, err := marketplaceService.GetCart(userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get cart: " + err.Error(),
                })
                return
        }</span>

        // Calculate totals
        <span class="cov0" title="0">var totalAmount float64
        var totalItems int
        for _, item := range cartItems </span><span class="cov0" title="0">{
                totalAmount += item.Price * float64(item.Quantity)
                totalItems += item.Quantity
        }</span>

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": map[string]interface{}{
                        "items":       cartItems,
                        "totalItems":  totalItems,
                        "totalAmount": totalAmount,
                        "currency":    "KES",
                },
        })</span>
}

func AddToCart(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var req struct {
                ProductID string `json:"productId" binding:"required"`
                Quantity  int    `json:"quantity" binding:"required,min=1"`
                Notes     string `json:"notes"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Add to cart
        err := marketplaceService.AddToCart(userID.(string), req.ProductID, req.Quantity)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Failed to add to cart: " + err.Error(),
                })
                return
        }</span>

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Product added to cart successfully",
        })</span>
}

func RemoveFromCart(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get cart item ID from URL parameter
        <span class="cov0" title="0">cartItemID := c.Param("id")
        if cartItemID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Cart item ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Remove from cart
        err := marketplaceService.RemoveFromCart(userID.(string), cartItemID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "cart item not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Cart item not found",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to remove from cart: " + err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Item removed from cart successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// Chama handlers
func GetChamas(c *gin.Context) <span class="cov0" title="0">{
        // Get query parameters
        limitStr := c.DefaultQuery("limit", "20")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Get all public chamas
        chamas, err := chamaService.GetChamas(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get chamas: " + err.Error(),
                })
                return
        }</span>

        // Return chamas
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    chamas,
                "count":   len(chamas),
        })</span>
}

// GetAllChamasForAdmin - Admin endpoint to get all chamas (no filters)
func GetAllChamasForAdmin(c *gin.Context) <span class="cov0" title="0">{
        // Check if user is admin
        userRole := c.GetString("userRole")
        if userRole != "admin" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Only admins can access this endpoint",
                })
                return
        }</span>

        // Get query parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "100")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Get all chamas for admin
        chamas, err := chamaService.GetAllChamasForAdmin(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get chamas for admin: " + err.Error(),
                })
                return
        }</span>

        // Return chamas
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    chamas,
                "count":   len(chamas),
        })</span>
}

func GetUserChamas(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get query parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "20")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Get user's chamas
        chamas, err := chamaService.GetChamasByUser(userID.(string), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get user chamas: " + err.Error(),
                })
                return
        }</span>

        // Return chamas
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    chamas,
                "count":   len(chamas),
        })</span>
}

func CreateChama(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Parse request body with enhanced validation tags
        <span class="cov0" title="0">var req struct {
                Name                  string  `json:"name" binding:"required" validate:"required,min=3,max=100,safe_text,no_sql_injection,no_xss"`
                Description           string  `json:"description" binding:"required" validate:"required,min=10,max=500,safe_text,no_sql_injection,no_xss"`
                Type                  string  `json:"type" binding:"required" validate:"required,alphanumeric"`
                County                string  `json:"county" binding:"required" validate:"required,min=2,max=50,alpha,no_sql_injection,no_xss"`
                Town                  string  `json:"town" binding:"required" validate:"required,min=2,max=50,alpha,no_sql_injection,no_xss"`
                ContributionAmount    float64 `json:"contribution_amount" binding:"required" validate:"required,amount"`
                ContributionFrequency string  `json:"contribution_frequency" binding:"required" validate:"required,alphanumeric"`
                MaxMembers            int     `json:"max_members" binding:"required" validate:"required,min=2,max=1000"`
                IsPublic              bool    `json:"is_public"`
                RequiresApproval      bool    `json:"requires_approval"`
                Rules                 string  `json:"rules" validate:"max=1000,safe_text,no_sql_injection,no_xss"`
                MeetingSchedule       string  `json:"meeting_schedule" validate:"max=200,safe_text,no_sql_injection,no_xss"`
                Members               []struct {
                        UserID string `json:"user_id" validate:"required,uuid"`
                        Role   string `json:"role" validate:"required,alphanumeric"`
                        Status string `json:"status" validate:"required,alphanumeric"`
                } `json:"members"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Additional validation - basic security checks
        <span class="cov0" title="0">if len(req.Name) &lt; 3 || len(req.Name) &gt; 100 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama name must be between 3 and 100 characters",
                })
                return
        }</span>

        <span class="cov0" title="0">if len(req.Description) &lt; 10 || len(req.Description) &gt; 500 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Description must be between 10 and 500 characters",
                })
                return
        }</span>

        <span class="cov0" title="0">if req.ContributionAmount &lt;= 0 || req.ContributionAmount &gt; 10000000 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Contribution amount must be between 1 and 10,000,000",
                })
                return
        }</span>

        <span class="cov0" title="0">if req.MaxMembers &lt; 2 || req.MaxMembers &gt; 1000 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Max members must be between 2 and 1000",
                })
                return
        }</span>

        // Basic sanitization - remove dangerous characters
        <span class="cov0" title="0">req.Name = sanitizeInput(req.Name)
        req.Description = sanitizeInput(req.Description)
        req.Type = sanitizeInput(req.Type)
        req.County = sanitizeInput(req.County)
        req.Town = sanitizeInput(req.Town)
        req.ContributionFrequency = sanitizeInput(req.ContributionFrequency)
        req.Rules = sanitizeInput(req.Rules)
        req.MeetingSchedule = sanitizeInput(req.MeetingSchedule)

        // Get database connection
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Convert string fields to proper types
        var description *string
        if req.Description != "" </span><span class="cov0" title="0">{
                description = &amp;req.Description
        }</span>

        <span class="cov0" title="0">var maxMembers *int
        if req.MaxMembers &gt; 0 </span><span class="cov0" title="0">{
                maxMembers = &amp;req.MaxMembers
        }</span>

        // Parse rules from string to []string (simple split by newlines)
        <span class="cov0" title="0">var rules []string
        if req.Rules != "" </span><span class="cov0" title="0">{
                // For now, treat the entire string as one rule
                // In the future, you might want to parse JSON or split by delimiters
                rules = []string{req.Rules}
        }</span>

        // Parse meeting schedule from string (for now, just store as simple schedule)
        <span class="cov0" title="0">var meetingSchedule *models.MeetingSchedule
        if req.MeetingSchedule != "" </span><span class="cov0" title="0">{
                meetingSchedule = &amp;models.MeetingSchedule{
                        Frequency: "monthly", // Default
                        Time:      "18:00",   // Default
                }
        }</span>

        // Create chama creation model
        <span class="cov0" title="0">creation := &amp;models.ChamaCreation{
                Name:                  req.Name,
                Description:           description,
                Type:                  models.ChamaType(req.Type),
                County:                req.County,
                Town:                  req.Town,
                ContributionAmount:    req.ContributionAmount,
                ContributionFrequency: models.ContributionFrequency(req.ContributionFrequency),
                MaxMembers:            maxMembers,
                IsPublic:              req.IsPublic,
                RequiresApproval:      req.RequiresApproval,
                Rules:                 rules,
                MeetingSchedule:       meetingSchedule,
        }

        // Create the chama
        chama, err := chamaService.CreateChama(creation, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create chama: " + err.Error(),
                })
                return
        }</span>

        // Add additional members to the chama
        <span class="cov0" title="0">if len(req.Members) &gt; 0 </span><span class="cov0" title="0">{
                for _, member := range req.Members </span><span class="cov0" title="0">{
                        // Skip the creator (already added as chairperson)
                        if member.UserID == userID.(string) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Add member to chama
                        <span class="cov0" title="0">err := chamaService.AddMemberToChama(chama.ID, member.UserID, member.Role)
                        if err != nil </span><span class="cov0" title="0">{
                                // Log error but don't fail the entire operation
                                // The chama is already created, so we continue with other members
                                fmt.Printf("Warning: Failed to add member %s to chama %s: %v\n", member.UserID, chama.ID, err)
                                continue</span>
                        }

                        // Update current members count
                        <span class="cov0" title="0">chama.CurrentMembers++</span>
                }

                // Update the chama's current members count in database
                <span class="cov0" title="0">err = chamaService.UpdateChamaMemberCount(chama.ID, chama.CurrentMembers)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Failed to update member count for chama %s: %v\n", chama.ID, err)
                }</span>
        }

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Chama created successfully",
                "data": map[string]interface{}{
                        "id":                     chama.ID,
                        "name":                   chama.Name,
                        "description":            chama.Description,
                        "type":                   chama.Type,
                        "status":                 chama.Status,
                        "county":                 chama.County,
                        "town":                   chama.Town,
                        "contribution_amount":    chama.ContributionAmount,
                        "contribution_frequency": chama.ContributionFrequency,
                        "max_members":            chama.MaxMembers,
                        "current_members":        chama.CurrentMembers,
                        "is_public":              chama.IsPublic,
                        "requires_approval":      chama.RequiresApproval,
                        "created_by":             chama.CreatedBy,
                        "created_at":             chama.CreatedAt,
                },
        })</span>
}

func generateMockMonthlyData(average float64) []float64 <span class="cov0" title="0">{
        data := make([]float64, 12)
        for i := 0; i &lt; 12; i++ </span><span class="cov0" title="0">{
                // Add some variation around the average
                variation := (float64(i%3) - 1) * 500 // -500, 0, +500 variation
                data[i] = average + variation
                if data[i] &lt; 0 </span><span class="cov0" title="0">{
                        data[i] = 0
                }</span>
        }
        <span class="cov0" title="0">return data</span>
}

func getStringValue(s *string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *s</span>
}

func GetChama(c *gin.Context) <span class="cov0" title="0">{
        chamaID := c.Param("id")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Get chama details
        chama, err := chamaService.GetChamaByID(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Chama not found: " + err.Error(),
                })
                return
        }</span>

        // Return chama details
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    chama,
                "message": "Chama details retrieved successfully",
        })</span>
}

func UpdateChama(c *gin.Context) <span class="cov0" title="0">{
        // Get chama ID from URL
        chamaID := c.Param("id")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get user ID from context (set by auth middleware)
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Check if user is chairperson of this chama
        userRole, err := chamaService.GetUserRoleInChama(chamaID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify user role: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">if userRole != "chairperson" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Only chairperson can update chama settings",
                })
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var req struct {
                Name                  *string                 `json:"name,omitempty"`
                Description           *string                 `json:"description,omitempty"`
                IsPublic              *bool                   `json:"is_public,omitempty"`
                RequiresApproval      *bool                   `json:"requires_approval,omitempty"`
                MaxMembers            *int                    `json:"max_members,omitempty"`
                ContributionAmount    *float64                `json:"contribution_amount,omitempty"`
                ContributionFrequency *string                 `json:"contribution_frequency,omitempty"`
                Rules                 *[]string               `json:"rules,omitempty"`
                MeetingSchedule       *map[string]interface{} `json:"meeting_schedule,omitempty"`
                Permissions           *map[string]bool        `json:"permissions,omitempty"`
                Notifications         *map[string]bool        `json:"notifications,omitempty"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Update chama settings
        <span class="cov0" title="0">err = chamaService.UpdateChamaSettings(chamaID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update chama settings: " + err.Error(),
                })
                return
        }</span>

        // Get updated chama details
        <span class="cov0" title="0">updatedChama, err := chamaService.GetChamaByID(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get updated chama details: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    updatedChama,
                "message": "Chama settings updated successfully",
        })</span>
}

func DeleteChama(c *gin.Context) <span class="cov0" title="0">{
        // Get chama ID from URL
        chamaID := c.Param("id")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get user ID from context (set by auth middleware)
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Check if user is chairperson of this chama
        userRole, err := chamaService.GetUserRoleInChama(chamaID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "You are not a member of this chama",
                })
                return
        }</span>

        <span class="cov0" title="0">if userRole != "chairperson" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Only chairperson can delete the chama",
                })
                return
        }</span>

        // Delete the chama (this will cascade delete all related data)
        <span class="cov0" title="0">err = chamaService.DeleteChama(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to delete chama: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Chama deleted successfully",
        })</span>
}

func LeaveChama(c *gin.Context) <span class="cov0" title="0">{
        // Get chama ID from URL
        chamaID := c.Param("id")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get user ID from context (set by auth middleware)
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Check if user is a member of this chama
        userRole, err := chamaService.GetUserRoleInChama(chamaID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "You are not a member of this chama",
                })
                return
        }</span>

        // Check if user is the chairperson - chairperson cannot leave without transferring role
        <span class="cov0" title="0">if userRole == "chairperson" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chairperson cannot leave chama. Please transfer chairperson role first or delete the chama.",
                })
                return
        }</span>

        // Remove user from chama
        <span class="cov0" title="0">err = chamaService.RemoveUserFromChama(chamaID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to leave chama: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Successfully left the chama",
        })</span>
}

func GetChamaMembers(c *gin.Context) <span class="cov0" title="0">{
        chamaID := c.Param("id")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">dbInterface, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>
        <span class="cov0" title="0">db := dbInterface.(*sql.DB)

        // Get real chama members from database with comprehensive information
        query := `
                SELECT
                        cm.id, cm.chama_id, cm.user_id, cm.role, cm.joined_at, cm.is_active,
                        cm.total_contributions, cm.last_contribution, cm.rating, cm.total_ratings,
                        u.first_name, u.last_name, u.email, u.phone, u.avatar, u.status,
                        u.is_email_verified, u.is_phone_verified, u.business_type, u.county, u.town,
                        u.bio, u.occupation, u.created_at as user_created_at,
                        COALESCE(w.balance, 0) as savings_balance,
                        COALESCE(loan_balance.balance, 0) as loan_balance,
                        COALESCE(contrib_stats.monthly_average, 0) as monthly_average,
                        COALESCE(contrib_stats.consistency_rate, 0) as consistency_rate,
                        COALESCE(meeting_stats.meetings_attended, 0) as meetings_attended,
                        COALESCE(meeting_stats.total_meetings, 0) as total_meetings,
                        COALESCE(activity_stats.contributions_made, 0) as contributions_made,
                        COALESCE(activity_stats.loans_taken, 0) as loans_taken,
                        COALESCE(activity_stats.guarantor_requests, 0) as guarantor_requests
                FROM chama_members cm
                INNER JOIN users u ON cm.user_id = u.id
                LEFT JOIN wallets w ON u.id = w.owner_id AND w.type = 'personal'
                LEFT JOIN (
                        SELECT
                                borrower_id,
                                SUM(CASE WHEN status IN ('approved', 'disbursed', 'active') THEN remaining_amount ELSE 0 END) as balance
                        FROM loans
                        WHERE chama_id = ?
                        GROUP BY borrower_id
                ) loan_balance ON u.id = loan_balance.borrower_id
                LEFT JOIN (
                        SELECT
                                t.initiated_by,
                                AVG(t.amount) as monthly_average,
                                (COUNT(*) * 100.0 / 12) as consistency_rate,
                                COUNT(*) as contributions_made
                        FROM transactions t
                        WHERE t.type = 'contribution'
                        AND t.created_at &gt;= datetime('now', '-12 months')
                        GROUP BY t.initiated_by
                ) contrib_stats ON u.id = contrib_stats.initiated_by
                LEFT JOIN (
                        SELECT
                                t.initiated_by,
                                COUNT(*) as contributions_made,
                                0 as loans_taken,
                                0 as guarantor_requests
                        FROM transactions t
                        WHERE t.type = 'contribution'
                        GROUP BY t.initiated_by
                ) activity_stats ON u.id = activity_stats.initiated_by
                LEFT JOIN (
                        SELECT
                                cm.user_id,
                                COUNT(*) as meetings_attended,
                                (SELECT COUNT(*) FROM meetings WHERE chama_id = ?) as total_meetings
                        FROM chama_members cm
                        WHERE cm.chama_id = ?
                        GROUP BY cm.user_id
                ) meeting_stats ON u.id = meeting_stats.user_id
                WHERE cm.chama_id = ? AND cm.is_active = true
                ORDER BY cm.joined_at ASC
        `

        rows, err := db.Query(query, chamaID, chamaID, chamaID, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch chama members: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var members []map[string]interface{}
        activeMembers := 0
        pendingMembers := 0

        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        id, chamaID, userID, role, firstName, lastName, email, phone, userStatus                        string
                        joinedAt, userCreatedAt                                                                         string
                        isActive, isEmailVerified, isPhoneVerified                                                      bool
                        totalContributions, rating, savingsBalance, loanBalance, monthlyAverage, consistencyRate        float64
                        totalRatings, meetingsAttended, totalMeetings, contributionsMade, loansTaken, guarantorRequests int
                        avatar, lastContribution, businessType, county, town, bio, occupation                           *string
                )

                err := rows.Scan(
                        &amp;id, &amp;chamaID, &amp;userID, &amp;role, &amp;joinedAt, &amp;isActive,
                        &amp;totalContributions, &amp;lastContribution, &amp;rating, &amp;totalRatings,
                        &amp;firstName, &amp;lastName, &amp;email, &amp;phone, &amp;avatar, &amp;userStatus,
                        &amp;isEmailVerified, &amp;isPhoneVerified, &amp;businessType, &amp;county, &amp;town,
                        &amp;bio, &amp;occupation, &amp;userCreatedAt,
                        &amp;savingsBalance, &amp;loanBalance, &amp;monthlyAverage, &amp;consistencyRate,
                        &amp;meetingsAttended, &amp;totalMeetings, &amp;contributionsMade, &amp;loansTaken, &amp;guarantorRequests,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid rows
                }

                // Calculate attendance rate
                <span class="cov0" title="0">attendanceRate := 0.0
                if totalMeetings &gt; 0 </span><span class="cov0" title="0">{
                        attendanceRate = (float64(meetingsAttended) / float64(totalMeetings)) * 100
                }</span>

                // Determine online status (mock for now - would need real-time tracking)
                <span class="cov0" title="0">isOnline := userStatus == "active" &amp;&amp; (id == "user-1" || id == "user-3" || id == "user-4")

                // Calculate last contribution amount (mock for now)
                lastContributionAmount := 5000.0
                if totalContributions &gt; 0 </span><span class="cov0" title="0">{
                        lastContributionAmount = monthlyAverage
                }</span>

                // Build member object with real data
                <span class="cov0" title="0">member := map[string]interface{}{
                        "id":                       id,
                        "user_id":                  userID,
                        "chama_id":                 chamaID,
                        "role":                     role,
                        "joined_at":                joinedAt,
                        "status":                   userStatus,
                        "total_contributions":      totalContributions,
                        "last_contribution_date":   lastContribution,
                        "last_contribution_amount": lastContributionAmount,
                        "attendance_rate":          attendanceRate,
                        "loan_balance":             loanBalance,
                        "savings_balance":          savingsBalance,
                        "reputation_score":         rating,
                        "business_type":            businessType,
                        "location":                 fmt.Sprintf("%s, %s", getStringValue(town), getStringValue(county)),
                        "phone_verified":           isPhoneVerified,
                        "email_verified":           isEmailVerified,
                        "user": map[string]interface{}{
                                "id":         userID,
                                "first_name": firstName,
                                "last_name":  lastName,
                                "email":      email,
                                "phone":      phone,
                                "avatar_url": avatar,
                                "bio":        bio,
                                "occupation": occupation,
                                "created_at": userCreatedAt,
                                "last_seen":  joinedAt, // Mock - would need real tracking
                                "is_online":  isOnline,
                        },
                        "contributions_summary": map[string]interface{}{
                                "total_amount":     totalContributions,
                                "monthly_average":  monthlyAverage,
                                "consistency_rate": consistencyRate,
                                "last_12_months":   generateMockMonthlyData(monthlyAverage), // Mock historical data
                        },
                        "activity_summary": map[string]interface{}{
                                "meetings_attended":  meetingsAttended,
                                "total_meetings":     totalMeetings,
                                "last_activity":      joinedAt,
                                "contributions_made": contributionsMade,
                                "loans_taken":        loansTaken,
                                "guarantor_requests": guarantorRequests,
                        },
                }

                members = append(members, member)

                // Count member statuses
                if userStatus == "active" </span><span class="cov0" title="0">{
                        activeMembers++
                }</span> else<span class="cov0" title="0"> {
                        pendingMembers++
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    members,
                "message": "Chama members retrieved successfully",
                "meta": map[string]interface{}{
                        "total_members":   len(members),
                        "active_members":  activeMembers,
                        "pending_members": pendingMembers,
                        "last_updated":    time.Now().Format(time.RFC3339),
                },
        })</span>
}

// SendChamaInvitation sends an invitation to join a chama
func SendChamaInvitation(c *gin.Context) <span class="cov0" title="0">{
        // Get chama ID from URL
        chamaID := c.Param("id")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get user ID from context (set by auth middleware)
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Check if user has permission to invite (chairperson, secretary, treasurer)
        userRole, err := chamaService.GetUserRoleInChama(chamaID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "You are not a member of this chama",
                })
                return
        }</span>

        <span class="cov0" title="0">if !isLeadershipRole(userRole) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Only chairperson, secretary, and treasurer can send invitations",
                })
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var req struct {
                Email           string `json:"email" binding:"required,email"`
                PhoneNumber     string `json:"phone_number,omitempty"`
                Message         string `json:"message,omitempty"`
                Role            string `json:"role,omitempty"`
                RoleName        string `json:"role_name,omitempty"`
                RoleDescription string `json:"role_description,omitempty"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Send invitation
        <span class="cov0" title="0">fmt.Printf("🔍 Sending chama invitation:\n")
        fmt.Printf("  - Chama ID: %s\n", chamaID)
        fmt.Printf("  - User ID: %s\n", userID.(string))
        fmt.Printf("  - Email: %s\n", req.Email)
        fmt.Printf("  - Phone: %s\n", req.PhoneNumber)
        fmt.Printf("  - Message: %s\n", req.Message)

        invitationID, err := chamaService.SendInvitation(chamaID, userID.(string), req.Email, req.PhoneNumber, req.Message, req.Role, req.RoleName, req.RoleDescription)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Chama invitation failed: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to send invitation: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Invitation sent successfully",
                "data": gin.H{
                        "invitation_id": invitationID,
                },
        })</span>
}

// RespondToInvitation handles accepting or rejecting a chama invitation
func RespondToInvitation(c *gin.Context) <span class="cov0" title="0">{
        // Get invitation ID from URL
        invitationID := c.Param("id")
        if invitationID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invitation ID is required",
                })
                return
        }</span>

        // Get user ID from context (set by auth middleware)
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var req struct {
                Response string `json:"response" binding:"required"` // "accept" or "reject"
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">if req.Response != "accept" &amp;&amp; req.Response != "reject" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Response must be 'accept' or 'reject'",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Respond to invitation
        err := chamaService.RespondToInvitation(invitationID, userID.(string), req.Response)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to respond to invitation: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">message := "Invitation rejected"
        if req.Response == "accept" </span><span class="cov0" title="0">{
                message = "Invitation accepted! You are now a member of the chama"
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": message,
        })</span>
}

// GetUserInvitations gets pending invitations for a user
func GetUserInvitations(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Get user invitations
        invitations, err := chamaService.GetUserInvitations(userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get invitations: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    invitations,
                "count":   len(invitations),
        })</span>
}

// GetChamaSentInvitations gets all invitations sent for a specific chama
func GetChamaSentInvitations(c *gin.Context) <span class="cov0" title="0">{
        // Get chama ID from URL
        chamaID := c.Param("id")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get user ID from context (set by auth middleware)
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Check if user has permission to view invitations (chairperson, secretary, treasurer)
        userRole, err := chamaService.GetUserRoleInChama(chamaID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "You are not a member of this chama",
                })
                return
        }</span>

        <span class="cov0" title="0">if !isLeadershipRole(userRole) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Only chairperson, secretary, and treasurer can view sent invitations",
                })
                return
        }</span>

        // Get sent invitations for this chama
        <span class="cov0" title="0">invitations, err := chamaService.GetChamaSentInvitations(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get sent invitations: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    invitations,
                "count":   len(invitations),
        })</span>
}

// CancelInvitation cancels a pending invitation
func CancelInvitation(c *gin.Context) <span class="cov0" title="0">{
        // Get invitation ID from URL
        invitationID := c.Param("id")
        if invitationID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invitation ID is required",
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Update invitation status to cancelled
        <span class="cov0" title="0">result, err := db.(*sql.DB).Exec(`
                UPDATE chama_invitations
                SET status = 'cancelled', responded_at = ?
                WHERE id = ? AND inviter_id = ? AND status = 'pending'
        `, time.Now(), invitationID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to cancel invitation: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Invitation not found or cannot be cancelled",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Invitation cancelled successfully",
        })</span>
}

// ResendInvitation resends a pending invitation
func ResendInvitation(c *gin.Context) <span class="cov0" title="0">{
        // Get invitation ID from URL
        invitationID := c.Param("id")
        if invitationID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invitation ID is required",
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Update invitation with new expiry date
        <span class="cov0" title="0">result, err := db.(*sql.DB).Exec(`
                UPDATE chama_invitations
                SET expires_at = ?
                WHERE id = ? AND inviter_id = ? AND status = 'pending'
        `, time.Now().Add(7*24*time.Hour), invitationID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to resend invitation: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Invitation not found or cannot be resent",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Invitation resent successfully",
        })</span>
}

// GetMemberRole gets a member's role in a chama
func GetMemberRole(c *gin.Context) <span class="cov0" title="0">{
        chamaID := c.Param("id")
        userID := c.Param("userId")

        if chamaID == "" || userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID and User ID are required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Query member role
        <span class="cov0" title="0">query := `SELECT role FROM chama_members WHERE chama_id = ? AND user_id = ? AND is_active = TRUE`
        var role string
        err := db.(*sql.DB).QueryRow(query, chamaID, userID).Scan(&amp;role)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Member not found in this chama",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to get member role",
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "role": role,
                },
        })</span>
}

// Helper function to check if role can send invitations
func isLeadershipRole(role string) bool <span class="cov0" title="0">{
        return role == "chairperson" || role == "secretary" || role == "treasurer"
}</span>

// InviteToChama is an alias for SendChamaInvitation for test compatibility
func InviteToChama(c *gin.Context) <span class="cov0" title="0">{
        SendChamaInvitation(c)
}</span>

// UpdateChamaMember updates a chama member's role or status
func UpdateChamaMember(c *gin.Context) <span class="cov0" title="0">{
        // Get chama ID and member ID from URL
        chamaID := c.Param("id")
        memberID := c.Param("memberId")
        if chamaID == "" || memberID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID and Member ID are required",
                })
                return
        }</span>

        // Get user ID from context (set by auth middleware)
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var req struct {
                Role   string `json:"role"`
                Status string `json:"status"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Check if user has permission to update members (chairperson only)
        userRole, err := chamaService.GetUserRoleInChama(chamaID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "You are not a member of this chama",
                })
                return
        }</span>

        <span class="cov0" title="0">if userRole != "chairperson" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Only chairperson can update member details",
                })
                return
        }</span>

        // Update member role if provided
        <span class="cov0" title="0">if req.Role != "" </span><span class="cov0" title="0">{
                err = chamaService.UpdateMemberRoleSimple(chamaID, memberID, req.Role)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to update member role: " + err.Error(),
                        })
                        return
                }</span>
        }

        // Update member status if provided
        <span class="cov0" title="0">if req.Status != "" </span><span class="cov0" title="0">{
                err = chamaService.UpdateMemberStatus(chamaID, memberID, req.Status)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to update member status: " + err.Error(),
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Member updated successfully",
        })</span>
}

// RemoveChamaMember removes a member from a chama
func RemoveChamaMember(c *gin.Context) <span class="cov0" title="0">{
        // Get chama ID and member ID from URL
        chamaID := c.Param("id")
        memberID := c.Param("memberId")
        if chamaID == "" || memberID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID and Member ID are required",
                })
                return
        }</span>

        // Get user ID from context (set by auth middleware)
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Check if user has permission to remove members (chairperson only)
        userRole, err := chamaService.GetUserRoleInChama(chamaID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "You are not a member of this chama",
                })
                return
        }</span>

        <span class="cov0" title="0">if userRole != "chairperson" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Only chairperson can remove members",
                })
                return
        }</span>

        // Remove member from chama
        <span class="cov0" title="0">err = chamaService.RemoveUserFromChama(chamaID, memberID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to remove member: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Member removed successfully",
        })</span>
}

// GetChamaStatistics returns statistics for a chama
func GetChamaStatistics(c *gin.Context) <span class="cov0" title="0">{
        // Get chama ID from URL
        chamaID := c.Param("id")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get user ID from context (set by auth middleware)
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create chama service
        <span class="cov0" title="0">chamaService := services.NewChamaService(db.(*sql.DB))

        // Check if user is a member of this chama
        _, err := chamaService.GetUserRoleInChama(chamaID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "You are not a member of this chama",
                })
                return
        }</span>

        // Get chama statistics
        <span class="cov0" title="0">stats, err := chamaService.GetChamaStatistics(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get chama statistics: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    stats,
        })</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// GetChatRooms retrieves chat rooms for the authenticated user
func GetChatRooms(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Use the proper chat service
        <span class="cov0" title="0">chatService := services.NewChatService(db.(*sql.DB))
        rooms, err := chatService.GetUserChatRooms(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve chat rooms: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    rooms,
        })</span>
}

// CreateChatRoom creates a new chat room
func CreateChatRoom(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Type        string                 `json:"type" binding:"required"`
                Name        string                 `json:"name"`
                ChamaID     string                 `json:"chamaId"`
                UserIDs     []string               `json:"userIds"`
                RecipientID string                 `json:"recipientId"`
                Context     map[string]interface{} `json:"context"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Failed to bind JSON in CreateChatRoom: %v\n", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("🔍 CreateChatRoom request - UserID: %s, Type: %s, RecipientID: %s\n", userID, req.Type, req.RecipientID)

        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">chatService := services.NewChatService(db.(*sql.DB))

        switch req.Type </span>{
        case "private":<span class="cov0" title="0">
                if req.RecipientID == "" </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Missing RecipientID for private chat\n")
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "Recipient ID required for private chat",
                        })
                        return
                }</span>

                <span class="cov0" title="0">fmt.Printf("🔄 Creating private chat between %s and %s\n", userID, req.RecipientID)

                // Create or get existing private chat room
                room, err := chatService.CreatePrivateChat(userID, req.RecipientID)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Failed to create private chat: %v\n", err)
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to create private chat: " + err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">fmt.Printf("✅ Private chat created successfully: %s\n", room.ID)

                // If context is provided (e.g., product inquiry), send an initial message
                if req.Context != nil </span><span class="cov0" title="0">{
                        if productID, exists := req.Context["productId"]; exists </span><span class="cov0" title="0">{
                                if productName, nameExists := req.Context["productName"]; nameExists </span><span class="cov0" title="0">{
                                        // Send initial context message about the product
                                        contextMessage := fmt.Sprintf("Hi! I'm interested in your product: %s", productName)
                                        metadata := map[string]interface{}{
                                                "type":      "product_inquiry",
                                                "productId": productID,
                                        }

                                        _, err := chatService.SendMessage(room.ID, userID, services.MessageTypeText, contextMessage, metadata, nil)
                                        if err != nil </span><span class="cov0" title="0">{
                                                // Log error but don't fail the chat creation
                                                fmt.Printf("Failed to send initial product inquiry message: %v\n", err)
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                        "success": true,
                        "data":    room,
                })
                return</span>

        case "chama":<span class="cov0" title="0">
                if req.ChamaID == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "Chama ID required for chama chat",
                        })
                        return
                }</span>

                // Create chama chat room
                <span class="cov0" title="0">room, err := chatService.CreateChamaChat(req.ChamaID, userID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to create chama chat: " + err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                        "success": true,
                        "data":    room,
                })
                return</span>

        case "support":<span class="cov0" title="0">
                // For support chats, we need a user ID (the user who needs support)
                supportUserID := req.RecipientID
                if supportUserID == "" &amp;&amp; len(req.UserIDs) &gt; 0 </span><span class="cov0" title="0">{
                        // Try to get it from the UserID field if RecipientID is not provided
                        supportUserID = req.UserIDs[0]
                }</span>

                // Check if we have a userId in the request body
                <span class="cov0" title="0">if supportUserID == "" </span><span class="cov0" title="0">{
                        if userIDFromBody, ok := req.Context["userId"].(string); ok </span><span class="cov0" title="0">{
                                supportUserID = userIDFromBody
                        }</span>
                }

                <span class="cov0" title="0">if supportUserID == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "User ID required for support chat",
                        })
                        return
                }</span>

                <span class="cov0" title="0">fmt.Printf("🔄 Creating support chat for user %s (admin: %s)\n", supportUserID, userID)

                // Create support chat room (similar to private chat but allows admin to chat with user)
                room, err := chatService.CreateSupportChat(userID, supportUserID, req.Context)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Failed to create support chat: %v\n", err)
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to create support chat: " + err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">fmt.Printf("✅ Support chat created successfully: %s\n", room.ID)
                c.JSON(http.StatusCreated, gin.H{
                        "success": true,
                        "data":    room,
                })
                return</span>

        default:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid chat room type",
                })
                return</span>
        }
}

// GetChatRoom retrieves a specific chat room
func GetChatRoom(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        roomID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // For now, return a simple response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "id":     roomID,
                        "name":   "Chat Room",
                        "type":   "private",
                        "userId": userID,
                },
        })</span>
}

// GetChatMessages retrieves messages for a chat room
func GetChatMessages(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        roomID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, _ := strconv.Atoi(limitStr)
        offset, _ := strconv.Atoi(offsetStr)

        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Use the proper chat service
        <span class="cov0" title="0">chatService := services.NewChatService(db.(*sql.DB))
        messages, err := chatService.GetRoomMessages(roomID, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve messages: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    messages,
        })</span>
}

// SendMessage sends a message to a chat room
func SendMessage(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        roomID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Check if this is a multipart/form-data request (file upload)
        <span class="cov0" title="0">contentType := c.GetHeader("Content-Type")
        if strings.Contains(contentType, "multipart/form-data") </span><span class="cov0" title="0">{
                handleFileMessage(c, userID, roomID)
                return
        }</span>

        // Handle regular JSON message
        <span class="cov0" title="0">var req struct {
                Type          string                 `json:"type" binding:"required"`
                Content       string                 `json:"content" binding:"required"`
                Metadata      map[string]interface{} `json:"metadata"`
                ReplyToID     *string                `json:"replyToId"`
                IsEncrypted   bool                   `json:"isEncrypted"`
                SecurityLevel string                 `json:"securityLevel"`
                RecipientID   string                 `json:"recipientId"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get WebSocket service from context
        <span class="cov0" title="0">wsService, wsExists := c.Get("wsService")

        // Use the proper chat service
        chatService := services.NewChatService(db.(*sql.DB))

        var finalContent string
        var finalMetadata map[string]interface{}
        var e2eeMessageID *string

        // Check if message should be encrypted
        if req.IsEncrypted &amp;&amp; req.SecurityLevel == "MILITARY_GRADE" </span><span class="cov0" title="0">{
                fmt.Printf("🔐 Processing military-grade encrypted message from %s\n", userID)

                // Parse encrypted message from content
                var encryptedMsg services.EncryptedMessage
                if err := json.Unmarshal([]byte(req.Content), &amp;encryptedMsg); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "Invalid encrypted message format: " + err.Error(),
                        })
                        return
                }</span>

                // Store the encrypted message in E2EE table
                <span class="cov0" title="0">e2eeMessageID = &amp;encryptedMsg.SenderID // Use a proper ID generation

                // For encrypted messages, store the encrypted content as-is
                finalContent = req.Content
                finalMetadata = map[string]interface{}{
                        "encrypted":     true,
                        "securityLevel": req.SecurityLevel,
                        "e2eeMessageId": *e2eeMessageID,
                }
                if req.Metadata != nil </span><span class="cov0" title="0">{
                        for k, v := range req.Metadata </span><span class="cov0" title="0">{
                                finalMetadata[k] = v
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("✅ Military-grade encrypted message processed\n")</span>
        } else<span class="cov0" title="0"> {
                // Regular unencrypted message
                finalContent = req.Content
                finalMetadata = req.Metadata
        }</span>

        // Convert type string to MessageType
        <span class="cov0" title="0">var messageType services.MessageType
        switch req.Type </span>{
        case "text":<span class="cov0" title="0">
                messageType = services.MessageTypeText</span>
        case "image":<span class="cov0" title="0">
                messageType = services.MessageTypeImage</span>
        case "file":<span class="cov0" title="0">
                messageType = services.MessageTypeFile</span>
        case "military_encrypted_text":<span class="cov0" title="0">
                messageType = services.MessageTypeText</span> // Store as text but mark as encrypted
        default:<span class="cov0" title="0">
                messageType = services.MessageTypeText</span>
        }

        // Send message using chat service
        <span class="cov0" title="0">message, err := chatService.SendMessage(roomID, userID, messageType, finalContent, finalMetadata, req.ReplyToID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to send message: " + err.Error(),
                })
                return
        }</span>

        // Send real-time notification via WebSocket
        <span class="cov0" title="0">if wsExists </span><span class="cov0" title="0">{
                wsMsg := services.WebSocketMessage{
                        Type:   "new_message",
                        RoomID: roomID,
                        Data:   message,
                }
                wsService.(*services.WebSocketService).BroadcastToRoom(roomID, wsMsg)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "data":    message,
        })</span>
}

// MarkMessagesAsRead marks messages as read in a chat room
func MarkMessagesAsRead(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        roomID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">chatService := services.NewChatService(db.(*sql.DB))
        err := chatService.MarkMessagesAsRead(roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to mark messages as read",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Messages marked as read",
        })</span>
}

// GetChatRoomMembers retrieves members of a chat room
func GetChatRoomMembers(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        roomID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">chatService := services.NewChatService(db.(*sql.DB))
        members, err := chatService.GetRoomMembers(roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve room members: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    members,
        })</span>
}

// DeleteChatRoom deletes a chat room for the user
func DeleteChatRoom(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        roomID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">chatService := services.NewChatService(db.(*sql.DB))
        err := chatService.DeleteChatRoom(roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to delete chat room: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Chat room deleted successfully",
        })</span>
}

// ClearChatRoom clears all messages in a chat room for the user
func ClearChatRoom(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        roomID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">chatService := services.NewChatService(db.(*sql.DB))
        err := chatService.ClearChatRoom(roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to clear chat room: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Chat room cleared successfully",
        })</span>
}

// handleFileMessage handles file upload messages
func handleFileMessage(c *gin.Context, userID, roomID string) <span class="cov0" title="0">{
        // Parse multipart form
        err := c.Request.ParseMultipartForm(10 &lt;&lt; 20) // 10 MB max
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Failed to parse multipart form: " + err.Error(),
                })
                return
        }</span>

        // Get form values
        <span class="cov0" title="0">messageType := c.PostForm("type")
        content := c.PostForm("content")
        metadataStr := c.PostForm("metadata")

        // Parse metadata
        var metadata map[string]interface{}
        if metadataStr != "" </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(metadataStr), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                        metadata = make(map[string]interface{})
                }</span>
        } else<span class="cov0" title="0"> {
                metadata = make(map[string]interface{})
        }</span>

        // Handle file upload
        <span class="cov0" title="0">file, header, err := c.Request.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "No file uploaded: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Create uploads directory if it doesn't exist
        uploadsDir := "uploads/chat"
        if err := os.MkdirAll(uploadsDir, 0o755); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create uploads directory: " + err.Error(),
                })
                return
        }</span>

        // Generate unique filename
        <span class="cov0" title="0">fileExt := filepath.Ext(header.Filename)
        fileName := fmt.Sprintf("%s_%d%s", uuid.New().String(), time.Now().Unix(), fileExt)
        filePath := filepath.Join(uploadsDir, fileName)

        // Save file
        dst, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create file: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer dst.Close()

        if _, err := io.Copy(dst, file); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to save file: " + err.Error(),
                })
                return
        }</span>

        // Create file URL with full base URL for frontend access
        <span class="cov0" title="0">fileURL := fmt.Sprintf("http://127.0.0.1:8080/uploads/chat/%s", fileName)

        // Add file URL to metadata
        metadata["fileUrl"] = fileURL
        metadata["fileName"] = header.Filename
        metadata["fileSize"] = header.Size

        // Get database connection
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get WebSocket service from context
        <span class="cov0" title="0">wsService, wsExists := c.Get("wsService")

        // Use the proper chat service
        chatService := services.NewChatService(db.(*sql.DB))

        // Convert type string to MessageType
        var msgType services.MessageType
        switch messageType </span>{
        case "image":<span class="cov0" title="0">
                msgType = services.MessageTypeImage</span>
        case "file":<span class="cov0" title="0">
                msgType = services.MessageTypeFile</span>
        default:<span class="cov0" title="0">
                msgType = services.MessageTypeImage</span> // Default to image for file uploads
        }

        // Send message using chat service
        <span class="cov0" title="0">message, err := chatService.SendMessage(roomID, userID, msgType, content, metadata, nil)
        if err != nil </span><span class="cov0" title="0">{
                // Clean up uploaded file on error
                os.Remove(filePath)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to send message: " + err.Error(),
                })
                return
        }</span>

        // Send real-time notification via WebSocket
        <span class="cov0" title="0">if wsExists </span><span class="cov0" title="0">{
                wsMsg := services.WebSocketMessage{
                        Type:   "new_message",
                        RoomID: roomID,
                        Data:   message,
                }
                wsService.(*services.WebSocketService).BroadcastToRoom(roomID, wsMsg)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "data":    message,
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

// Contribution handlers
func GetContributions(c *gin.Context) <span class="cov0" title="0">{
        chamaID := c.Query("chamaId")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "chamaId parameter is required",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    []interface{}{},
                "message": "No contributions found",
        })</span>
}

func MakeContribution(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ChamaID       string  `json:"chamaId" binding:"required" validate:"required,uuid"`
                Amount        float64 `json:"amount" binding:"required" validate:"required,amount"`
                Description   string  `json:"description" validate:"max=200,safe_text,no_sql_injection,no_xss"`
                Type          string  `json:"type" validate:"alphanumeric"` // "regular", "penalty", "special"
                PaymentMethod string  `json:"paymentMethod" validate:"alphanumeric,max=50"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Enhanced validation
        <span class="cov0" title="0">if req.Amount &lt;= 0 || req.Amount &gt; 10000000 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Amount must be between 1 and 10,000,000 KES",
                })
                return
        }</span>

        // Validate contribution type
        <span class="cov0" title="0">validTypes := map[string]bool{
                "regular": true,
                "penalty": true,
                "special": true,
                "":        true, // Allow empty (defaults to regular)
        }
        if !validTypes[req.Type] </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid contribution type. Must be 'regular', 'penalty', or 'special'",
                })
                return
        }</span>

        // Sanitize inputs
        <span class="cov0" title="0">req.ChamaID = sanitizeInput(req.ChamaID)
        req.Description = sanitizeInput(req.Description)
        req.Type = sanitizeInput(req.Type)
        req.PaymentMethod = sanitizeInput(req.PaymentMethod)

        // Get database connection
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := db.(*sql.DB).Begin()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to start transaction",
                })
                return
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Check if user has sufficient balance in personal wallet
        var personalBalance float64
        err = tx.QueryRow(`
                SELECT COALESCE(balance, 0)
                FROM wallets
                WHERE owner_id = ? AND type = 'personal'
        `, userID).Scan(&amp;personalBalance)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to check wallet balance",
                })
                return
        }</span>

        <span class="cov0" title="0">if personalBalance &lt; req.Amount </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Insufficient balance in personal wallet",
                })
                return
        }</span>

        // Deduct from personal wallet
        <span class="cov0" title="0">_, err = tx.Exec(`
                UPDATE wallets
                SET balance = balance - ?, updated_at = CURRENT_TIMESTAMP
                WHERE owner_id = ? AND type = 'personal'
        `, req.Amount, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to deduct from personal wallet",
                })
                return
        }</span>

        // Add to chama wallet
        <span class="cov0" title="0">_, err = tx.Exec(`
                UPDATE wallets
                SET balance = balance + ?, updated_at = CURRENT_TIMESTAMP
                WHERE owner_id = ? AND type = 'chama'
        `, req.Amount, req.ChamaID)
        if err != nil </span><span class="cov0" title="0">{
                // If chama wallet doesn't exist, create it
                _, err = tx.Exec(`
                        INSERT INTO wallets (id, owner_id, type, balance, created_at, updated_at)
                        VALUES (?, ?, 'chama', ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                `, "wallet-"+req.ChamaID, req.ChamaID, req.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to update chama wallet",
                        })
                        return
                }</span>
        }

        // Record the transaction
        <span class="cov0" title="0">transactionID := fmt.Sprintf("txn-%d", time.Now().UnixNano())
        contributionType := req.Type
        if contributionType == "" </span><span class="cov0" title="0">{
                contributionType = "regular"
        }</span>

        <span class="cov0" title="0">_, err = tx.Exec(`
                INSERT INTO transactions (
                        id, type, amount, description, status, payment_method,
                        initiated_by, recipient_id, created_at, updated_at
                ) VALUES (?, 'contribution', ?, ?, 'completed', ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `, transactionID, req.Amount, req.Description, req.PaymentMethod, userID, req.ChamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to record transaction",
                })
                return
        }</span>

        // Update member's total contributions
        <span class="cov0" title="0">_, err = tx.Exec(`
                UPDATE chama_members
                SET total_contributions = total_contributions + ?,
                    last_contribution = CURRENT_TIMESTAMP,
                    updated_at = CURRENT_TIMESTAMP
                WHERE chama_id = ? AND user_id = ?
        `, req.Amount, req.ChamaID, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update member contributions",
                })
                return
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to commit transaction",
                })
                return
        }</span>

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Contribution made successfully",
                "data": map[string]interface{}{
                        "id":            transactionID,
                        "chamaId":       req.ChamaID,
                        "amount":        req.Amount,
                        "type":          contributionType,
                        "description":   req.Description,
                        "paymentMethod": req.PaymentMethod,
                        "status":        "completed",
                        "contributedBy": userID,
                        "createdAt":     time.Now().Format(time.RFC3339),
                },
        })</span>
}

func GetContribution(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Get contribution endpoint - coming soon",
        })
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// DeliveryContactsHandlers handles delivery contacts API endpoints
type DeliveryContactsHandlers struct {
        db *sql.DB
}

// NewDeliveryContactsHandlers creates a new instance of DeliveryContactsHandlers
func NewDeliveryContactsHandlers(db *sql.DB) *DeliveryContactsHandlers <span class="cov0" title="0">{
        return &amp;DeliveryContactsHandlers{db: db}
}</span>

// GetDeliveryContacts retrieves delivery contacts for the current seller
func (h *DeliveryContactsHandlers) GetDeliveryContacts(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Query delivery contacts
        <span class="cov0" title="0">query := `
                SELECT dc.id, dc.seller_id, dc.user_id, dc.name, dc.phone, dc.email,
                           dc.address, dc.notes, dc.is_active, dc.created_at, dc.updated_at,
                           u.first_name, u.last_name, u.email as user_email, u.phone as user_phone
                FROM delivery_contacts dc
                LEFT JOIN users u ON dc.user_id = u.id
                WHERE dc.seller_id = ?
                ORDER BY dc.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := h.db.Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve delivery contacts",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var contacts []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var id, sellerId, name, phone, email, address, notes, createdAt, updatedAt string
                var userId, userFirstName, userLastName, userEmail, userPhone sql.NullString
                var isActive bool

                err := rows.Scan(
                        &amp;id, &amp;sellerId, &amp;userId, &amp;name, &amp;phone, &amp;email,
                        &amp;address, &amp;notes, &amp;isActive, &amp;createdAt, &amp;updatedAt,
                        &amp;userFirstName, &amp;userLastName, &amp;userEmail, &amp;userPhone,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">contact := map[string]interface{}{
                        "id":        id,
                        "sellerId":  sellerId,
                        "name":      name,
                        "phone":     phone,
                        "email":     email,
                        "address":   address,
                        "notes":     notes,
                        "isActive":  isActive,
                        "createdAt": createdAt,
                        "updatedAt": updatedAt,
                }

                if userId.Valid </span><span class="cov0" title="0">{
                        contact["userId"] = userId.String
                        if userFirstName.Valid &amp;&amp; userLastName.Valid </span><span class="cov0" title="0">{
                                contact["userFullName"] = userFirstName.String + " " + userLastName.String
                        }</span>
                        <span class="cov0" title="0">if userEmail.Valid </span><span class="cov0" title="0">{
                                contact["userEmail"] = userEmail.String
                        }</span>
                        <span class="cov0" title="0">if userPhone.Valid </span><span class="cov0" title="0">{
                                contact["userPhone"] = userPhone.String
                        }</span>
                }

                <span class="cov0" title="0">contacts = append(contacts, contact)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    contacts,
                "count":   len(contacts),
        })</span>
}

// CreateDeliveryContact creates a new delivery contact
func (h *DeliveryContactsHandlers) CreateDeliveryContact(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                UserID   string `json:"userId"`
                Name     string `json:"name" binding:"required"`
                Phone    string `json:"phone"`
                Email    string `json:"email"`
                Address  string `json:"address"`
                Notes    string `json:"notes"`
                IsActive bool   `json:"isActive"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Check if contact already exists for this seller and user
        <span class="cov0" title="0">if req.UserID != "" </span><span class="cov0" title="0">{
                var existingID string
                checkQuery := `SELECT id FROM delivery_contacts WHERE seller_id = ? AND user_id = ?`
                err := h.db.QueryRow(checkQuery, userID, req.UserID).Scan(&amp;existingID)
                if err == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{
                                "success": false,
                                "error":   "This user is already in your delivery contacts",
                        })
                        return
                }</span>
        }

        // Create delivery contact
        <span class="cov0" title="0">contactID := uuid.New().String()
        query := `
                INSERT INTO delivery_contacts (
                        id, seller_id, user_id, name, phone, email, address, notes, is_active, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `

        _, err := h.db.Exec(query, contactID, userID, req.UserID, req.Name, req.Phone, req.Email, req.Address, req.Notes, req.IsActive)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create delivery contact",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "id":       contactID,
                        "name":     req.Name,
                        "phone":    req.Phone,
                        "email":    req.Email,
                        "isActive": req.IsActive,
                },
                "message": "Delivery contact created successfully",
        })</span>
}

// UpdateDeliveryContact updates an existing delivery contact
func (h *DeliveryContactsHandlers) UpdateDeliveryContact(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        contactID := c.Param("contactId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Name     string `json:"name"`
                Phone    string `json:"phone"`
                Email    string `json:"email"`
                Address  string `json:"address"`
                Notes    string `json:"notes"`
                IsActive *bool  `json:"isActive"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Check if contact exists and belongs to the seller
        <span class="cov0" title="0">var existingSellerId string
        checkQuery := `SELECT seller_id FROM delivery_contacts WHERE id = ?`
        err := h.db.QueryRow(checkQuery, contactID).Scan(&amp;existingSellerId)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Delivery contact not found",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to check contact ownership",
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if existingSellerId != userID </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "You can only update your own delivery contacts",
                })
                return
        }</span>

        // Update delivery contact
        <span class="cov0" title="0">query := `
                UPDATE delivery_contacts 
                SET name = ?, phone = ?, email = ?, address = ?, notes = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
        `

        isActive := true
        if req.IsActive != nil </span><span class="cov0" title="0">{
                isActive = *req.IsActive
        }</span>

        <span class="cov0" title="0">_, err = h.db.Exec(query, req.Name, req.Phone, req.Email, req.Address, req.Notes, isActive, contactID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update delivery contact",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delivery contact updated successfully",
        })</span>
}

// DeleteDeliveryContact deletes a delivery contact
func (h *DeliveryContactsHandlers) DeleteDeliveryContact(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        contactID := c.Param("contactId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Check if contact exists and belongs to the seller
        <span class="cov0" title="0">var existingSellerId string
        checkQuery := `SELECT seller_id FROM delivery_contacts WHERE id = ?`
        err := h.db.QueryRow(checkQuery, contactID).Scan(&amp;existingSellerId)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Delivery contact not found",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to check contact ownership",
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if existingSellerId != userID </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "You can only delete your own delivery contacts",
                })
                return
        }</span>

        // Delete delivery contact
        <span class="cov0" title="0">query := `DELETE FROM delivery_contacts WHERE id = ?`
        _, err = h.db.Exec(query, contactID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to delete delivery contact",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delivery contact deleted successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "database/sql"
        "log"
        "net/http"

        "github.com/gin-gonic/gin"
)

// GetDeliveries returns delivery assignments for delivery personnel
func GetDeliveries(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context
        userIDInterface, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>
        <span class="cov0" title="0">userID := userIDInterface.(string)

        status := c.Query("status")

        // Get database connection
        dbInterface, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>
        <span class="cov0" title="0">db := dbInterface.(*sql.DB)

        // Get real delivery data from database
        deliveries, err := getDeliveriesFromDB(db, userID, status)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting deliveries: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get deliveries"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    deliveries,
        })</span>
}

// AcceptDelivery allows delivery personnel to accept a delivery
func AcceptDelivery(c *gin.Context) <span class="cov0" title="0">{
        deliveryID := c.Param("id")
        if deliveryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Delivery ID is required",
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">_, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">_, exists = c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Mock acceptance for now
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delivery accepted successfully",
        })</span>
}

// UpdateDeliveryStatus updates the status of a product delivery
func UpdateDeliveryStatus(c *gin.Context) <span class="cov0" title="0">{
        orderItemID := c.Param("id") // This is the order_item_id
        if orderItemID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Order item ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Status string `json:"status" binding:"required"`
                Notes  string `json:"notes"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userIDInterface, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>
        <span class="cov0" title="0">userID := userIDInterface.(string)

        // Get database connection
        dbInterface, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>
        <span class="cov0" title="0">db := dbInterface.(*sql.DB)

        // Verify this delivery person is assigned to this product
        var assignedDeliveryPersonID string
        checkQuery := `SELECT delivery_person_id FROM order_items WHERE id = ?`
        err := db.QueryRow(checkQuery, orderItemID).Scan(&amp;assignedDeliveryPersonID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Order item not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify delivery assignment",
                })
                return</span>
        }

        // Check if this delivery person is assigned to this product
        <span class="cov0" title="0">if assignedDeliveryPersonID != userID </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "You are not assigned to deliver this product",
                })
                return
        }</span>

        // Update the order delivery status (this affects the whole order)
        // Get the order_id first
        <span class="cov0" title="0">var orderID string
        orderQuery := `SELECT order_id FROM order_items WHERE id = ?`
        err = db.QueryRow(orderQuery, orderItemID).Scan(&amp;orderID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get order information",
                })
                return
        }</span>

        // Update order delivery status
        <span class="cov0" title="0">updateQuery := `
                UPDATE orders
                SET delivery_status = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
        `
        _, err = db.Exec(updateQuery, req.Status, orderID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update delivery status",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delivery status updated successfully",
                "data": map[string]interface{}{
                        "orderItemId": orderItemID,
                        "orderId":     orderID,
                        "status":      req.Status,
                        "notes":       req.Notes,
                },
        })</span>
}

// getDeliveriesFromDB retrieves products assigned to the delivery person
func getDeliveriesFromDB(db *sql.DB, userID, status string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var deliveries []map[string]interface{}

        // Query to get products assigned to this delivery person
        query := `
                SELECT
                        oi.id as order_item_id,
                        oi.order_id,
                        oi.product_id,
                        oi.quantity,
                        oi.price,
                        oi.name as product_name,
                        oi.delivery_person_id,
                        o.delivery_status,
                        o.delivery_address,
                        o.delivery_phone,
                        o.delivery_fee,
                        o.delivery_town,
                        o.delivery_county,
                        o.notes as order_notes,
                        u.first_name as buyer_first_name,
                        u.last_name as buyer_last_name,
                        u.phone as buyer_phone,
                        u.email as buyer_email,
                        p.name as product_full_name,
                        p.description as product_description,
                        p.images as product_images,
                        s.first_name as seller_first_name,
                        s.last_name as seller_last_name
                FROM order_items oi
                JOIN orders o ON oi.order_id = o.id
                JOIN users u ON o.buyer_id = u.id
                JOIN products p ON oi.product_id = p.id
                JOIN users s ON p.seller_id = s.id
                WHERE oi.delivery_person_id = ?
        `

        args := []interface{}{userID}

        // Add status filter if provided
        if status != "" &amp;&amp; status != "all" </span><span class="cov0" title="0">{
                if status == "pending" </span><span class="cov0" title="0">{
                        query += " AND o.delivery_status = 'pending'"
                }</span> else<span class="cov0" title="0"> if status == "assigned" </span><span class="cov0" title="0">{
                        query += " AND o.delivery_status = 'assigned'"
                }</span> else<span class="cov0" title="0"> if status == "in_transit" </span><span class="cov0" title="0">{
                        query += " AND o.delivery_status = 'in_transit'"
                }</span> else<span class="cov0" title="0"> if status == "delivered" </span><span class="cov0" title="0">{
                        query += " AND o.delivery_status = 'delivered'"
                }</span> else<span class="cov0" title="0"> {
                        query += " AND o.delivery_status = ?"
                        args = append(args, status)
                }</span>
        }

        <span class="cov0" title="0">query += " ORDER BY o.created_at DESC"

        rows, err := db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var orderItemID, orderID, productID, productName, deliveryPersonID string
                var deliveryStatus, deliveryAddress, deliveryPhone, deliveryTown, deliveryCounty string
                var orderNotes, buyerFirstName, buyerLastName, buyerPhone, buyerEmail string
                var productFullName, productDescription, productImages string
                var sellerFirstName, sellerLastName string
                var quantity int
                var price, deliveryFee float64

                err := rows.Scan(
                        &amp;orderItemID, &amp;orderID, &amp;productID, &amp;quantity, &amp;price, &amp;productName,
                        &amp;deliveryPersonID, &amp;deliveryStatus, &amp;deliveryAddress, &amp;deliveryPhone,
                        &amp;deliveryFee, &amp;deliveryTown, &amp;deliveryCounty, &amp;orderNotes,
                        &amp;buyerFirstName, &amp;buyerLastName, &amp;buyerPhone, &amp;buyerEmail,
                        &amp;productFullName, &amp;productDescription, &amp;productImages,
                        &amp;sellerFirstName, &amp;sellerLastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">delivery := map[string]interface{}{
                        "id":              orderItemID,
                        "orderItemId":     orderItemID,
                        "orderId":         orderID,
                        "productId":       productID,
                        "quantity":        quantity,
                        "price":           price,
                        "deliveryStatus":  deliveryStatus,
                        "deliveryAddress": deliveryAddress,
                        "deliveryPhone":   deliveryPhone,
                        "deliveryFee":     deliveryFee,
                        "deliveryTown":    deliveryTown,
                        "deliveryCounty":  deliveryCounty,
                        "orderNotes":      orderNotes,
                        "product": map[string]interface{}{
                                "id":          productID,
                                "name":        productFullName,
                                "description": productDescription,
                                "images":      productImages,
                        },
                        "buyer": map[string]interface{}{
                                "firstName": buyerFirstName,
                                "lastName":  buyerLastName,
                                "phone":     buyerPhone,
                                "email":     buyerEmail,
                        },
                        "seller": map[string]interface{}{
                                "firstName": sellerFirstName,
                                "lastName":  sellerLastName,
                        },
                }

                deliveries = append(deliveries, delivery)</span>
        }

        <span class="cov0" title="0">return deliveries, nil</span>
}

// AssignDeliveryPersonToProduct assigns a delivery person to specific products in an order
func AssignDeliveryPersonToProduct(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                OrderItemIDs      []string `json:"orderItemIds" binding:"required"`
                DeliveryPersonID  string   `json:"deliveryPersonId" binding:"required"`
                DeliveryFee       float64  `json:"deliveryFee"`
                EstimatedDelivery string   `json:"estimatedDelivery"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get user ID from context (seller)
        <span class="cov0" title="0">userIDInterface, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>
        <span class="cov0" title="0">userID := userIDInterface.(string)

        // Get database connection
        dbInterface, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>
        <span class="cov0" title="0">db := dbInterface.(*sql.DB)

        // Verify the delivery person exists and is a delivery person
        var deliveryPersonExists bool
        checkDeliveryPersonQuery := `
                SELECT EXISTS(
                        SELECT 1 FROM marketplace_roles
                        WHERE user_id = ? AND role = 'delivery_person'
                )
        `
        err := db.QueryRow(checkDeliveryPersonQuery, req.DeliveryPersonID).Scan(&amp;deliveryPersonExists)
        if err != nil || !deliveryPersonExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid delivery person",
                })
                return
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to start transaction",
                })
                return
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Assign delivery person to each product
        for _, orderItemID := range req.OrderItemIDs </span><span class="cov0" title="0">{
                // Verify the seller owns this product
                var sellerID string
                checkOwnershipQuery := `
                        SELECT p.seller_id
                        FROM order_items oi
                        JOIN products p ON oi.product_id = p.id
                        WHERE oi.id = ?
                `
                err := tx.QueryRow(checkOwnershipQuery, orderItemID).Scan(&amp;sellerID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to verify product ownership",
                        })
                        return
                }</span>

                <span class="cov0" title="0">if sellerID != userID </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "success": false,
                                "error":   "You don't have permission to assign delivery for this product",
                        })
                        return
                }</span>

                // Update the order item with delivery person
                <span class="cov0" title="0">updateQuery := `
                        UPDATE order_items
                        SET delivery_person_id = ?, assigned_at = CURRENT_TIMESTAMP
                        WHERE id = ?
                `
                _, err = tx.Exec(updateQuery, req.DeliveryPersonID, orderItemID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to assign delivery person to product",
                        })
                        return
                }</span>
        }

        // Update the order status to 'assigned'
        <span class="cov0" title="0">if len(req.OrderItemIDs) &gt; 0 </span><span class="cov0" title="0">{
                // Get the order ID from the first item
                var orderID string
                getOrderQuery := `SELECT order_id FROM order_items WHERE id = ?`
                err := tx.QueryRow(getOrderQuery, req.OrderItemIDs[0]).Scan(&amp;orderID)
                if err == nil </span><span class="cov0" title="0">{
                        // Update order delivery status
                        updateOrderQuery := `
                                UPDATE orders
                                SET delivery_status = 'assigned', delivery_person_id = ?, updated_at = CURRENT_TIMESTAMP
                                WHERE id = ?
                        `
                        tx.Exec(updateOrderQuery, req.DeliveryPersonID, orderID)
                }</span>
        }

        // Commit transaction
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to commit assignment",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delivery person assigned to products successfully",
                "data": map[string]interface{}{
                        "orderItemIds":     req.OrderItemIDs,
                        "deliveryPersonId": req.DeliveryPersonID,
                        "assignedAt":       "now",
                },
        })</span>
}

// Legacy function - kept for backward compatibility
func AssignDeliveryPerson(c *gin.Context) <span class="cov0" title="0">{
        orderID := c.Param("id")
        if orderID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Order ID is required",
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // For now, we'll simulate assigning a delivery person
        // In a real implementation, this would integrate with a delivery service
        <span class="cov0" title="0">query := `
                UPDATE orders
                SET delivery_status = 'assigned', updated_at = CURRENT_TIMESTAMP
                WHERE id = ? AND seller_id = ?
        `
        result, err := db.(*sql.DB).Exec(query, orderID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to assign delivery person: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to assign delivery person",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil || rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Order not found or you don't have permission to assign delivery",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delivery person assigned successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

// DisbursementHandlers handles disbursement-related API endpoints
type DisbursementHandlers struct {
        db *sql.DB
}

// NewDisbursementHandlers creates a new instance of DisbursementHandlers
func NewDisbursementHandlers(db *sql.DB) *DisbursementHandlers <span class="cov0" title="0">{
        return &amp;DisbursementHandlers{db: db}
}</span>

// GetDisbursementBatches retrieves disbursement batches for a chama
func (h *DisbursementHandlers) GetDisbursementBatches(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Query disbursement batches
        <span class="cov0" title="0">query := `
                SELECT db.id, db.chama_id, db.batch_type, db.title, db.description,
                           db.total_amount, db.total_recipients, db.status, db.scheduled_date,
                           db.processed_date, db.created_at, db.updated_at,
                           u1.first_name || ' ' || u1.last_name as initiated_by_name,
                           COALESCE(u2.first_name || ' ' || u2.last_name, '') as approved_by_name
                FROM disbursement_batches db
                LEFT JOIN users u1 ON db.initiated_by = u1.id
                LEFT JOIN users u2 ON db.approved_by = u2.id
                WHERE db.chama_id = ?
                ORDER BY db.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := h.db.Query(query, chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve disbursement batches",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var batches []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var id, chamaId, batchType, title, description, status, createdAt, updatedAt, initiatedBy string
                var totalAmount float64
                var totalRecipients int
                var scheduledDate, processedDate sql.NullTime
                var approvedByName sql.NullString

                err := rows.Scan(
                        &amp;id, &amp;chamaId, &amp;batchType, &amp;title,
                        &amp;description, &amp;totalAmount, &amp;totalRecipients,
                        &amp;status, &amp;scheduledDate, &amp;processedDate, &amp;createdAt,
                        &amp;updatedAt, &amp;initiatedBy, &amp;approvedByName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">batch := map[string]interface{}{
                        "id":              id,
                        "chamaId":         chamaId,
                        "batchType":       batchType,
                        "title":           title,
                        "description":     description,
                        "totalAmount":     totalAmount,
                        "totalRecipients": totalRecipients,
                        "status":          status,
                        "createdAt":       createdAt,
                        "updatedAt":       updatedAt,
                        "initiatedBy":     initiatedBy,
                }

                if scheduledDate.Valid </span><span class="cov0" title="0">{
                        batch["scheduledDate"] = scheduledDate.Time
                }</span>
                <span class="cov0" title="0">if processedDate.Valid </span><span class="cov0" title="0">{
                        batch["processedDate"] = processedDate.Time
                }</span>
                <span class="cov0" title="0">if approvedByName.Valid </span><span class="cov0" title="0">{
                        batch["approvedBy"] = approvedByName.String
                }</span>

                <span class="cov0" title="0">batches = append(batches, batch)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    batches,
                "count":   len(batches),
        })</span>
}

// GetTransparencyLog retrieves financial transparency log for a chama
func (h *DisbursementHandlers) GetTransparencyLog(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Query transparency log
        <span class="cov0" title="0">query := `
                SELECT ftl.id, ftl.chama_id, ftl.activity_type, ftl.title, ftl.description,
                           ftl.amount, ftl.currency, ftl.transaction_type, ftl.reference_id,
                           ftl.reference_type, ftl.affected_members, ftl.visibility,
                           ftl.created_at, u.first_name || ' ' || u.last_name as performed_by_name
                FROM financial_transparency_log ftl
                LEFT JOIN users u ON ftl.performed_by = u.id
                WHERE ftl.chama_id = ?
                ORDER BY ftl.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := h.db.Query(query, chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve transparency log",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var logs []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var id, chamaId, activityType, title, description, currency, transactionType, visibility, createdAt, performedBy string
                var amount float64
                var referenceID, referenceType, affectedMembers sql.NullString

                err := rows.Scan(
                        &amp;id, &amp;chamaId, &amp;activityType, &amp;title,
                        &amp;description, &amp;amount, &amp;currency, &amp;transactionType,
                        &amp;referenceID, &amp;referenceType, &amp;affectedMembers, &amp;visibility,
                        &amp;createdAt, &amp;performedBy,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">log := map[string]interface{}{
                        "id":              id,
                        "chamaId":         chamaId,
                        "activityType":    activityType,
                        "title":           title,
                        "description":     description,
                        "amount":          amount,
                        "currency":        currency,
                        "transactionType": transactionType,
                        "visibility":      visibility,
                        "createdAt":       createdAt,
                        "performedBy":     performedBy,
                }

                if referenceID.Valid </span><span class="cov0" title="0">{
                        log["referenceId"] = referenceID.String
                }</span>
                <span class="cov0" title="0">if referenceType.Valid </span><span class="cov0" title="0">{
                        log["referenceType"] = referenceType.String
                }</span>
                <span class="cov0" title="0">if affectedMembers.Valid </span><span class="cov0" title="0">{
                        log["affectedMembers"] = affectedMembers.String
                }</span>

                <span class="cov0" title="0">logs = append(logs, log)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    logs,
                "count":   len(logs),
        })</span>
}

// ProcessDisbursementBatch processes a disbursement batch
func (h *DisbursementHandlers) ProcessDisbursementBatch(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        batchID := c.Param("batchId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // For now, just mark as processed
        <span class="cov0" title="0">query := `UPDATE disbursement_batches SET status = 'completed', processed_date = CURRENT_TIMESTAMP WHERE id = ? AND chama_id = ?`
        _, err := h.db.Exec(query, batchID, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to process disbursement batch",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Disbursement batch processed successfully",
        })</span>
}

// ApproveDisbursementBatch approves a disbursement batch
func (h *DisbursementHandlers) ApproveDisbursementBatch(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        batchID := c.Param("batchId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Update batch status to approved
        <span class="cov0" title="0">query := `UPDATE disbursement_batches SET status = 'approved', approved_by = ? WHERE id = ? AND chama_id = ?`
        _, err := h.db.Exec(query, userID, batchID, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to approve disbursement batch",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Disbursement batch approved successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "strconv"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// DividendsHandlers handles dividend-related HTTP requests
type DividendsHandlers struct {
        dividendsService *services.DividendsService
}

// NewDividendsHandlers creates a new dividends handlers instance
func NewDividendsHandlers(db *sql.DB) *DividendsHandlers <span class="cov0" title="0">{
        return &amp;DividendsHandlers{
                dividendsService: services.NewDividendsService(db),
        }
}</span>

// DeclareDividend creates a new dividend declaration
func (h *DividendsHandlers) DeclareDividend(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.DividendResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendResponse{
                        Success: false,
                        Error:   "Chama ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateDividendDeclarationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">declaration, err := h.dividendsService.DeclareDividend(chamaID, userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, models.DividendResponse{
                Success: true,
                Data:    declaration,
                Message: "Dividend declared successfully",
        })</span>
}

// GetChamaDividendDeclarations retrieves dividend declarations for a chama
func (h *DividendsHandlers) GetChamaDividendDeclarations(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.DividendDeclarationsListResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendDeclarationsListResponse{
                        Success: false,
                        Error:   "Chama ID is required",
                })
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">declarations, err := h.dividendsService.GetChamaDividendDeclarations(chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.DividendDeclarationsListResponse{
                        Success: false,
                        Error:   "Failed to retrieve dividend declarations",
                })
                return
        }</span>

        // Convert to basic declarations for response
        <span class="cov0" title="0">basicDeclarations := make([]models.DividendDeclaration, len(declarations))
        for i, decl := range declarations </span><span class="cov0" title="0">{
                basicDeclarations[i] = decl.DividendDeclaration
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.DividendDeclarationsListResponse{
                Success: true,
                Data:    basicDeclarations,
                Count:   len(basicDeclarations),
        })</span>
}

// GetDividendDeclarationDetails retrieves detailed information about a dividend declaration
func (h *DividendsHandlers) GetDividendDeclarationDetails(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        declarationID := c.Param("declarationId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.DividendResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" || declarationID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendResponse{
                        Success: false,
                        Error:   "Chama ID and Declaration ID are required",
                })
                return
        }</span>

        // Get declarations and find the specific one
        <span class="cov0" title="0">declarations, err := h.dividendsService.GetChamaDividendDeclarations(chamaID, 100, 0)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.DividendResponse{
                        Success: false,
                        Error:   "Failed to retrieve dividend declaration",
                })
                return
        }</span>

        <span class="cov0" title="0">var targetDeclaration *models.DividendDeclarationWithDetails
        for _, decl := range declarations </span><span class="cov0" title="0">{
                if decl.ID == declarationID </span><span class="cov0" title="0">{
                        targetDeclaration = &amp;decl
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetDeclaration == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.DividendResponse{
                        Success: false,
                        Error:   "Dividend declaration not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.DividendResponse{
                Success: true,
                Data:    targetDeclaration,
        })</span>
}

// ApproveDividend approves a dividend declaration
func (h *DividendsHandlers) ApproveDividend(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        declarationID := c.Param("declarationId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.DividendResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" || declarationID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendResponse{
                        Success: false,
                        Error:   "Chama ID and Declaration ID are required",
                })
                return
        }</span>

        <span class="cov0" title="0">declaration, err := h.dividendsService.ApproveDividend(declarationID, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.DividendResponse{
                Success: true,
                Data:    declaration,
                Message: "Dividend approved successfully",
        })</span>
}

// ProcessDividendPayments processes dividend payments for a declaration
func (h *DividendsHandlers) ProcessDividendPayments(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        declarationID := c.Param("declarationId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.DividendResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" || declarationID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendResponse{
                        Success: false,
                        Error:   "Chama ID and Declaration ID are required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.ProcessDividendPaymentsRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">err := h.dividendsService.ProcessDividendPayments(declarationID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.DividendResponse{
                Success: true,
                Message: "Dividend payments processed successfully",
        })</span>
}

// GetMemberDividendHistory retrieves dividend history for a member
func (h *DividendsHandlers) GetMemberDividendHistory(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        memberID := c.Param("memberId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.DividendPaymentsListResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" || memberID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendPaymentsListResponse{
                        Success: false,
                        Error:   "Chama ID and Member ID are required",
                })
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">payments, err := h.dividendsService.GetMemberDividendHistory(chamaID, memberID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.DividendPaymentsListResponse{
                        Success: false,
                        Error:   "Failed to retrieve dividend history",
                })
                return
        }</span>

        // Convert to basic payments for response
        <span class="cov0" title="0">basicPayments := make([]models.DividendPayment, len(payments))
        for i, payment := range payments </span><span class="cov0" title="0">{
                basicPayments[i] = payment.DividendPayment
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.DividendPaymentsListResponse{
                Success: true,
                Data:    basicPayments,
                Count:   len(basicPayments),
        })</span>
}

// GetMyDividendHistory retrieves dividend history for the authenticated user
func (h *DividendsHandlers) GetMyDividendHistory(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.DividendPaymentsListResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.DividendPaymentsListResponse{
                        Success: false,
                        Error:   "Chama ID is required",
                })
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">payments, err := h.dividendsService.GetMemberDividendHistory(chamaID, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.DividendPaymentsListResponse{
                        Success: false,
                        Error:   "Failed to retrieve dividend history",
                })
                return
        }</span>

        // Convert to basic payments for response
        <span class="cov0" title="0">basicPayments := make([]models.DividendPayment, len(payments))
        for i, payment := range payments </span><span class="cov0" title="0">{
                basicPayments[i] = payment.DividendPayment
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.DividendPaymentsListResponse{
                Success: true,
                Data:    basicPayments,
                Count:   len(basicPayments),
        })</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "database/sql"
        "net/http"

        "github.com/gin-gonic/gin"

        "vaultke-backend/internal/services"
)

// InitializeE2EEKeys initializes military-grade E2EE keys for a user
func InitializeE2EEKeys(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Initialize E2EE service
        <span class="cov0" title="0">e2eeService := services.NewMilitaryGradeE2EEService(db.(*sql.DB))

        // Initialize keys for the user
        keyBundle, err := e2eeService.InitializeUserKeys(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to initialize E2EE keys: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "keyBundle":     keyBundle,
                        "securityLevel": "MILITARY_GRADE",
                        "features": []string{
                                "PERFECT_FORWARD_SECRECY",
                                "POST_COMPROMISE_SECURITY",
                                "AUTHENTICATED_ENCRYPTION",
                                "METADATA_PROTECTION",
                                "CURVE25519_KEY_EXCHANGE",
                        },
                },
        })</span>
}

// GetE2EEKeyBundle retrieves a user's public key bundle
func GetE2EEKeyBundle(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("userId")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "User ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Initialize E2EE service
        <span class="cov0" title="0">e2eeService := services.NewMilitaryGradeE2EEService(db.(*sql.DB))

        // Get key bundle for the user
        keyBundle, err := e2eeService.GetKeyBundle(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Key bundle not found: " + err.Error(),
                })
                return
        }</span>

        // Return only public components (never return private keys)
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "userId":          keyBundle.UserID,
                        "identityKey":     keyBundle.IdentityKey,
                        "signedPreKey":    keyBundle.SignedPreKey,
                        "preKeySignature": keyBundle.PreKeySignature,
                        "oneTimePreKeys":  keyBundle.OneTimePreKeys,
                        "registrationId":  keyBundle.RegistrationID,
                        "securityLevel":   "MILITARY_GRADE",
                },
        })</span>
}

// EncryptMessage encrypts a message using military-grade E2EE
func EncryptMessage(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                RecipientID string                 `json:"recipientId" binding:"required"`
                Plaintext   string                 `json:"plaintext" binding:"required"`
                Metadata    map[string]interface{} `json:"metadata"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request: " + err.Error(),
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Initialize E2EE service
        <span class="cov0" title="0">e2eeService := services.NewMilitaryGradeE2EEService(db.(*sql.DB))

        // Encrypt the message
        encryptedMessage, err := e2eeService.EncryptMessage(userID, req.RecipientID, req.Plaintext, req.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to encrypt message: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    encryptedMessage,
        })</span>
}

// DecryptMessage decrypts a military-grade encrypted message
func DecryptMessage(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req services.EncryptedMessage
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid encrypted message: " + err.Error(),
                })
                return
        }</span>

        // Verify user is authorized to decrypt this message
        <span class="cov0" title="0">if req.RecipientID != userID </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Not authorized to decrypt this message",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Initialize E2EE service
        <span class="cov0" title="0">e2eeService := services.NewMilitaryGradeE2EEService(db.(*sql.DB))

        // Decrypt the message
        plaintext, metadata, err := e2eeService.DecryptMessage(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to decrypt message: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "plaintext": plaintext,
                        "metadata":  metadata,
                        "verified":  true,
                },
        })</span>
}

// GetE2EESecurityStatus returns the security status of the E2EE system
func GetE2EESecurityStatus(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "securityLevel": "MILITARY_GRADE",
                        "features": []string{
                                "PERFECT_FORWARD_SECRECY",
                                "POST_COMPROMISE_SECURITY",
                                "AUTHENTICATED_ENCRYPTION_AES_256_GCM",
                                "CURVE25519_KEY_EXCHANGE",
                                "HKDF_KEY_DERIVATION",
                                "HMAC_SHA256_AUTHENTICATION",
                                "METADATA_PROTECTION",
                                "CONSTANT_TIME_OPERATIONS",
                                "SIDE_CHANNEL_RESISTANCE",
                        },
                        "algorithms": gin.H{
                                "encryption":     "AES-256-GCM",
                                "keyExchange":    "Curve25519",
                                "keyDerivation":  "HKDF-SHA-256",
                                "authentication": "HMAC-SHA-256",
                                "hashing":        "SHA-256",
                        },
                        "status":  "ACTIVE",
                        "version": "1.0",
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// FinancialReportsHandlers handles financial reports API endpoints
type FinancialReportsHandlers struct {
        db *sql.DB
}

// NewFinancialReportsHandlers creates a new instance of FinancialReportsHandlers
func NewFinancialReportsHandlers(db *sql.DB) *FinancialReportsHandlers <span class="cov0" title="0">{
        return &amp;FinancialReportsHandlers{db: db}
}</span>

// GetFinancialReports retrieves financial reports for a chama
func (h *FinancialReportsHandlers) GetFinancialReports(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Query financial reports
        <span class="cov0" title="0">query := `
                SELECT fr.id, fr.chama_id, fr.report_type, fr.title, fr.description,
                           fr.report_period_start, fr.report_period_end, fr.file_path,
                           fr.file_size, fr.status, fr.download_count, fr.is_public,
                           fr.created_at, fr.updated_at,
                           u.first_name || ' ' || u.last_name as generated_by_name
                FROM financial_reports fr
                LEFT JOIN users u ON fr.generated_by = u.id
                WHERE fr.chama_id = ?
                ORDER BY fr.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := h.db.Query(query, chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve financial reports",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reports []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var id, chamaId, reportType, title, description, status, createdAt, updatedAt, generatedBy string
                var downloadCount int
                var isPublic bool
                var periodStart, periodEnd sql.NullTime
                var filePath sql.NullString
                var fileSize sql.NullInt64

                err := rows.Scan(
                        &amp;id, &amp;chamaId, &amp;reportType, &amp;title,
                        &amp;description, &amp;periodStart, &amp;periodEnd, &amp;filePath,
                        &amp;fileSize, &amp;status, &amp;downloadCount, &amp;isPublic,
                        &amp;createdAt, &amp;updatedAt, &amp;generatedBy,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">report := map[string]interface{}{
                        "id":            id,
                        "chamaId":       chamaId,
                        "reportType":    reportType,
                        "title":         title,
                        "description":   description,
                        "status":        status,
                        "downloadCount": downloadCount,
                        "isPublic":      isPublic,
                        "createdAt":     createdAt,
                        "updatedAt":     updatedAt,
                        "generatedBy":   generatedBy,
                }

                if periodStart.Valid </span><span class="cov0" title="0">{
                        report["reportPeriodStart"] = periodStart.Time
                }</span>
                <span class="cov0" title="0">if periodEnd.Valid </span><span class="cov0" title="0">{
                        report["reportPeriodEnd"] = periodEnd.Time
                }</span>
                <span class="cov0" title="0">if filePath.Valid </span><span class="cov0" title="0">{
                        report["filePath"] = filePath.String
                }</span>
                <span class="cov0" title="0">if fileSize.Valid </span><span class="cov0" title="0">{
                        report["fileSize"] = float64(fileSize.Int64) / (1024 * 1024) // Convert to MB
                }</span>

                <span class="cov0" title="0">reports = append(reports, report)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    reports,
                "count":   len(reports),
        })</span>
}

// GenerateFinancialReport generates a new financial report
func (h *FinancialReportsHandlers) GenerateFinancialReport(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ReportType        string    `json:"reportType" binding:"required"`
                Title             string    `json:"title"`
                Description       string    `json:"description"`
                ReportPeriodStart time.Time `json:"reportPeriodStart"`
                ReportPeriodEnd   time.Time `json:"reportPeriodEnd"`
                IsPublic          bool      `json:"isPublic"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Generate default title if not provided
        <span class="cov0" title="0">if req.Title == "" </span><span class="cov0" title="0">{
                switch req.ReportType </span>{
                case "monthly_statement":<span class="cov0" title="0">
                        req.Title = "Monthly Financial Statement"</span>
                case "dividend_report":<span class="cov0" title="0">
                        req.Title = "Dividend Distribution Report"</span>
                case "transparency_report":<span class="cov0" title="0">
                        req.Title = "Financial Transparency Report"</span>
                default:<span class="cov0" title="0">
                        req.Title = "Financial Report"</span>
                }
        }

        // Create report record
        <span class="cov0" title="0">reportID := uuid.New().String()
        query := `
                INSERT INTO financial_reports (
                        id, chama_id, report_type, title, description,
                        report_period_start, report_period_end, generated_by,
                        status, is_public, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'generating', ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `

        _, err := h.db.Exec(query, reportID, chamaID, req.ReportType, req.Title,
                req.Description, req.ReportPeriodStart, req.ReportPeriodEnd,
                userID, req.IsPublic)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create report",
                })
                return
        }</span>

        // In a real implementation, you would trigger background report generation here
        // For now, we'll just mark it as ready after a short delay
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                time.Sleep(2 * time.Second)
                updateQuery := `UPDATE financial_reports SET status = 'ready', file_size = 2048000 WHERE id = ?`
                h.db.Exec(updateQuery, reportID)
        }</span>()

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "id":         reportID,
                        "reportType": req.ReportType,
                        "title":      req.Title,
                        "status":     "generating",
                },
                "message": "Report generation started",
        })</span>
}

// DownloadFinancialReport downloads a financial report
func (h *FinancialReportsHandlers) DownloadFinancialReport(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        reportID := c.Param("reportId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Check if report exists and is ready
        <span class="cov0" title="0">var status string
        query := `SELECT status FROM financial_reports WHERE id = ? AND chama_id = ?`
        err := h.db.QueryRow(query, reportID, chamaID).Scan(&amp;status)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Report not found",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to check report status",
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if status != "ready" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Report is not ready for download",
                })
                return
        }</span>

        // Increment download count
        <span class="cov0" title="0">updateQuery := `UPDATE financial_reports SET download_count = download_count + 1 WHERE id = ?`
        h.db.Exec(updateQuery, reportID)

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Report download started",
                "data": gin.H{
                        "downloadUrl": "/api/v1/reports/" + reportID + "/download",
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package api

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// CreateLearningCategory creates a new learning category (admin only)
func CreateLearningCategory(c *gin.Context) <span class="cov0" title="0">{
        userRole := c.GetString("userRole")

        if userRole != "admin" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Admin access required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Name        string `json:"name" binding:"required"`
                Description string `json:"description"`
                Icon        string `json:"icon"`
                Color       string `json:"color"`
                SortOrder   int    `json:"sort_order"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">categoryID := uuid.New().String()
        now := time.Now()

        query := `
                INSERT INTO learning_categories 
                (id, name, description, icon, color, sort_order, is_active, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, true, ?, ?)
        `

        _, err := db.(*sql.DB).Exec(query, categoryID, req.Name, req.Description,
                req.Icon, req.Color, req.SortOrder, now, now)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create category",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success":     true,
                "message":     "Category created successfully",
                "category_id": categoryID,
        })</span>
}

// UpdateLearningCategory updates a learning category (admin only)
func UpdateLearningCategory(c *gin.Context) <span class="cov0" title="0">{
        userRole := c.GetString("userRole")
        categoryID := c.Param("id")

        if userRole != "admin" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Admin access required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Name        string `json:"name"`
                Description string `json:"description"`
                Icon        string `json:"icon"`
                Color       string `json:"color"`
                SortOrder   int    `json:"sort_order"`
                IsActive    *bool  `json:"is_active"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Build dynamic update query
        <span class="cov0" title="0">updates := []string{}
        args := []interface{}{}

        if req.Name != "" </span><span class="cov0" title="0">{
                updates = append(updates, "name = ?")
                args = append(args, req.Name)
        }</span>
        <span class="cov0" title="0">if req.Description != "" </span><span class="cov0" title="0">{
                updates = append(updates, "description = ?")
                args = append(args, req.Description)
        }</span>
        <span class="cov0" title="0">if req.Icon != "" </span><span class="cov0" title="0">{
                updates = append(updates, "icon = ?")
                args = append(args, req.Icon)
        }</span>
        <span class="cov0" title="0">if req.Color != "" </span><span class="cov0" title="0">{
                updates = append(updates, "color = ?")
                args = append(args, req.Color)
        }</span>
        <span class="cov0" title="0">if req.SortOrder &gt; 0 </span><span class="cov0" title="0">{
                updates = append(updates, "sort_order = ?")
                args = append(args, req.SortOrder)
        }</span>
        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                updates = append(updates, "is_active = ?")
                args = append(args, *req.IsActive)
        }</span>

        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "No fields to update",
                })
                return
        }</span>

        <span class="cov0" title="0">updates = append(updates, "updated_at = ?")
        args = append(args, time.Now())
        args = append(args, categoryID)

        query := "UPDATE learning_categories SET " +
                updates[0]
        for i := 1; i &lt; len(updates); i++ </span><span class="cov0" title="0">{
                query += ", " + updates[i]
        }</span>
        <span class="cov0" title="0">query += " WHERE id = ?"

        result, err := db.(*sql.DB).Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update category",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Category not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Category updated successfully",
        })</span>
}

// CreateLearningCourse creates a new learning course (admin only)
func CreateLearningCourse(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        userRole := c.GetString("userRole")

        if userRole != "admin" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Admin access required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Title              string   `json:"title" binding:"required"`
                Description        string   `json:"description" binding:"required"`
                CategoryID         string   `json:"category_id" binding:"required"`
                Level              string   `json:"level" binding:"required"`
                Type               string   `json:"type" binding:"required"`
                Content            string   `json:"content"`
                ThumbnailURL       string   `json:"thumbnail_url"`
                DurationMinutes    int      `json:"duration_minutes"`
                EstimatedReadTime  string   `json:"estimated_read_time"`
                Tags               []string `json:"tags"`
                Prerequisites      []string `json:"prerequisites"`
                LearningObjectives []string `json:"learning_objectives"`
                Status             string   `json:"status"`
                IsFeatured         bool     `json:"is_featured"`
                // Enhanced content fields
                VideoURL        string           `json:"video_url"`
                QuizQuestions   []QuizQuestion   `json:"quiz_questions"`
                ArticleContent  *ArticleContent  `json:"article_content"`
                CourseStructure *CourseStructure `json:"course_structure"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to bind JSON for course creation: %v", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Debug logging for enhanced content structures
        <span class="cov0" title="0">log.Printf("📝 Creating course with type: %s", req.Type)
        if req.ArticleContent != nil </span><span class="cov0" title="0">{
                log.Printf("📰 Article content received with %d sections", len(req.ArticleContent.Sections))
        }</span>
        <span class="cov0" title="0">if req.CourseStructure != nil </span><span class="cov0" title="0">{
                log.Printf("📚 Course structure received with %d topics", len(req.CourseStructure.Topics))
        }</span>
        <span class="cov0" title="0">if len(req.QuizQuestions) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("🧪 Quiz questions received: %d questions", len(req.QuizQuestions))
        }</span>

        // Validate level
        <span class="cov0" title="0">if req.Level != "beginner" &amp;&amp; req.Level != "intermediate" &amp;&amp; req.Level != "advanced" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid level. Must be: beginner, intermediate, or advanced",
                })
                return
        }</span>

        // Validate type
        <span class="cov0" title="0">if req.Type != "article" &amp;&amp; req.Type != "video" &amp;&amp; req.Type != "course" &amp;&amp; req.Type != "quiz" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid type. Must be: article, video, course, or quiz",
                })
                return
        }</span>

        // Validate status
        <span class="cov0" title="0">if req.Status == "" </span><span class="cov0" title="0">{
                req.Status = "draft"
        }</span>
        <span class="cov0" title="0">if req.Status != "draft" &amp;&amp; req.Status != "published" &amp;&amp; req.Status != "archived" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid status. Must be: draft, published, or archived",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if category exists
        <span class="cov0" title="0">var categoryExists bool
        err := db.(*sql.DB).QueryRow("SELECT EXISTS(SELECT 1 FROM learning_categories WHERE id = ? AND is_active = true)", req.CategoryID).Scan(&amp;categoryExists)
        if err != nil || !categoryExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid category ID",
                })
                return
        }</span>

        <span class="cov0" title="0">courseID := uuid.New().String()
        now := time.Now()

        // Convert arrays and objects to JSON
        tagsJSON, _ := json.Marshal(req.Tags)
        prerequisitesJSON, _ := json.Marshal(req.Prerequisites)
        objectivesJSON, _ := json.Marshal(req.LearningObjectives)

        // Convert enhanced content to JSON
        var quizQuestionsJSON, articleContentJSON, courseStructureJSON []byte
        if req.QuizQuestions != nil &amp;&amp; len(req.QuizQuestions) &gt; 0 </span><span class="cov0" title="0">{
                quizQuestionsJSON, _ = json.Marshal(req.QuizQuestions)
        }</span> else<span class="cov0" title="0"> {
                quizQuestionsJSON = []byte("[]") // Empty array
        }</span>
        <span class="cov0" title="0">if req.ArticleContent != nil </span><span class="cov0" title="0">{
                articleContentJSON, _ = json.Marshal(req.ArticleContent)
        }</span> else<span class="cov0" title="0"> {
                articleContentJSON = []byte("null") // Null value
        }</span>
        <span class="cov0" title="0">if req.CourseStructure != nil </span><span class="cov0" title="0">{
                courseStructureJSON, _ = json.Marshal(req.CourseStructure)
        }</span> else<span class="cov0" title="0"> {
                courseStructureJSON = []byte("null") // Null value
        }</span>

        // Consolidate content based on course type
        <span class="cov0" title="0">var mainContent string
        switch req.Type </span>{
        case "video":<span class="cov0" title="0">
                if req.VideoURL != "" </span><span class="cov0" title="0">{
                        mainContent = req.VideoURL
                }</span> else<span class="cov0" title="0"> {
                        mainContent = req.Content // Fallback to provided content
                }</span>
        case "quiz":<span class="cov0" title="0">
                if len(req.QuizQuestions) &gt; 0 </span><span class="cov0" title="0">{
                        contentData := map[string]interface{}{
                                "type":        "quiz",
                                "questions":   req.QuizQuestions,
                                "description": req.Content, // Use content as quiz description
                        }
                        contentJSON, _ := json.Marshal(contentData)
                        mainContent = string(contentJSON)
                }</span> else<span class="cov0" title="0"> {
                        mainContent = req.Content
                }</span>
        case "article":<span class="cov0" title="0">
                if req.ArticleContent != nil &amp;&amp; len(req.ArticleContent.Sections) &gt; 0 </span><span class="cov0" title="0">{
                        contentData := map[string]interface{}{
                                "type":           "article",
                                "headline_image": req.ArticleContent.HeadlineImage,
                                "sections":       req.ArticleContent.Sections,
                                "description":    req.Content, // Use content as article description
                        }
                        contentJSON, _ := json.Marshal(contentData)
                        mainContent = string(contentJSON)
                }</span> else<span class="cov0" title="0"> {
                        mainContent = req.Content
                }</span>
        case "course":<span class="cov0" title="0">
                if req.CourseStructure != nil &amp;&amp; len(req.CourseStructure.Topics) &gt; 0 </span><span class="cov0" title="0">{
                        contentData := map[string]interface{}{
                                "type":        "course",
                                "outline":     req.CourseStructure.Outline,
                                "topics":      req.CourseStructure.Topics,
                                "description": req.Content, // Use content as course description
                        }
                        contentJSON, _ := json.Marshal(contentData)
                        mainContent = string(contentJSON)
                }</span> else<span class="cov0" title="0"> {
                        mainContent = req.Content
                }</span>
        default:<span class="cov0" title="0">
                mainContent = req.Content</span> // For any other type, use the provided content
        }

        // Check if enhanced content columns exist, if not, use basic query
        <span class="cov0" title="0">var hasEnhancedColumns bool
        checkQuery := `SELECT COUNT(*) FROM pragma_table_info('learning_courses') WHERE name IN ('video_url', 'quiz_questions', 'article_content', 'course_structure')`
        err = db.(*sql.DB).QueryRow(checkQuery).Scan(&amp;hasEnhancedColumns)
        if err != nil </span><span class="cov0" title="0">{
                hasEnhancedColumns = false
        }</span>

        <span class="cov0" title="0">var query string
        var args []interface{}

        if hasEnhancedColumns </span><span class="cov0" title="0">{
                // Use enhanced query with new columns
                query = `
                        INSERT INTO learning_courses
                        (id, title, description, category_id, level, type, content, thumbnail_url,
                         duration_minutes, estimated_read_time, tags, prerequisites, learning_objectives,
                         status, is_featured, video_url, quiz_questions, article_content, course_structure,
                         created_by, created_at, updated_at)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                `
                args = []interface{}{
                        courseID, req.Title, req.Description, req.CategoryID,
                        req.Level, req.Type, mainContent, req.ThumbnailURL, req.DurationMinutes,
                        req.EstimatedReadTime, string(tagsJSON), string(prerequisitesJSON),
                        string(objectivesJSON), req.Status, req.IsFeatured, req.VideoURL,
                        string(quizQuestionsJSON), string(articleContentJSON), string(courseStructureJSON),
                        userID, now, now,
                }
        }</span> else<span class="cov0" title="0"> {
                // Use basic query without enhanced columns
                query = `
                        INSERT INTO learning_courses
                        (id, title, description, category_id, level, type, content, thumbnail_url,
                         duration_minutes, estimated_read_time, tags, prerequisites, learning_objectives,
                         status, is_featured, created_by, created_at, updated_at)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                `
                args = []interface{}{
                        courseID, req.Title, req.Description, req.CategoryID,
                        req.Level, req.Type, mainContent, req.ThumbnailURL, req.DurationMinutes,
                        req.EstimatedReadTime, string(tagsJSON), string(prerequisitesJSON),
                        string(objectivesJSON), req.Status, req.IsFeatured, userID, now, now,
                }
        }</span>

        <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create course: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   fmt.Sprintf("Failed to create course: %v", err),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success":   true,
                "message":   "Course created successfully",
                "course_id": courseID,
        })</span>
}

// UpdateLearningCourse updates an existing learning course (admin only)
func UpdateLearningCourse(c *gin.Context) <span class="cov0" title="0">{
        userRole := c.GetString("userRole")
        courseID := c.Param("id")

        if userRole != "admin" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Admin access required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Title              string   `json:"title"`
                Description        string   `json:"description"`
                CategoryID         string   `json:"category_id"`
                Level              string   `json:"level"`
                Type               string   `json:"type"`
                Content            string   `json:"content"`
                ThumbnailURL       string   `json:"thumbnail_url"`
                DurationMinutes    int      `json:"duration_minutes"`
                EstimatedReadTime  string   `json:"estimated_read_time"`
                Tags               []string `json:"tags"`
                Prerequisites      []string `json:"prerequisites"`
                LearningObjectives []string `json:"learning_objectives"`
                Status             string   `json:"status"`
                IsFeatured         *bool    `json:"is_featured"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Build dynamic update query
        <span class="cov0" title="0">updates := []string{}
        args := []interface{}{}

        if req.Title != "" </span><span class="cov0" title="0">{
                updates = append(updates, "title = ?")
                args = append(args, req.Title)
        }</span>
        <span class="cov0" title="0">if req.Description != "" </span><span class="cov0" title="0">{
                updates = append(updates, "description = ?")
                args = append(args, req.Description)
        }</span>
        <span class="cov0" title="0">if req.CategoryID != "" </span><span class="cov0" title="0">{
                // Verify category exists
                var categoryExists bool
                err := db.(*sql.DB).QueryRow("SELECT EXISTS(SELECT 1 FROM learning_categories WHERE id = ? AND is_active = true)", req.CategoryID).Scan(&amp;categoryExists)
                if err != nil || !categoryExists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "Invalid category ID",
                        })
                        return
                }</span>
                <span class="cov0" title="0">updates = append(updates, "category_id = ?")
                args = append(args, req.CategoryID)</span>
        }
        <span class="cov0" title="0">if req.Level != "" </span><span class="cov0" title="0">{
                if req.Level != "beginner" &amp;&amp; req.Level != "intermediate" &amp;&amp; req.Level != "advanced" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "Invalid level. Must be: beginner, intermediate, or advanced",
                        })
                        return
                }</span>
                <span class="cov0" title="0">updates = append(updates, "level = ?")
                args = append(args, req.Level)</span>
        }
        <span class="cov0" title="0">if req.Type != "" </span><span class="cov0" title="0">{
                if req.Type != "article" &amp;&amp; req.Type != "video" &amp;&amp; req.Type != "course" &amp;&amp; req.Type != "quiz" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "Invalid type. Must be: article, video, course, or quiz",
                        })
                        return
                }</span>
                <span class="cov0" title="0">updates = append(updates, "type = ?")
                args = append(args, req.Type)</span>
        }
        <span class="cov0" title="0">if req.Content != "" </span><span class="cov0" title="0">{
                updates = append(updates, "content = ?")
                args = append(args, req.Content)
        }</span>
        <span class="cov0" title="0">if req.ThumbnailURL != "" </span><span class="cov0" title="0">{
                updates = append(updates, "thumbnail_url = ?")
                args = append(args, req.ThumbnailURL)
        }</span>
        <span class="cov0" title="0">if req.DurationMinutes &gt; 0 </span><span class="cov0" title="0">{
                updates = append(updates, "duration_minutes = ?")
                args = append(args, req.DurationMinutes)
        }</span>
        <span class="cov0" title="0">if req.EstimatedReadTime != "" </span><span class="cov0" title="0">{
                updates = append(updates, "estimated_read_time = ?")
                args = append(args, req.EstimatedReadTime)
        }</span>
        <span class="cov0" title="0">if req.Tags != nil </span><span class="cov0" title="0">{
                tagsJSON, _ := json.Marshal(req.Tags)
                updates = append(updates, "tags = ?")
                args = append(args, string(tagsJSON))
        }</span>
        <span class="cov0" title="0">if req.Prerequisites != nil </span><span class="cov0" title="0">{
                prerequisitesJSON, _ := json.Marshal(req.Prerequisites)
                updates = append(updates, "prerequisites = ?")
                args = append(args, string(prerequisitesJSON))
        }</span>
        <span class="cov0" title="0">if req.LearningObjectives != nil </span><span class="cov0" title="0">{
                objectivesJSON, _ := json.Marshal(req.LearningObjectives)
                updates = append(updates, "learning_objectives = ?")
                args = append(args, string(objectivesJSON))
        }</span>
        <span class="cov0" title="0">if req.Status != "" </span><span class="cov0" title="0">{
                if req.Status != "draft" &amp;&amp; req.Status != "published" &amp;&amp; req.Status != "archived" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "Invalid status. Must be: draft, published, or archived",
                        })
                        return
                }</span>
                <span class="cov0" title="0">updates = append(updates, "status = ?")
                args = append(args, req.Status)</span>
        }
        <span class="cov0" title="0">if req.IsFeatured != nil </span><span class="cov0" title="0">{
                updates = append(updates, "is_featured = ?")
                args = append(args, *req.IsFeatured)
        }</span>

        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "No fields to update",
                })
                return
        }</span>

        <span class="cov0" title="0">updates = append(updates, "updated_at = ?")
        args = append(args, time.Now())
        args = append(args, courseID)

        query := "UPDATE learning_courses SET " +
                updates[0]
        for i := 1; i &lt; len(updates); i++ </span><span class="cov0" title="0">{
                query += ", " + updates[i]
        }</span>
        <span class="cov0" title="0">query += " WHERE id = ?"

        result, err := db.(*sql.DB).Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update course",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Course not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Course updated successfully",
        })</span>
}

// DeleteLearningCourse deletes a learning course (admin only)
func DeleteLearningCourse(c *gin.Context) <span class="cov0" title="0">{
        userRole := c.GetString("userRole")
        courseID := c.Param("id")

        if userRole != "admin" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Admin access required",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Delete the course (this will cascade delete lessons, progress, etc.)
        <span class="cov0" title="0">result, err := db.(*sql.DB).Exec("DELETE FROM learning_courses WHERE id = ?", courseID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to delete course",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Course not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Course deleted successfully",
        })</span>
}

// DeleteLearningCategory deletes a learning category (admin only)
func DeleteLearningCategory(c *gin.Context) <span class="cov0" title="0">{
        userRole := c.GetString("userRole")
        categoryID := c.Param("id")

        if userRole != "admin" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Admin access required",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if category has courses
        <span class="cov0" title="0">var courseCount int
        err := db.(*sql.DB).QueryRow("SELECT COUNT(*) FROM learning_courses WHERE category_id = ?", categoryID).Scan(&amp;courseCount)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to check category usage",
                })
                return
        }</span>

        <span class="cov0" title="0">if courseCount &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   fmt.Sprintf("Cannot delete category. It has %d courses. Please move or delete the courses first.", courseCount),
                })
                return
        }</span>

        // Delete the category
        <span class="cov0" title="0">result, err := db.(*sql.DB).Exec("DELETE FROM learning_categories WHERE id = ?", categoryID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to delete category",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Category not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Category deleted successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// Learning category structure
type LearningCategory struct {
        ID          string    `json:"id"`
        Name        string    `json:"name"`
        Description string    `json:"description"`
        Icon        string    `json:"icon"`
        Color       string    `json:"color"`
        SortOrder   int       `json:"sort_order"`
        IsActive    bool      `json:"is_active"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

// Learning course structure
type LearningCourse struct {
        ID                 string              `json:"id"`
        Title              string              `json:"title"`
        Description        string              `json:"description"`
        CategoryID         string              `json:"category_id"`
        CategoryName       string              `json:"category_name,omitempty"`
        Level              string              `json:"level"`
        Type               string              `json:"type"`
        Content            string              `json:"content"`
        ThumbnailURL       string              `json:"thumbnail_url"`
        DurationMinutes    int                 `json:"duration_minutes"`
        EstimatedReadTime  string              `json:"estimated_read_time"`
        Tags               []string            `json:"tags"`
        Prerequisites      []string            `json:"prerequisites"`
        LearningObjectives []string            `json:"learning_objectives"`
        Status             string              `json:"status"`
        IsFeatured         bool                `json:"is_featured"`
        ViewCount          int                 `json:"view_count"`
        Rating             float64             `json:"rating"`
        TotalRatings       int                 `json:"total_ratings"`
        CreatedBy          string              `json:"created_by"`
        CreatedByName      string              `json:"created_by_name,omitempty"`
        CreatedAt          time.Time           `json:"created_at"`
        UpdatedAt          time.Time           `json:"updated_at"`
        UserProgress       *UserCourseProgress `json:"user_progress,omitempty"`
        // Enhanced content fields
        VideoURL        string           `json:"video_url,omitempty"`
        QuizQuestions   []QuizQuestion   `json:"quiz_questions,omitempty"`
        ArticleContent  *ArticleContent  `json:"article_content,omitempty"`
        CourseStructure *CourseStructure `json:"course_structure,omitempty"`
}

// Enhanced content type structures
type QuizQuestion struct {
        Question      string   `json:"question"`
        Options       []string `json:"options"`
        CorrectAnswer int      `json:"correct_answer"`
        Explanation   string   `json:"explanation,omitempty"`
}

// Enhanced ArticleContent structure matching frontend
type ArticleContent struct {
        HeadlineImage   string           `json:"headline_image"`
        Author          string           `json:"author"`
        PublicationDate string           `json:"publication_date"`
        ReadingTime     int              `json:"reading_time"`
        Excerpt         string           `json:"excerpt"`
        Tags            []string         `json:"tags"`
        Hashtags        []string         `json:"hashtags"`
        SEOKeywords     []string         `json:"seo_keywords"`
        References      []string         `json:"references"`
        TableOfContents bool             `json:"table_of_contents"`
        Sections        []ArticleSection `json:"sections"`
        Conclusion      string           `json:"conclusion"`
        CallToAction    string           `json:"call_to_action"`
        RelatedArticles []string         `json:"related_articles"`
        SocialSharing   bool             `json:"social_sharing"`
        CommentsEnabled bool             `json:"comments_enabled"`
}

// Enhanced ArticleSection structure
type ArticleSection struct {
        HeadingType  string `json:"headingType"` // h1, h2, h3, h4 - matches frontend
        Heading      string `json:"heading"`
        Content      string `json:"content"`
        ImageURL     string `json:"image_url,omitempty"`
        ImageCaption string `json:"image_caption,omitempty"`
        Quote        string `json:"quote,omitempty"`
        Order        int    `json:"order"`
}

// Enhanced CourseStructure matching frontend
type CourseStructure struct {
        Outline               string             `json:"outline"`
        Topics                []CourseTopic      `json:"topics"`
        TotalDuration         int                `json:"total_duration"`
        DifficultyProgression string             `json:"difficulty_progression"`
        Prerequisites         []string           `json:"prerequisites"`
        CompletionCriteria    CompletionCriteria `json:"completion_criteria"`
}

// Enhanced CourseTopic structure
type CourseTopic struct {
        Title              string           `json:"title"`
        Description        string           `json:"description"`
        LearningObjectives []string         `json:"learning_objectives"`
        EstimatedDuration  int              `json:"estimated_duration"`
        Subtopics          []CourseSubtopic `json:"subtopics"`
}

// Enhanced CourseSubtopic structure
type CourseSubtopic struct {
        Title              string     `json:"title"`
        Content            string     `json:"content"`
        ContentType        string     `json:"content_type"` // text, video, image, mixed
        EstimatedDuration  int        `json:"estimated_duration"`
        LearningObjectives []string   `json:"learning_objectives"`
        Resources          []string   `json:"resources"`
        Examples           []string   `json:"examples"`
        Exercises          []string   `json:"exercises"`
        VideoURL           string     `json:"video_url,omitempty"`
        ImageURL           string     `json:"image_url,omitempty"`
        Documents          []Document `json:"documents,omitempty"`
}

// Document structure for file attachments
type Document struct {
        Name string `json:"name"`
        URI  string `json:"uri"`
        Type string `json:"type"`
        Size int64  `json:"size"`
}

// CompletionCriteria structure
type CompletionCriteria struct {
        MinTopicsCompleted  int  `json:"min_topics_completed"`
        MinScoreRequired    int  `json:"min_score_required"`
        RequireAllExercises bool `json:"require_all_exercises"`
}

// User course progress structure
type UserCourseProgress struct {
        ID                 string     `json:"id"`
        UserID             string     `json:"user_id"`
        CourseID           string     `json:"course_id"`
        Status             string     `json:"status"`
        ProgressPercentage float64    `json:"progress_percentage"`
        CurrentLessonID    *string    `json:"current_lesson_id"`
        StartedAt          *time.Time `json:"started_at"`
        CompletedAt        *time.Time `json:"completed_at"`
        LastAccessedAt     time.Time  `json:"last_accessed_at"`
        TimeSpentMinutes   int        `json:"time_spent_minutes"`
}

// GetLearningCategories returns all learning categories
func GetLearningCategories(c *gin.Context) <span class="cov0" title="0">{
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, name, description, icon, color, sort_order, is_active, created_at, updated_at
                FROM learning_categories 
                WHERE is_active = true
                ORDER BY sort_order ASC, name ASC
        `

        rows, err := db.(*sql.DB).Query(query)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch categories",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var categories []LearningCategory
        for rows.Next() </span><span class="cov0" title="0">{
                var category LearningCategory
                var description, icon, color sql.NullString

                err := rows.Scan(
                        &amp;category.ID, &amp;category.Name, &amp;description, &amp;icon, &amp;color,
                        &amp;category.SortOrder, &amp;category.IsActive, &amp;category.CreatedAt, &amp;category.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">category.Description = description.String
                category.Icon = icon.String
                category.Color = color.String
                categories = append(categories, category)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success":    true,
                "categories": categories,
        })</span>
}

// GetLearningCategory returns a single learning category by ID
func GetLearningCategory(c *gin.Context) <span class="cov0" title="0">{
        categoryID := c.Param("id")
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, name, description, icon, color, sort_order, is_active, created_at, updated_at
                FROM learning_categories
                WHERE id = ?
        `

        var category LearningCategory
        var description, icon, color sql.NullString

        err := db.(*sql.DB).QueryRow(query, categoryID).Scan(
                &amp;category.ID, &amp;category.Name, &amp;description, &amp;icon, &amp;color,
                &amp;category.SortOrder, &amp;category.IsActive, &amp;category.CreatedAt, &amp;category.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Category not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch category",
                })
                return</span>
        }

        <span class="cov0" title="0">category.Description = description.String
        category.Icon = icon.String
        category.Color = color.String

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    category,
        })</span>
}

// GetLearningCourses returns courses with optional filtering
func GetLearningCourses(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">categoryID := c.Query("category_id")
        level := c.Query("level")
        courseType := c.Query("type")
        featured := c.Query("featured")
        search := c.Query("search")
        limit := c.DefaultQuery("limit", "20")
        offset := c.DefaultQuery("offset", "0")

        limitInt, _ := strconv.Atoi(limit)
        offsetInt, _ := strconv.Atoi(offset)

        // Build query
        query := `
                SELECT
                        lc.id, lc.title, lc.description, lc.category_id, lc.level, lc.type,
                        lc.content, lc.thumbnail_url, lc.duration_minutes, lc.estimated_read_time,
                        lc.tags, lc.prerequisites, lc.learning_objectives, lc.status,
                        lc.is_featured, lc.view_count, lc.rating, lc.total_ratings,
                        lc.created_by, lc.created_at, lc.updated_at,
                        lc.video_url, lc.quiz_questions, lc.article_content, lc.course_structure,
                        cat.name as category_name,
                        u.first_name || ' ' || u.last_name as created_by_name
                FROM learning_courses lc
                LEFT JOIN learning_categories cat ON lc.category_id = cat.id
                LEFT JOIN users u ON lc.created_by = u.id
                WHERE lc.status = 'published'
        `

        args := []interface{}{}
        argIndex := 1

        if categoryID != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND lc.category_id = $%d", argIndex)
                args = append(args, categoryID)
                argIndex++
        }</span>

        <span class="cov0" title="0">if level != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND lc.level = $%d", argIndex)
                args = append(args, level)
                argIndex++
        }</span>

        <span class="cov0" title="0">if courseType != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND lc.type = $%d", argIndex)
                args = append(args, courseType)
                argIndex++
        }</span>

        <span class="cov0" title="0">if featured == "true" </span><span class="cov0" title="0">{
                query += " AND lc.is_featured = true"
        }</span>

        <span class="cov0" title="0">if search != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND (lc.title ILIKE $%d OR lc.description ILIKE $%d)", argIndex, argIndex)
                args = append(args, "%"+search+"%")
                argIndex++
        }</span>

        <span class="cov0" title="0">query += " ORDER BY lc.is_featured DESC, lc.created_at DESC"
        query += fmt.Sprintf(" LIMIT $%d OFFSET $%d", argIndex, argIndex+1)
        args = append(args, limitInt, offsetInt)

        rows, err := db.(*sql.DB).Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch courses",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var courses []LearningCourse
        for rows.Next() </span><span class="cov0" title="0">{
                var course LearningCourse
                var content, thumbnailURL, estimatedReadTime sql.NullString
                var tags, prerequisites, objectives sql.NullString
                var videoURL, quizQuestions, articleContent, courseStructure sql.NullString
                var categoryName, createdByName sql.NullString

                err := rows.Scan(
                        &amp;course.ID, &amp;course.Title, &amp;course.Description, &amp;course.CategoryID,
                        &amp;course.Level, &amp;course.Type, &amp;content, &amp;thumbnailURL,
                        &amp;course.DurationMinutes, &amp;estimatedReadTime, &amp;tags, &amp;prerequisites,
                        &amp;objectives, &amp;course.Status, &amp;course.IsFeatured, &amp;course.ViewCount,
                        &amp;course.Rating, &amp;course.TotalRatings, &amp;course.CreatedBy,
                        &amp;course.CreatedAt, &amp;course.UpdatedAt, &amp;videoURL, &amp;quizQuestions,
                        &amp;articleContent, &amp;courseStructure, &amp;categoryName, &amp;createdByName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">course.Content = content.String
                course.ThumbnailURL = thumbnailURL.String
                course.EstimatedReadTime = estimatedReadTime.String
                course.VideoURL = videoURL.String
                course.CategoryName = categoryName.String
                course.CreatedByName = createdByName.String

                // Parse JSON fields
                if tags.Valid </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(tags.String), &amp;course.Tags)
                }</span>
                <span class="cov0" title="0">if prerequisites.Valid </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(prerequisites.String), &amp;course.Prerequisites)
                }</span>
                <span class="cov0" title="0">if objectives.Valid </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(objectives.String), &amp;course.LearningObjectives)
                }</span>

                // Parse enhanced content fields
                <span class="cov0" title="0">if quizQuestions.Valid &amp;&amp; quizQuestions.String != "" </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(quizQuestions.String), &amp;course.QuizQuestions)
                }</span>
                <span class="cov0" title="0">if articleContent.Valid &amp;&amp; articleContent.String != "" </span><span class="cov0" title="0">{
                        var content ArticleContent
                        if json.Unmarshal([]byte(articleContent.String), &amp;content) == nil </span><span class="cov0" title="0">{
                                course.ArticleContent = &amp;content
                        }</span>
                }
                <span class="cov0" title="0">if courseStructure.Valid &amp;&amp; courseStructure.String != "" </span><span class="cov0" title="0">{
                        var structure CourseStructure
                        if json.Unmarshal([]byte(courseStructure.String), &amp;structure) == nil </span><span class="cov0" title="0">{
                                course.CourseStructure = &amp;structure
                        }</span>
                }

                // Parse main content field if it contains structured data
                <span class="cov0" title="0">if course.Content != "" </span><span class="cov0" title="0">{
                        var contentData map[string]interface{}
                        if json.Unmarshal([]byte(course.Content), &amp;contentData) == nil </span><span class="cov0" title="0">{
                                // Check if this is structured content
                                if contentType, exists := contentData["type"]; exists </span><span class="cov0" title="0">{
                                        switch contentType </span>{
                                        case "quiz":<span class="cov0" title="0">
                                                if questions, ok := contentData["questions"].([]interface{}); ok </span><span class="cov0" title="0">{
                                                        questionsJSON, _ := json.Marshal(questions)
                                                        json.Unmarshal(questionsJSON, &amp;course.QuizQuestions)
                                                }</span>
                                        case "article":<span class="cov0" title="0">
                                                if sections, ok := contentData["sections"].([]interface{}); ok </span><span class="cov0" title="0">{
                                                        if headlineImage, ok := contentData["headline_image"].(string); ok </span><span class="cov0" title="0">{
                                                                course.ArticleContent = &amp;ArticleContent{
                                                                        HeadlineImage: headlineImage,
                                                                }
                                                                sectionsJSON, _ := json.Marshal(sections)
                                                                json.Unmarshal(sectionsJSON, &amp;course.ArticleContent.Sections)
                                                        }</span>
                                                }
                                        case "course":<span class="cov0" title="0">
                                                if topics, ok := contentData["topics"].([]interface{}); ok </span><span class="cov0" title="0">{
                                                        if outline, ok := contentData["outline"].(string); ok </span><span class="cov0" title="0">{
                                                                course.CourseStructure = &amp;CourseStructure{
                                                                        Outline: outline,
                                                                }
                                                                topicsJSON, _ := json.Marshal(topics)
                                                                json.Unmarshal(topicsJSON, &amp;course.CourseStructure.Topics)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                        // For video type, if content is just a URL, set it as video_url
                        <span class="cov0" title="0">if course.Type == "video" &amp;&amp; course.VideoURL == "" &amp;&amp; isValidURL(course.Content) </span><span class="cov0" title="0">{
                                course.VideoURL = course.Content
                        }</span>
                }

                // Get user progress if user is authenticated
                <span class="cov0" title="0">if userID != "" </span><span class="cov0" title="0">{
                        course.UserProgress = getUserCourseProgress(db.(*sql.DB), userID, course.ID)
                }</span>

                <span class="cov0" title="0">courses = append(courses, course)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "courses": courses,
                "total":   len(courses),
        })</span>
}

// Helper function to get user course progress
func getUserCourseProgress(db *sql.DB, userID, courseID string) *UserCourseProgress <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, course_id, status, progress_percentage, current_lesson_id,
                           started_at, completed_at, last_accessed_at, time_spent_minutes
                FROM user_course_progress 
                WHERE user_id = ? AND course_id = ?
        `

        var progress UserCourseProgress
        var currentLessonID sql.NullString
        var startedAt, completedAt sql.NullTime

        err := db.QueryRow(query, userID, courseID).Scan(
                &amp;progress.ID, &amp;progress.UserID, &amp;progress.CourseID, &amp;progress.Status,
                &amp;progress.ProgressPercentage, &amp;currentLessonID, &amp;startedAt,
                &amp;completedAt, &amp;progress.LastAccessedAt, &amp;progress.TimeSpentMinutes,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if currentLessonID.Valid </span><span class="cov0" title="0">{
                progress.CurrentLessonID = &amp;currentLessonID.String
        }</span>
        <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                progress.StartedAt = &amp;startedAt.Time
        }</span>
        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                progress.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov0" title="0">return &amp;progress</span>
}

// GetLearningCourse returns a single course by ID
func GetLearningCourse(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        courseID := c.Param("id")

        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">query := `
                SELECT
                        lc.id, lc.title, lc.description, lc.category_id, lc.level, lc.type,
                        lc.content, lc.thumbnail_url, lc.duration_minutes, lc.estimated_read_time,
                        lc.tags, lc.prerequisites, lc.learning_objectives, lc.status,
                        lc.is_featured, lc.view_count, lc.rating, lc.total_ratings,
                        lc.created_by, lc.created_at, lc.updated_at,
                        lc.video_url, lc.quiz_questions, lc.article_content, lc.course_structure,
                        cat.name as category_name,
                        u.first_name || ' ' || u.last_name as created_by_name
                FROM learning_courses lc
                LEFT JOIN learning_categories cat ON lc.category_id = cat.id
                LEFT JOIN users u ON lc.created_by = u.id
                WHERE lc.id = ?
        `

        var course LearningCourse
        var content, thumbnailURL, estimatedReadTime sql.NullString
        var tags, prerequisites, objectives sql.NullString
        var videoURL, quizQuestions, articleContent, courseStructure sql.NullString
        var categoryName, createdByName sql.NullString

        err := db.(*sql.DB).QueryRow(query, courseID).Scan(
                &amp;course.ID, &amp;course.Title, &amp;course.Description, &amp;course.CategoryID,
                &amp;course.Level, &amp;course.Type, &amp;content, &amp;thumbnailURL,
                &amp;course.DurationMinutes, &amp;estimatedReadTime, &amp;tags, &amp;prerequisites,
                &amp;objectives, &amp;course.Status, &amp;course.IsFeatured, &amp;course.ViewCount,
                &amp;course.Rating, &amp;course.TotalRatings, &amp;course.CreatedBy,
                &amp;course.CreatedAt, &amp;course.UpdatedAt, &amp;videoURL, &amp;quizQuestions,
                &amp;articleContent, &amp;courseStructure, &amp;categoryName, &amp;createdByName,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Course not found",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to fetch course",
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">course.Content = content.String
        course.ThumbnailURL = thumbnailURL.String
        course.EstimatedReadTime = estimatedReadTime.String
        course.VideoURL = videoURL.String
        course.CategoryName = categoryName.String
        course.CreatedByName = createdByName.String

        // Parse JSON fields
        if tags.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(tags.String), &amp;course.Tags)
        }</span>
        <span class="cov0" title="0">if prerequisites.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(prerequisites.String), &amp;course.Prerequisites)
        }</span>
        <span class="cov0" title="0">if objectives.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(objectives.String), &amp;course.LearningObjectives)
        }</span>

        // Parse enhanced content fields
        <span class="cov0" title="0">if quizQuestions.Valid &amp;&amp; quizQuestions.String != "" </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(quizQuestions.String), &amp;course.QuizQuestions)
        }</span>
        <span class="cov0" title="0">if articleContent.Valid &amp;&amp; articleContent.String != "" </span><span class="cov0" title="0">{
                var content ArticleContent
                if json.Unmarshal([]byte(articleContent.String), &amp;content) == nil </span><span class="cov0" title="0">{
                        course.ArticleContent = &amp;content
                }</span>
        }
        <span class="cov0" title="0">if courseStructure.Valid &amp;&amp; courseStructure.String != "" </span><span class="cov0" title="0">{
                var structure CourseStructure
                if json.Unmarshal([]byte(courseStructure.String), &amp;structure) == nil </span><span class="cov0" title="0">{
                        course.CourseStructure = &amp;structure
                }</span>
        }

        // Parse main content field if it contains structured data
        <span class="cov0" title="0">if course.Content != "" </span><span class="cov0" title="0">{
                var contentData map[string]interface{}
                if json.Unmarshal([]byte(course.Content), &amp;contentData) == nil </span><span class="cov0" title="0">{
                        // Check if this is structured content
                        if contentType, exists := contentData["type"]; exists </span><span class="cov0" title="0">{
                                switch contentType </span>{
                                case "quiz":<span class="cov0" title="0">
                                        if questions, ok := contentData["questions"].([]interface{}); ok </span><span class="cov0" title="0">{
                                                questionsJSON, _ := json.Marshal(questions)
                                                json.Unmarshal(questionsJSON, &amp;course.QuizQuestions)
                                        }</span>
                                case "article":<span class="cov0" title="0">
                                        if sections, ok := contentData["sections"].([]interface{}); ok </span><span class="cov0" title="0">{
                                                if headlineImage, ok := contentData["headline_image"].(string); ok </span><span class="cov0" title="0">{
                                                        course.ArticleContent = &amp;ArticleContent{
                                                                HeadlineImage: headlineImage,
                                                        }
                                                        sectionsJSON, _ := json.Marshal(sections)
                                                        json.Unmarshal(sectionsJSON, &amp;course.ArticleContent.Sections)
                                                }</span>
                                        }
                                case "course":<span class="cov0" title="0">
                                        if topics, ok := contentData["topics"].([]interface{}); ok </span><span class="cov0" title="0">{
                                                if outline, ok := contentData["outline"].(string); ok </span><span class="cov0" title="0">{
                                                        course.CourseStructure = &amp;CourseStructure{
                                                                Outline: outline,
                                                        }
                                                        topicsJSON, _ := json.Marshal(topics)
                                                        json.Unmarshal(topicsJSON, &amp;course.CourseStructure.Topics)
                                                }</span>
                                        }
                                }
                        }
                }
                // For video type, if content is just a URL, set it as video_url
                <span class="cov0" title="0">if course.Type == "video" &amp;&amp; course.VideoURL == "" &amp;&amp; isValidURL(course.Content) </span><span class="cov0" title="0">{
                        course.VideoURL = course.Content
                }</span>
        }

        // Get user progress if user is authenticated
        <span class="cov0" title="0">if userID != "" </span><span class="cov0" title="0">{
                course.UserProgress = getUserCourseProgress(db.(*sql.DB), userID, course.ID)

                // Update view count and last accessed time
                go updateCourseViewCount(db.(*sql.DB), courseID, userID)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "course":  course,
        })</span>
}

// StartCourse starts a course for a user
func StartCourse(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        courseID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if course exists
        <span class="cov0" title="0">var courseExists bool
        err := db.(*sql.DB).QueryRow("SELECT EXISTS(SELECT 1 FROM learning_courses WHERE id = ? AND status = 'published')", courseID).Scan(&amp;courseExists)
        if err != nil || !courseExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Course not found",
                })
                return
        }</span>

        // Check if user already has progress for this course
        <span class="cov0" title="0">var existingProgressID string
        err = db.(*sql.DB).QueryRow("SELECT id FROM user_course_progress WHERE user_id = ? AND course_id = ?", userID, courseID).Scan(&amp;existingProgressID)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                // Create new progress record
                progressID := uuid.New().String()
                now := time.Now()

                query := `
                        INSERT INTO user_course_progress
                        (id, user_id, course_id, status, progress_percentage, started_at, last_accessed_at, created_at, updated_at)
                        VALUES (?, ?, ?, 'in_progress', 0, ?, ?, ?, ?)
                `

                _, err = db.(*sql.DB).Exec(query, progressID, userID, courseID, now, now, now, now)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to start course",
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> if err == nil </span><span class="cov0" title="0">{
                // Update existing progress
                now := time.Now()
                query := `
                        UPDATE user_course_progress
                        SET status = 'in_progress', last_accessed_at = ?, updated_at = ?
                        WHERE user_id = ? AND course_id = ?
                `

                _, err = db.(*sql.DB).Exec(query, now, now, userID, courseID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to update course progress",
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to check course progress",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Course started successfully",
        })</span>
}

// Helper function to update course view count
func updateCourseViewCount(db *sql.DB, courseID, userID string) <span class="cov0" title="0">{
        // Update view count
        db.Exec("UPDATE learning_courses SET view_count = view_count + 1 WHERE id = ?", courseID)

        // Update user's last accessed time if they have progress
        now := time.Now()
        db.Exec("UPDATE user_course_progress SET last_accessed_at = ?, updated_at = ? WHERE user_id = ? AND course_id = ?",
                now, now, userID, courseID)
}</span>

// SubmitQuizResults handles quiz result submission and progress tracking
func SubmitQuizResults(c *gin.Context) <span class="cov0" title="0">{
        courseID := c.Param("id")
        userID := c.GetString("userID")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Score           int                      `json:"score"`
                CorrectAnswers  int                      `json:"correct_answers"`
                TotalQuestions  int                      `json:"total_questions"`
                Passed          bool                     `json:"passed"`
                TimeTaken       *int                     `json:"time_taken"`
                DetailedResults []map[string]interface{} `json:"detailed_results"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data",
                })
                return
        }</span>

        <span class="cov0" title="0">now := time.Now()

        // Update or create user course progress
        progressPercentage := 100 // Quiz completion is 100%
        status := "completed"     // Mark as completed if passed
        var completedAt *time.Time
        if req.Passed </span><span class="cov0" title="0">{
                status = "completed"
                completedAt = &amp;now
        }</span> else<span class="cov0" title="0"> {
                status = "in_progress" // Keep as in progress if not passed
                completedAt = nil
        }</span>

        // Check if progress record exists
        <span class="cov0" title="0">var existingID string
        checkQuery := `SELECT id FROM user_course_progress WHERE user_id = ? AND course_id = ?`
        err := db.(*sql.DB).QueryRow(checkQuery, userID, courseID).Scan(&amp;existingID)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                // Create new progress record
                progressID := uuid.New().String()
                progressQuery := `
                        INSERT INTO user_course_progress
                        (id, user_id, course_id, status, progress_percentage, completed_at, last_accessed_at, created_at, updated_at)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                `
                _, err = db.(*sql.DB).Exec(progressQuery,
                        progressID, userID, courseID, status, progressPercentage, completedAt, now, now, now)
        }</span> else<span class="cov0" title="0"> if err == nil </span><span class="cov0" title="0">{
                // Update existing progress record
                progressQuery := `
                        UPDATE user_course_progress
                        SET status = ?, progress_percentage = ?, completed_at = ?, last_accessed_at = ?, updated_at = ?
                        WHERE user_id = ? AND course_id = ?
                `
                _, err = db.(*sql.DB).Exec(progressQuery,
                        status, progressPercentage, completedAt, now, now, userID, courseID)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update course progress: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update progress",
                })
                return
        }</span>

        // Store quiz results (optional - for detailed analytics)
        <span class="cov0" title="0">detailedResultsJSON, _ := json.Marshal(req.DetailedResults)

        resultsQuery := `
                INSERT INTO quiz_results
                (user_id, course_id, score, correct_answers, total_questions, passed, time_taken, detailed_results, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = db.(*sql.DB).Exec(resultsQuery,
                userID, courseID, req.Score, req.CorrectAnswers, req.TotalQuestions,
                req.Passed, req.TimeTaken, string(detailedResultsJSON), now)
        if err != nil </span><span class="cov0" title="0">{
                // Don't fail the request if quiz results storage fails
                log.Printf("Failed to store quiz results: %v", err)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Quiz results submitted successfully",
                "data": gin.H{
                        "progress_updated": true,
                        "completed":        req.Passed,
                        "score":            req.Score,
                        "status":           status,
                },
        })</span>
}

// isValidURL checks if a string is a valid URL
func isValidURL(str string) bool <span class="cov0" title="0">{
        if str == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return strings.HasPrefix(str, "http://") || strings.HasPrefix(str, "https://")</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package api

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// UploadLearningImage handles image uploads for learning content
func UploadLearningImage(c *gin.Context) <span class="cov0" title="0">{
        // Debug logging
        fmt.Printf("🔍 Upload request received - Method: %s, Content-Type: %s\n",
                c.Request.Method, c.Request.Header.Get("Content-Type"))
        fmt.Printf("🔍 Form data keys: %v\n", c.Request.Form)

        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "Authentication required",
                })
                return
        }</span>

        // Get file from form
        <span class="cov0" title="0">file, header, err := c.Request.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Error getting form file: %v\n", err)
                fmt.Printf("❌ Available form fields: %v\n", c.Request.Form)
                if c.Request.MultipartForm != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Available file fields: %v\n", c.Request.MultipartForm.File)
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "No image file provided: " + err.Error(),
                })
                return</span>
        }
        <span class="cov0" title="0">defer file.Close()

        fmt.Printf("✅ File received - Name: %s, Size: %d, Type: %s\n",
                header.Filename, header.Size, header.Header.Get("Content-Type"))

        // Validate file type
        allowedTypes := map[string]bool{
                "image/jpeg": true,
                "image/jpg":  true,
                "image/png":  true,
                "image/webp": true,
                "image/gif":  true,
        }

        contentType := header.Header.Get("Content-Type")
        if !allowedTypes[contentType] </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid file type. Only JPEG, PNG, WebP, and GIF images are allowed",
                })
                return
        }</span>

        // Validate file size (10MB max for learning content)
        <span class="cov0" title="0">if header.Size &gt; 10*1024*1024 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Image too large. Maximum size is 10MB",
                })
                return
        }</span>

        // Create uploads directory
        <span class="cov0" title="0">uploadDir := "./uploads/learning/images"
        if err := os.MkdirAll(uploadDir, 0755); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create upload directory",
                })
                return
        }</span>

        // Generate unique filename
        <span class="cov0" title="0">ext := filepath.Ext(header.Filename)
        if ext == "" </span><span class="cov0" title="0">{
                // Determine extension from content type
                switch contentType </span>{
                case "image/jpeg", "image/jpg":<span class="cov0" title="0">
                        ext = ".jpg"</span>
                case "image/png":<span class="cov0" title="0">
                        ext = ".png"</span>
                case "image/webp":<span class="cov0" title="0">
                        ext = ".webp"</span>
                case "image/gif":<span class="cov0" title="0">
                        ext = ".gif"</span>
                }
        }

        <span class="cov0" title="0">filename := fmt.Sprintf("learning_img_%s_%d%s", uuid.New().String(), time.Now().Unix(), ext)
        filePath := filepath.Join(uploadDir, filename)

        // Save file
        dst, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create file: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer dst.Close()

        if _, err := io.Copy(dst, file); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to save image: " + err.Error(),
                })
                return
        }</span>

        // Create file URL
        <span class="cov0" title="0">fileURL := fmt.Sprintf("/uploads/learning/images/%s", filename)

        c.JSON(http.StatusOK, gin.H{
                "success":   true,
                "message":   "Image uploaded successfully",
                "image_url": fileURL,
                "filename":  filename,
                "size":      header.Size,
        })</span>
}

// UploadLearningVideo handles video uploads for learning content
func UploadLearningVideo(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "Authentication required",
                })
                return
        }</span>

        // Get file from form
        <span class="cov0" title="0">file, header, err := c.Request.FormFile("video")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "No video file provided: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Validate file type
        allowedTypes := map[string]bool{
                "video/mp4":       true,
                "video/mpeg":      true,
                "video/quicktime": true,
                "video/x-msvideo": true, // .avi
                "video/webm":      true,
        }

        contentType := header.Header.Get("Content-Type")
        if !allowedTypes[contentType] </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid file type. Only MP4, MPEG, QuickTime, AVI, and WebM videos are allowed",
                })
                return
        }</span>

        // Validate file size (100MB max for videos)
        <span class="cov0" title="0">if header.Size &gt; 100*1024*1024 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Video too large. Maximum size is 100MB",
                })
                return
        }</span>

        // Create uploads directory
        <span class="cov0" title="0">uploadDir := "./uploads/learning/videos"
        if err := os.MkdirAll(uploadDir, 0755); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create upload directory",
                })
                return
        }</span>

        // Generate unique filename
        <span class="cov0" title="0">ext := filepath.Ext(header.Filename)
        if ext == "" </span><span class="cov0" title="0">{
                // Determine extension from content type
                switch contentType </span>{
                case "video/mp4":<span class="cov0" title="0">
                        ext = ".mp4"</span>
                case "video/mpeg":<span class="cov0" title="0">
                        ext = ".mpeg"</span>
                case "video/quicktime":<span class="cov0" title="0">
                        ext = ".mov"</span>
                case "video/x-msvideo":<span class="cov0" title="0">
                        ext = ".avi"</span>
                case "video/webm":<span class="cov0" title="0">
                        ext = ".webm"</span>
                }
        }

        <span class="cov0" title="0">filename := fmt.Sprintf("learning_vid_%s_%d%s", uuid.New().String(), time.Now().Unix(), ext)
        filePath := filepath.Join(uploadDir, filename)

        // Save file
        dst, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create file: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer dst.Close()

        if _, err := io.Copy(dst, file); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to save video: " + err.Error(),
                })
                return
        }</span>

        // Create file URL
        <span class="cov0" title="0">fileURL := fmt.Sprintf("/uploads/learning/videos/%s", filename)

        c.JSON(http.StatusOK, gin.H{
                "success":   true,
                "message":   "Video uploaded successfully",
                "video_url": fileURL,
                "filename":  filename,
                "size":      header.Size,
        })</span>
}

// UploadLearningDocument handles document uploads for learning content
func UploadLearningDocument(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "Authentication required",
                })
                return
        }</span>

        // Get file from form
        <span class="cov0" title="0">file, header, err := c.Request.FormFile("document")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "No document file provided: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Validate file type
        allowedTypes := map[string]bool{
                "application/pdf":    true,
                "application/msword": true,
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
                "application/vnd.ms-excel": true,
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":         true,
                "application/vnd.ms-powerpoint":                                             true,
                "application/vnd.openxmlformats-officedocument.presentationml.presentation": true,
                "text/plain": true,
        }

        contentType := header.Header.Get("Content-Type")
        if !allowedTypes[contentType] </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid file type. Only PDF, Word, Excel, PowerPoint, and text documents are allowed",
                })
                return
        }</span>

        // Validate file size (20MB max for documents)
        <span class="cov0" title="0">if header.Size &gt; 20*1024*1024 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Document too large. Maximum size is 20MB",
                })
                return
        }</span>

        // Create uploads directory
        <span class="cov0" title="0">uploadDir := "./uploads/learning/documents"
        if err := os.MkdirAll(uploadDir, 0755); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create upload directory",
                })
                return
        }</span>

        // Generate unique filename preserving original extension
        <span class="cov0" title="0">ext := filepath.Ext(header.Filename)
        baseName := strings.TrimSuffix(header.Filename, ext)
        filename := fmt.Sprintf("learning_doc_%s_%s_%d%s", uuid.New().String(), baseName, time.Now().Unix(), ext)
        filePath := filepath.Join(uploadDir, filename)

        // Save file
        dst, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create file: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer dst.Close()

        if _, err := io.Copy(dst, file); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to save document: " + err.Error(),
                })
                return
        }</span>

        // Create file URL
        <span class="cov0" title="0">fileURL := fmt.Sprintf("/uploads/learning/documents/%s", filename)

        c.JSON(http.StatusOK, gin.H{
                "success":       true,
                "message":       "Document uploaded successfully",
                "document_url":  fileURL,
                "filename":      filename,
                "original_name": header.Filename,
                "size":          header.Size,
                "type":          contentType,
        })</span>
}

// ValidateVideoURL validates and processes video URLs
func ValidateVideoURL(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "Authentication required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                VideoURL string `json:"video_url" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">videoURL := strings.TrimSpace(req.VideoURL)
        if videoURL == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Video URL is required",
                })
                return
        }</span>

        // Validate and process different video URL types
        <span class="cov0" title="0">videoInfo := processVideoURL(videoURL)

        c.JSON(http.StatusOK, gin.H{
                "success":    true,
                "message":    "Video URL validated successfully",
                "video_info": videoInfo,
        })</span>
}

// processVideoURL processes different types of video URLs
func processVideoURL(videoURL string) map[string]interface{} <span class="cov0" title="0">{
        result := map[string]interface{}{
                "original_url": videoURL,
                "type":         "unknown",
                "playable":     false,
                "embed_url":    "",
                "thumbnail":    "",
        }

        // YouTube URL processing
        if strings.Contains(videoURL, "youtube.com") || strings.Contains(videoURL, "youtu.be") </span><span class="cov0" title="0">{
                videoID := extractYouTubeVideoID(videoURL)
                if videoID != "" </span><span class="cov0" title="0">{
                        result["type"] = "youtube"
                        result["video_id"] = videoID
                        result["embed_url"] = fmt.Sprintf("https://www.youtube.com/embed/%s", videoID)
                        result["thumbnail"] = fmt.Sprintf("https://img.youtube.com/vi/%s/maxresdefault.jpg", videoID)
                        result["playable"] = true
                }</span>
                <span class="cov0" title="0">return result</span>
        }

        // Vimeo URL processing
        <span class="cov0" title="0">if strings.Contains(videoURL, "vimeo.com") </span><span class="cov0" title="0">{
                vimeoID := extractVimeoVideoID(videoURL)
                if vimeoID != "" </span><span class="cov0" title="0">{
                        result["type"] = "vimeo"
                        result["video_id"] = vimeoID
                        result["embed_url"] = fmt.Sprintf("https://player.vimeo.com/video/%s", vimeoID)
                        result["playable"] = true
                }</span>
                <span class="cov0" title="0">return result</span>
        }

        // Direct video file URLs
        <span class="cov0" title="0">if isDirectVideoURL(videoURL) </span><span class="cov0" title="0">{
                result["type"] = "direct"
                result["embed_url"] = videoURL
                result["playable"] = true
                return result
        }</span>

        // Streaming URLs (HLS, DASH)
        <span class="cov0" title="0">if isStreamingURL(videoURL) </span><span class="cov0" title="0">{
                result["type"] = "streaming"
                result["embed_url"] = videoURL
                result["playable"] = true
                return result
        }</span>

        // Default: try to play as direct URL
        <span class="cov0" title="0">result["type"] = "generic"
        result["embed_url"] = videoURL
        result["playable"] = true

        return result</span>
}

// extractYouTubeVideoID extracts video ID from YouTube URLs
func extractYouTubeVideoID(url string) string <span class="cov0" title="0">{
        patterns := []string{
                `(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})`,
        }

        for _, pattern := range patterns </span><span class="cov0" title="0">{
                re := regexp.MustCompile(pattern)
                matches := re.FindStringSubmatch(url)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        return matches[1]
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// extractVimeoVideoID extracts video ID from Vimeo URLs
func extractVimeoVideoID(url string) string <span class="cov0" title="0">{
        re := regexp.MustCompile(`vimeo\.com\/(\d+)`)
        matches := re.FindStringSubmatch(url)
        if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                return matches[1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// isDirectVideoURL checks if URL is a direct video file
func isDirectVideoURL(url string) bool <span class="cov0" title="0">{
        videoExtensions := []string{".mp4", ".webm", ".ogg", ".avi", ".mov", ".wmv", ".flv", ".mkv"}
        lowerURL := strings.ToLower(url)
        for _, ext := range videoExtensions </span><span class="cov0" title="0">{
                if strings.Contains(lowerURL, ext) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isStreamingURL checks if URL is a streaming video
func isStreamingURL(url string) bool <span class="cov0" title="0">{
        streamingExtensions := []string{".m3u8", ".mpd"}
        lowerURL := strings.ToLower(url)
        for _, ext := range streamingExtensions </span><span class="cov0" title="0">{
                if strings.Contains(lowerURL, ext) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

// Loan application handlers
func GetLoanApplications(c *gin.Context) <span class="cov0" title="0">{
        chamaID := c.Query("chamaId")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "chamaId parameter is required",
                })
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("🔍 GetLoanApplications called for chamaId: %s\n", chamaID)

        // Get database connection
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // First, let's check if the loans table exists and has data
        <span class="cov0" title="0">var tableExists bool
        err := db.(*sql.DB).QueryRow("SELECT name FROM sqlite_master WHERE type='table' AND name='loans'").Scan(&amp;tableExists)
        if err != nil </span>{<span class="cov0" title="0">
                // fmt.Printf("❌ Loans table check failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✅ Loans table exists\n")
        }</span>

        // Check total count of loans in the table
        <span class="cov0" title="0">var totalLoans int
        err = db.(*sql.DB).QueryRow("SELECT COUNT(*) FROM loans").Scan(&amp;totalLoans)
        if err != nil </span>{<span class="cov0" title="0">
                // fmt.Printf("❌ Failed to count loans: %v\n", err)
        }</span> else <span class="cov0" title="0">{
                // fmt.Printf("🔍 Total loans in database: %d\n", totalLoans)
        }</span>

        // Check loans for this specific chama
        <span class="cov0" title="0">var chamaLoans int
        err = db.(*sql.DB).QueryRow("SELECT COUNT(*) FROM loans WHERE chama_id = ?", chamaID).Scan(&amp;chamaLoans)
        if err != nil </span>{<span class="cov0" title="0">
                // fmt.Printf("❌ Failed to count loans for chama: %v\n", err)
        }</span> else <span class="cov0" title="0">{
                // fmt.Printf("🔍 Loans for chamaId %s: %d\n", chamaID, chamaLoans)
        }</span>

        // Debug: Show all unique chama_ids in loans table
        <span class="cov0" title="0">chamaRows, err := db.(*sql.DB).Query("SELECT DISTINCT chama_id, COUNT(*) FROM loans GROUP BY chama_id")
        if err == nil </span><span class="cov0" title="0">{
                // fmt.Printf("🔍 All chamaIds with loans:\n")
                for chamaRows.Next() </span><span class="cov0" title="0">{
                        var cid string
                        var count int
                        if chamaRows.Scan(&amp;cid, &amp;count) == nil </span><span class="cov0" title="0">{
                                fmt.Printf("   - %s: %d loans\n", cid, count)
                        }</span>
                }
                <span class="cov0" title="0">chamaRows.Close()</span>
        }

        // Query loan applications
        <span class="cov0" title="0">rows, err := db.(*sql.DB).Query(`
                SELECT
                        l.id, l.borrower_id, l.chama_id, l.amount, l.interest_rate,
                        l.duration, l.purpose, l.status, l.total_amount, l.remaining_amount,
                        l.required_guarantors, l.approved_guarantors, l.due_date, l.created_at,
                        u.first_name, u.last_name, u.email
                FROM loans l
                JOIN users u ON l.borrower_id = u.id
                WHERE l.chama_id = ?
                ORDER BY l.created_at DESC
        `, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch loan applications: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var loans []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var loan struct {
                        ID                 string    `json:"id"`
                        BorrowerID         string    `json:"borrowerId"`
                        ChamaID            string    `json:"chamaId"`
                        Amount             float64   `json:"amount"`
                        InterestRate       float64   `json:"interestRate"`
                        Duration           int       `json:"duration"`
                        Purpose            string    `json:"purpose"`
                        Status             string    `json:"status"`
                        TotalAmount        float64   `json:"totalAmount"`
                        RemainingAmount    float64   `json:"remainingAmount"`
                        RequiredGuarantors int       `json:"requiredGuarantors"`
                        ApprovedGuarantors int       `json:"approvedGuarantors"`
                        DueDate            time.Time `json:"dueDate"`
                        CreatedAt          time.Time `json:"createdAt"`
                        BorrowerFirstName  string    `json:"borrowerFirstName"`
                        BorrowerLastName   string    `json:"borrowerLastName"`
                        BorrowerEmail      string    `json:"borrowerEmail"`
                }

                err := rows.Scan(
                        &amp;loan.ID, &amp;loan.BorrowerID, &amp;loan.ChamaID, &amp;loan.Amount, &amp;loan.InterestRate,
                        &amp;loan.Duration, &amp;loan.Purpose, &amp;loan.Status, &amp;loan.TotalAmount, &amp;loan.RemainingAmount,
                        &amp;loan.RequiredGuarantors, &amp;loan.ApprovedGuarantors, &amp;loan.DueDate, &amp;loan.CreatedAt,
                        &amp;loan.BorrowerFirstName, &amp;loan.BorrowerLastName, &amp;loan.BorrowerEmail,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid rows
                }

                <span class="cov0" title="0">loanMap := map[string]interface{}{
                        "id":                 loan.ID,
                        "borrowerId":         loan.BorrowerID,
                        "chamaId":            loan.ChamaID,
                        "amount":             loan.Amount,
                        "interestRate":       loan.InterestRate,
                        "duration":           loan.Duration,
                        "purpose":            loan.Purpose,
                        "status":             loan.Status,
                        "totalAmount":        loan.TotalAmount,
                        "remainingAmount":    loan.RemainingAmount,
                        "requiredGuarantors": loan.RequiredGuarantors,
                        "approvedGuarantors": loan.ApprovedGuarantors,
                        "dueDate":            loan.DueDate.Format(time.RFC3339),
                        "createdAt":          loan.CreatedAt.Format(time.RFC3339),
                        "borrower": map[string]interface{}{
                                "id":        loan.BorrowerID,
                                "firstName": loan.BorrowerFirstName,
                                "lastName":  loan.BorrowerLastName,
                                "email":     loan.BorrowerEmail,
                                "fullName":  loan.BorrowerFirstName + " " + loan.BorrowerLastName,
                        },
                }

                loans = append(loans, loanMap)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    loans,
                "message": fmt.Sprintf("Found %d loan applications", len(loans)),
                "meta": map[string]interface{}{
                        "total":   len(loans),
                        "chamaId": chamaID,
                },
        })</span>
}

func CreateLoanApplication(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ChamaID         string                 `json:"chamaId" binding:"required"`
                Amount          float64                `json:"amount" binding:"required"`
                Purpose         string                 `json:"purpose" binding:"required"`
                RepaymentPeriod int                    `json:"repaymentPeriod" binding:"required"`
                InterestRate    float64                `json:"interestRate" binding:"required"`
                Guarantors      []string               `json:"guarantors" binding:"required"`
                Security        map[string]interface{} `json:"security"`
                BusinessPlan    string                 `json:"businessPlan"`
                MonthlyIncome   float64                `json:"monthlyIncome" binding:"required"`
                OtherLoans      string                 `json:"otherLoans"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Validate amount
        <span class="cov0" title="0">if req.Amount &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Amount must be greater than 0",
                })
                return
        }</span>

        // Validate guarantors
        <span class="cov0" title="0">if len(req.Guarantors) &lt; 2 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "At least 2 guarantors are required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := db.(*sql.DB).Begin()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to start transaction",
                })
                return
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Generate loan ID
        loanID := fmt.Sprintf("loan-%d", time.Now().UnixNano())

        // Calculate total amount with interest
        totalAmount := req.Amount * (1 + req.InterestRate/100)

        // Calculate due date (repayment period in months)
        dueDate := time.Now().AddDate(0, req.RepaymentPeriod, 0)

        // Insert loan application
        _, err = tx.Exec(`
                INSERT INTO loans (
                        id, borrower_id, chama_id, type, amount, interest_rate,
                        duration, purpose, status, total_amount, remaining_amount,
                        required_guarantors, approved_guarantors, due_date,
                        created_at, updated_at
                ) VALUES (?, ?, ?, 'regular', ?, ?, ?, ?, 'pending', ?, ?, ?, 0, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `, loanID, userID, req.ChamaID, req.Amount, req.InterestRate, req.RepaymentPeriod, req.Purpose, totalAmount, totalAmount, len(req.Guarantors), dueDate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create loan application: " + err.Error(),
                })
                return
        }</span>

        // Insert guarantors and send notifications
        <span class="cov0" title="0">for _, guarantorID := range req.Guarantors </span><span class="cov0" title="0">{
                guarantorAmount := req.Amount / float64(len(req.Guarantors)) // Split equally
                guarantorRecordID := fmt.Sprintf("guarantor-%d-%s", time.Now().UnixNano(), guarantorID)

                _, err = tx.Exec(`
                        INSERT INTO guarantors (
                                id, loan_id, user_id, amount, status, created_at
                        ) VALUES (?, ?, ?, ?, 'pending', CURRENT_TIMESTAMP)
                `, guarantorRecordID, loanID, guarantorID, guarantorAmount)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to add guarantor: " + err.Error(),
                        })
                        return
                }</span>

                // Create notification for guarantor
                <span class="cov0" title="0">notificationID := fmt.Sprintf("notif-%d", time.Now().UnixNano())
                _, err = tx.Exec(`
                        INSERT INTO notifications (
                                id, user_id, type, title, message, data, is_read, created_at
                        ) VALUES (?, ?, 'guarantor_request', ?, ?, ?, false, CURRENT_TIMESTAMP)
                `, notificationID, guarantorID,
                        "Guarantor Request",
                        fmt.Sprintf("You have been requested to guarantee a loan of KES %.2f", req.Amount),
                        fmt.Sprintf(`{"loan_id": "%s", "amount": %.2f, "purpose": "%s", "requester_id": "%s", "guarantor_id": "%s"}`,
                                loanID, req.Amount, req.Purpose, userID.(string), guarantorRecordID))
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the transaction
                        fmt.Printf("Failed to create notification for guarantor %s: %v\n", guarantorID, err)
                }</span>
        }

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to commit transaction",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Loan application submitted successfully. Guarantors will be notified.",
                "data": map[string]interface{}{
                        "id":                 loanID,
                        "chamaId":            req.ChamaID,
                        "borrowerId":         userID,
                        "amount":             req.Amount,
                        "purpose":            req.Purpose,
                        "repaymentPeriod":    req.RepaymentPeriod,
                        "interestRate":       req.InterestRate,
                        "guarantors":         req.Guarantors,
                        "totalAmount":        totalAmount,
                        "remainingAmount":    totalAmount,
                        "status":             "pending",
                        "requiredGuarantors": len(req.Guarantors),
                        "approvedGuarantors": 0,
                        "dueDate":            dueDate.Format(time.RFC3339),
                        "createdAt":          time.Now().Format(time.RFC3339),
                },
        })</span>
}

func GetLoanApplication(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Get loan application endpoint - coming soon",
        })
}</span>

func UpdateLoanApplication(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Update loan application endpoint - coming soon",
        })
}</span>

func DeleteLoanApplication(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delete loan application endpoint - coming soon",
        })
}</span>

func RespondToGuarantorRequest(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">guarantorID := c.Param("guarantorId")
        if guarantorID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Guarantor ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Action string `json:"action" binding:"required"` // "accept" or "decline"
                Reason string `json:"reason"`                    // Optional reason for decline
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Validate action
        <span class="cov0" title="0">if req.Action != "accept" &amp;&amp; req.Action != "decline" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Action must be 'accept' or 'decline'",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Verify the guarantor record belongs to the current user
        <span class="cov0" title="0">var loanID, requesterID string
        var currentStatus string
        err := db.(*sql.DB).QueryRow(`
                SELECT loan_id,
                        (SELECT user_id FROM loans WHERE id = guarantors.loan_id) as requester_id,
                        status
                FROM guarantors
                WHERE id = ? AND user_id = ?
        `, guarantorID, userID).Scan(&amp;loanID, &amp;requesterID, &amp;currentStatus)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Guarantor request not found or not authorized",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch guarantor request: " + err.Error(),
                })
                return</span>
        }

        // Check if already responded
        <span class="cov0" title="0">if currentStatus != "pending" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "You have already responded to this guarantor request",
                })
                return
        }</span>

        // Update guarantor status
        <span class="cov0" title="0">newStatus := "declined"
        if req.Action == "accept" </span><span class="cov0" title="0">{
                newStatus = "accepted"
        }</span>

        <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(`
                UPDATE guarantors
                SET status = ?, message = ?, responded_at = CURRENT_TIMESTAMP
                WHERE id = ?
        `, newStatus, req.Reason, guarantorID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update guarantor response: " + err.Error(),
                })
                return
        }</span>

        // Create notification for loan requester
        <span class="cov0" title="0">notificationID := fmt.Sprintf("notif-%d", time.Now().UnixNano())
        message := fmt.Sprintf("Your guarantor request has been %s", newStatus)
        if req.Reason != "" </span><span class="cov0" title="0">{
                message += fmt.Sprintf(". Reason: %s", req.Reason)
        }</span>

        <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(`
                INSERT INTO notifications (
                        id, user_id, type, title, message, data, is_read, created_at
                ) VALUES (?, ?, 'guarantor_response', ?, ?, ?, false, CURRENT_TIMESTAMP)
        `, notificationID, requesterID,
                "Guarantor Response",
                message,
                fmt.Sprintf(`{"loan_id": "%s", "guarantor_id": "%s", "action": "%s"}`,
                        loanID, guarantorID, req.Action))
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the response
                fmt.Printf("Failed to create notification for loan requester %s: %v\n", requesterID, err)
        }</span>

        // Check if all guarantors have responded and update loan status if needed
        <span class="cov0" title="0">go checkAndUpdateLoanStatus(db.(*sql.DB), loanID)

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": fmt.Sprintf("Guarantor request %s successfully", newStatus),
                "data": map[string]interface{}{
                        "guarantor_id": guarantorID,
                        "status":       newStatus,
                        "action":       req.Action,
                },
        })</span>
}

// checkAndUpdateLoanStatus checks if all guarantors have responded and updates loan status
func checkAndUpdateLoanStatus(db *sql.DB, loanID string) <span class="cov0" title="0">{
        // Get guarantor response counts
        var totalGuarantors, acceptedGuarantors, declinedGuarantors int
        err := db.QueryRow(`
                SELECT
                        COUNT(*) as total,
                        SUM(CASE WHEN status = 'accepted' THEN 1 ELSE 0 END) as accepted,
                        SUM(CASE WHEN status = 'declined' THEN 1 ELSE 0 END) as declined
                FROM guarantors
                WHERE loan_id = ?
        `, loanID).Scan(&amp;totalGuarantors, &amp;acceptedGuarantors, &amp;declinedGuarantors)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error checking guarantor status for loan %s: %v\n", loanID, err)
                return
        }</span>

        // Check if all guarantors have responded
        <span class="cov0" title="0">respondedGuarantors := acceptedGuarantors + declinedGuarantors
        if respondedGuarantors &lt; totalGuarantors </span><span class="cov0" title="0">{
                // Not all guarantors have responded yet
                return
        }</span>

        // Determine new loan status
        <span class="cov0" title="0">var newStatus string
        if acceptedGuarantors == totalGuarantors </span><span class="cov0" title="0">{
                // All guarantors accepted - move to pending approval
                newStatus = "guarantors_approved"
        }</span> else<span class="cov0" title="0"> if declinedGuarantors &gt; 0 </span><span class="cov0" title="0">{
                // At least one guarantor declined - reject loan
                newStatus = "guarantors_declined"
        }</span>

        // Update loan status
        <span class="cov0" title="0">_, err = db.Exec(`
                UPDATE loans
                SET status = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
        `, newStatus, loanID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error updating loan status for loan %s: %v\n", loanID, err)
                return
        }</span>

        // Get loan requester for notification
        <span class="cov0" title="0">var requesterID string
        err = db.QueryRow(`SELECT user_id FROM loans WHERE id = ?`, loanID).Scan(&amp;requesterID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error getting loan requester for loan %s: %v\n", loanID, err)
                return
        }</span>

        // Create notification for loan requester
        <span class="cov0" title="0">notificationID := fmt.Sprintf("notif-%d", time.Now().UnixNano())
        var message string
        if newStatus == "guarantors_approved" </span><span class="cov0" title="0">{
                message = "All guarantors have accepted your loan request. Your application is now pending approval from chama officials."
        }</span> else<span class="cov0" title="0"> {
                message = "Some guarantors have declined your loan request. Your application has been rejected."
        }</span>

        <span class="cov0" title="0">_, err = db.Exec(`
                INSERT INTO notifications (
                        id, user_id, type, title, message, data, is_read, created_at
                ) VALUES (?, ?, 'loan_status_update', ?, ?, ?, false, CURRENT_TIMESTAMP)
        `, notificationID, requesterID,
                "Loan Status Update",
                message,
                fmt.Sprintf(`{"loan_id": "%s", "status": "%s"}`, loanID, newStatus))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create loan status notification for user %s: %v\n", requesterID, err)
        }</span>
}

func ApproveLoan(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Loan approved successfully",
        })
}</span>

func RejectLoan(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Reason string `json:"reason" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Loan rejected successfully",
                "data": map[string]interface{}{
                        "reason": req.Reason,
                },
        })</span>
}

func DisburseLoan(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Loan disbursed successfully",
        })
}</span>

func GetGuarantorRequests(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Query guarantor requests for the user
        <span class="cov0" title="0">rows, err := db.(*sql.DB).Query(`
                SELECT
                        g.id, g.loan_id, g.amount, g.status, g.created_at,
                        l.amount as loan_amount, l.purpose, l.repayment_period, l.interest_rate,
                        u.first_name, u.last_name, u.email,
                        c.name as chama_name
                FROM guarantors g
                JOIN loans l ON g.loan_id = l.id
                JOIN users u ON l.user_id = u.id
                JOIN chamas c ON l.chama_id = c.id
                WHERE g.user_id = ?
                ORDER BY g.created_at DESC
        `, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch guarantor requests: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var guarantorRequests []map[string]interface{}

        for rows.Next() </span><span class="cov0" title="0">{
                var gr struct {
                        ID                 string    `json:"id"`
                        LoanID             string    `json:"loanId"`
                        Amount             float64   `json:"amount"`
                        Status             string    `json:"status"`
                        CreatedAt          time.Time `json:"createdAt"`
                        LoanAmount         float64   `json:"loanAmount"`
                        Purpose            string    `json:"purpose"`
                        RepaymentPeriod    int       `json:"repaymentPeriod"`
                        InterestRate       float64   `json:"interestRate"`
                        RequesterFirstName string    `json:"requesterFirstName"`
                        RequesterLastName  string    `json:"requesterLastName"`
                        RequesterEmail     string    `json:"requesterEmail"`
                        ChamaName          string    `json:"chamaName"`
                }

                err := rows.Scan(
                        &amp;gr.ID, &amp;gr.LoanID, &amp;gr.Amount, &amp;gr.Status, &amp;gr.CreatedAt,
                        &amp;gr.LoanAmount, &amp;gr.Purpose, &amp;gr.RepaymentPeriod, &amp;gr.InterestRate,
                        &amp;gr.RequesterFirstName, &amp;gr.RequesterLastName, &amp;gr.RequesterEmail,
                        &amp;gr.ChamaName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to scan guarantor request: " + err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">guarantorRequest := map[string]interface{}{
                        "id":              gr.ID,
                        "loanId":          gr.LoanID,
                        "amount":          gr.Amount,
                        "status":          gr.Status,
                        "createdAt":       gr.CreatedAt.Format(time.RFC3339),
                        "loanAmount":      gr.LoanAmount,
                        "purpose":         gr.Purpose,
                        "repaymentPeriod": gr.RepaymentPeriod,
                        "interestRate":    gr.InterestRate,
                        "chamaName":       gr.ChamaName,
                        "requester": map[string]interface{}{
                                "firstName": gr.RequesterFirstName,
                                "lastName":  gr.RequesterLastName,
                                "email":     gr.RequesterEmail,
                                "fullName":  gr.RequesterFirstName + " " + gr.RequesterLastName,
                        },
                }

                guarantorRequests = append(guarantorRequests, guarantorRequest)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    guarantorRequests,
                "count":   len(guarantorRequests),
        })</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "strconv"
        "strings"
        "vaultke-backend/internal/models"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// Marketplace handlers
func GetProducts(c *gin.Context) <span class="cov0" title="0">{
        // Get query parameters
        limitStr := c.DefaultQuery("limit", "20")
        offsetStr := c.DefaultQuery("offset", "0")
        category := c.Query("category")
        county := c.Query("county")
        chamaID := c.Query("chamaId")
        search := c.Query("search")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Build filters
        filters := make(map[string]interface{})
        if category != "" </span><span class="cov0" title="0">{
                filters["category"] = category
        }</span>
        <span class="cov0" title="0">if county != "" </span><span class="cov0" title="0">{
                filters["county"] = county
        }</span>
        <span class="cov0" title="0">if chamaID != "" </span><span class="cov0" title="0">{
                filters["chamaId"] = chamaID
        }</span>
        <span class="cov0" title="0">if search != "" </span><span class="cov0" title="0">{
                filters["search"] = search
        }</span>

        // Get products
        <span class="cov0" title="0">products, err := marketplaceService.GetProducts(filters, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get products: " + err.Error(),
                })
                return
        }</span>

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    products,
                "count":   len(products),
        })</span>
}

func GetAllProducts(c *gin.Context) <span class="cov0" title="0">{
        // Get query parameters
        limitStr := c.DefaultQuery("limit", "20")
        offsetStr := c.DefaultQuery("offset", "0")
        category := c.Query("category")
        county := c.Query("county")
        chamaID := c.Query("chamaId")
        sellerID := c.Query("sellerId")
        search := c.Query("search")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Build filters
        filters := make(map[string]interface{})
        if category != "" </span><span class="cov0" title="0">{
                filters["category"] = category
        }</span>
        <span class="cov0" title="0">if county != "" </span><span class="cov0" title="0">{
                filters["county"] = county
        }</span>
        <span class="cov0" title="0">if chamaID != "" </span><span class="cov0" title="0">{
                filters["chamaId"] = chamaID
        }</span>
        <span class="cov0" title="0">if sellerID != "" </span><span class="cov0" title="0">{
                filters["sellerId"] = sellerID
        }</span>
        <span class="cov0" title="0">if search != "" </span><span class="cov0" title="0">{
                filters["search"] = search
        }</span>

        // Get all products (including out of stock)
        <span class="cov0" title="0">products, err := marketplaceService.GetAllProducts(filters, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get products: " + err.Error(),
                })
                return
        }</span>

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    products,
                "count":   len(products),
        })</span>
}

func CreateProduct(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var req models.ProductCreation
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Get chama ID from query parameter (optional)
        chamaID := c.Query("chamaId")
        var chamaIDPtr *string
        if chamaID != "" </span><span class="cov0" title="0">{
                chamaIDPtr = &amp;chamaID
        }</span>

        // Create the product
        <span class="cov0" title="0">product, err := marketplaceService.CreateProduct(&amp;req, userID.(string), chamaIDPtr)
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a validation error
                if strings.Contains(err.Error(), "validation error") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "Failed to create product: " + err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to create product: " + err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Product created successfully",
                "data":    product,
        })</span>
}

func GetProduct(c *gin.Context) <span class="cov0" title="0">{
        productID := c.Param("id")
        if productID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Product ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Get product by ID
        product, err := marketplaceService.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Product not found",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to get product: " + err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    product,
        })</span>
}

func UpdateProduct(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Update product endpoint - coming soon",
        })
}</span>

func DeleteProduct(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delete product endpoint - coming soon",
        })
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

var (
        meetingService   *services.MeetingService
        schedulerService *services.SchedulerService
)

// Meeting handlers
func GetMeetings(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">chamaID := c.Query("chamaId")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "chamaId parameter is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if user is a member of the chama
        <span class="cov0" title="0">var membershipExists bool
        err := db.(*sql.DB).QueryRow(`
                SELECT EXISTS(
                        SELECT 1 FROM chama_members
                        WHERE chama_id = ? AND user_id = ? AND is_active = TRUE
                )
        `, chamaID, userID).Scan(&amp;membershipExists)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify chama membership",
                })
                return
        }</span>

        <span class="cov0" title="0">if !membershipExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Access denied. You are not a member of this chama.",
                })
                return
        }</span>

        // Query meetings for the chama
        <span class="cov0" title="0">rows, err := db.(*sql.DB).Query(`
                SELECT
                        m.id, m.chama_id, m.title, m.description, m.scheduled_at,
                        m.duration, m.location, m.meeting_url, m.meeting_type, m.status, m.created_by, m.created_at,
                        u.first_name, u.last_name, u.email
                FROM meetings m
                JOIN users u ON m.created_by = u.id
                WHERE m.chama_id = ?
                ORDER BY m.scheduled_at DESC
        `, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch meetings: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var meetings []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var meeting struct {
                        ID               string    `json:"id"`
                        ChamaID          string    `json:"chamaId"`
                        Title            string    `json:"title"`
                        Description      string    `json:"description"`
                        ScheduledAt      time.Time `json:"scheduledAt"`
                        Duration         int       `json:"duration"`
                        Location         string    `json:"location"`
                        MeetingURL       string    `json:"meetingUrl"`
                        MeetingType      string    `json:"meetingType"`
                        Status           string    `json:"status"`
                        CreatedBy        string    `json:"createdBy"`
                        CreatedAt        time.Time `json:"createdAt"`
                        CreatorFirstName string    `json:"creatorFirstName"`
                        CreatorLastName  string    `json:"creatorLastName"`
                        CreatorEmail     string    `json:"creatorEmail"`
                }

                err := rows.Scan(
                        &amp;meeting.ID, &amp;meeting.ChamaID, &amp;meeting.Title, &amp;meeting.Description, &amp;meeting.ScheduledAt,
                        &amp;meeting.Duration, &amp;meeting.Location, &amp;meeting.MeetingURL, &amp;meeting.MeetingType, &amp;meeting.Status, &amp;meeting.CreatedBy, &amp;meeting.CreatedAt,
                        &amp;meeting.CreatorFirstName, &amp;meeting.CreatorLastName, &amp;meeting.CreatorEmail,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid rows
                }

                // Determine meeting status based on scheduled time and duration
                <span class="cov0" title="0">now := time.Now()
                status := meeting.Status
                meetingEndTime := meeting.ScheduledAt.Add(time.Duration(meeting.Duration) * time.Minute)

                // Only mark as completed if the meeting has actually ended (not just started)
                if meetingEndTime.Before(now) &amp;&amp; status == "scheduled" </span><span class="cov0" title="0">{
                        status = "completed"
                }</span>

                <span class="cov0" title="0">meetingMap := map[string]interface{}{
                        "id":          meeting.ID,
                        "chamaId":     meeting.ChamaID,
                        "title":       meeting.Title,
                        "description": meeting.Description,
                        "scheduledAt": meeting.ScheduledAt.Format(time.RFC3339),
                        "duration":    meeting.Duration,
                        "location":    meeting.Location,
                        "meetingUrl":  meeting.MeetingURL,
                        "meetingType": meeting.MeetingType,
                        "type":        meeting.MeetingType, // Also include as 'type' for compatibility
                        "status":      status,
                        "createdBy":   meeting.CreatedBy,
                        "createdAt":   meeting.CreatedAt.Format(time.RFC3339),
                        "creator": map[string]interface{}{
                                "id":        meeting.CreatedBy,
                                "firstName": meeting.CreatorFirstName,
                                "lastName":  meeting.CreatorLastName,
                                "email":     meeting.CreatorEmail,
                                "fullName":  meeting.CreatorFirstName + " " + meeting.CreatorLastName,
                        },
                }

                meetings = append(meetings, meetingMap)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    meetings,
                "message": fmt.Sprintf("Found %d meetings", len(meetings)),
                "meta": map[string]interface{}{
                        "total":   len(meetings),
                        "chamaId": chamaID,
                },
        })</span>
}

func CreateMeeting(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ChamaID     string `json:"chamaId" binding:"required"`
                Title       string `json:"title" binding:"required"`
                Description string `json:"description"`
                ScheduledAt string `json:"scheduledAt" binding:"required"`
                Duration    int    `json:"duration"`
                Location    string `json:"location"`
                MeetingURL  string `json:"meetingUrl"`
                Type        string `json:"type"`
                Agenda      string `json:"agenda"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Validate date time format
        <span class="cov0" title="0">meetingTime, err := time.Parse(time.RFC3339, req.ScheduledAt)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid date time format. Use RFC3339 format (e.g., 2024-01-01T15:30:00Z)",
                })
                return
        }</span>

        // Check if meeting is in the future
        <span class="cov0" title="0">if meetingTime.Before(time.Now()) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting date and time must be in the future",
                })
                return
        }</span>

        // Calculate end time based on duration
        <span class="cov0" title="0">duration := req.Duration
        if duration &lt;= 0 </span><span class="cov0" title="0">{
                duration = 60 // Default to 60 minutes
        }</span>
        <span class="cov0" title="0">endTime := meetingTime.Add(time.Duration(duration) * time.Minute)

        // Get database connection
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if user is a member of the chama
        <span class="cov0" title="0">var membershipExists bool
        err = db.(*sql.DB).QueryRow(`
                SELECT EXISTS(
                        SELECT 1 FROM chama_members
                        WHERE chama_id = ? AND user_id = ? AND is_active = TRUE
                )
        `, req.ChamaID, userID).Scan(&amp;membershipExists)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify chama membership",
                })
                return
        }</span>

        <span class="cov0" title="0">if !membershipExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Access denied. You are not a member of this chama.",
                })
                return
        }</span>

        // Generate meeting ID
        <span class="cov0" title="0">meetingID := fmt.Sprintf("meeting-%d", time.Now().UnixNano())

        // Set default values
        meetingType := req.Type
        if meetingType == "" </span><span class="cov0" title="0">{
                meetingType = "regular"
        }</span>

        <span class="cov0" title="0">location := req.Location
        if location == "" </span><span class="cov0" title="0">{
                location = "TBD"
        }</span>

        // Insert meeting into database
        <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(`
                INSERT INTO meetings (
                        id, chama_id, title, description, scheduled_at, duration, location,
                        meeting_url, status, created_by, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'scheduled', ?, CURRENT_TIMESTAMP)
        `, meetingID, req.ChamaID, req.Title, req.Description, meetingTime, duration, location, req.MeetingURL, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create meeting: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Meeting scheduled successfully! All chama members will be notified.",
                "data": map[string]interface{}{
                        "id":          meetingID,
                        "chamaId":     req.ChamaID,
                        "title":       req.Title,
                        "description": req.Description,
                        "scheduledAt": req.ScheduledAt,
                        "endsAt":      endTime.Format(time.RFC3339), // Calculated end time
                        "duration":    duration,
                        "location":    location,
                        "meetingUrl":  req.MeetingURL,
                        "status":      "scheduled",
                        "createdBy":   userID,
                        "createdAt":   time.Now().Format(time.RFC3339),
                },
        })</span>
}

func GetMeeting(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Get meeting endpoint - coming soon",
        })
}</span>

func UpdateMeeting(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Update meeting endpoint - coming soon",
        })
}</span>

func DeleteMeeting(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delete meeting endpoint - coming soon",
        })
}</span>

// the join meeting endpint in backend is a dummy one and cannot do anyhingt

func JoinMeeting(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get meeting details
        <span class="cov0" title="0">var meeting struct {
                ID          string    `json:"id"`
                ChamaID     string    `json:"chamaId"`
                Title       string    `json:"title"`
                Description string    `json:"description"`
                ScheduledAt time.Time `json:"scheduledAt"`
                Duration    int       `json:"duration"`
                Location    string    `json:"location"`
                MeetingURL  string    `json:"meetingUrl"`
                MeetingType string    `json:"meetingType"`
                Status      string    `json:"status"`
                CreatedBy   string    `json:"createdBy"`
        }

        err := db.(*sql.DB).QueryRow(`
                SELECT id, chama_id, title, description, scheduled_at, duration,
                           location, meeting_url, meeting_type, status, created_by
                FROM meetings
                WHERE id = ?
        `, meetingID).Scan(
                &amp;meeting.ID, &amp;meeting.ChamaID, &amp;meeting.Title, &amp;meeting.Description,
                &amp;meeting.ScheduledAt, &amp;meeting.Duration, &amp;meeting.Location,
                &amp;meeting.MeetingURL, &amp;meeting.MeetingType, &amp;meeting.Status, &amp;meeting.CreatedBy,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Meeting not found",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to fetch meeting details: " + err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Check if user is a member of the chama
        <span class="cov0" title="0">var membershipExists bool
        err = db.(*sql.DB).QueryRow(`
                SELECT EXISTS(
                        SELECT 1 FROM chama_members
                        WHERE chama_id = ? AND user_id = ? AND is_active = TRUE
                )
        `, meeting.ChamaID, userID).Scan(&amp;membershipExists)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify chama membership",
                })
                return
        }</span>

        <span class="cov0" title="0">if !membershipExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Access denied. You are not a member of this chama.",
                })
                return
        }</span>

        // Check if meeting is active or can be joined
        <span class="cov0" title="0">now := time.Now()
        meetingEndTime := meeting.ScheduledAt.Add(time.Duration(meeting.Duration) * time.Minute)
        tenMinutesBefore := meeting.ScheduledAt.Add(-10 * time.Minute) // Updated to match frontend

        // Enhanced join logic - users can join from 10 minutes before until meeting ends
        canJoin := now.After(tenMinutesBefore) &amp;&amp; now.Before(meetingEndTime.Add(1*time.Minute)) // Add 1 minute buffer
        if !canJoin </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting cannot be joined at this time. Join window is 10 minutes before start until meeting ends.",
                        "data": map[string]interface{}{
                                "meetingStart":     meeting.ScheduledAt.Format(time.RFC3339),
                                "meetingEnd":       meetingEndTime.Format(time.RFC3339),
                                "joinWindowStart":  tenMinutesBefore.Format(time.RFC3339),
                                "joinWindowEnd":    meetingEndTime.Add(1 * time.Minute).Format(time.RFC3339),
                                "currentTime":      now.Format(time.RFC3339),
                                "isMeetingActive":  now.After(meeting.ScheduledAt) &amp;&amp; now.Before(meetingEndTime),
                                "remainingMinutes": int(meetingEndTime.Sub(now).Minutes()),
                        },
                })
                return
        }</span>

        // Return meeting join information based on meeting type
        <span class="cov0" title="0">response := gin.H{
                "success": true,
                "message": "Meeting join information retrieved successfully",
                "data": map[string]interface{}{
                        "meeting": map[string]interface{}{
                                "id":          meeting.ID,
                                "title":       meeting.Title,
                                "description": meeting.Description,
                                "scheduledAt": meeting.ScheduledAt.Format(time.RFC3339),
                                "duration":    meeting.Duration,
                                "location":    meeting.Location,
                                "meetingUrl":  meeting.MeetingURL,
                                "meetingType": meeting.MeetingType,
                                "type":        meeting.MeetingType,
                                "status":      meeting.Status,
                        },
                        "joinInfo": map[string]interface{}{
                                "canJoin":          true,
                                "joinWindowStart":  tenMinutesBefore.Format(time.RFC3339),
                                "joinWindowEnd":    meetingEndTime.Add(1 * time.Minute).Format(time.RFC3339),
                                "currentTime":      now.Format(time.RFC3339),
                                "isMeetingActive":  now.After(meeting.ScheduledAt) &amp;&amp; now.Before(meetingEndTime),
                                "remainingMinutes": int(meetingEndTime.Sub(now).Minutes()),
                        },
                },
        }

        // Add specific join instructions based on meeting type
        switch meeting.MeetingType </span>{
        case "virtual":<span class="cov0" title="0">
                if meeting.MeetingURL != "" </span><span class="cov0" title="0">{
                        response["data"].(map[string]interface{})["joinInstructions"] = map[string]interface{}{
                                "type":        "virtual",
                                "instruction": "Click the meeting URL to join the virtual meeting",
                                "meetingUrl":  meeting.MeetingURL,
                        }
                }</span> else<span class="cov0" title="0"> {
                        response["data"].(map[string]interface{})["joinInstructions"] = map[string]interface{}{
                                "type":        "virtual",
                                "instruction": "Virtual meeting details will be provided by the meeting organizer",
                        }
                }</span>
        case "physical":<span class="cov0" title="0">
                response["data"].(map[string]interface{})["joinInstructions"] = map[string]interface{}{
                        "type":        "physical",
                        "instruction": "Please arrive at the specified location",
                        "location":    meeting.Location,
                }</span>
        case "hybrid":<span class="cov0" title="0">
                response["data"].(map[string]interface{})["joinInstructions"] = map[string]interface{}{
                        "type":        "hybrid",
                        "instruction": "You can join either virtually or physically",
                        "location":    meeting.Location,
                        "meetingUrl":  meeting.MeetingURL,
                }</span>
        default:<span class="cov0" title="0">
                response["data"].(map[string]interface{})["joinInstructions"] = map[string]interface{}{
                        "type":        "unknown",
                        "instruction": "Please contact the meeting organizer for join instructions",
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// InitializeMeetingService initializes the meeting service with LiveKit integration
func InitializeMeetingService(db *sql.DB) <span class="cov0" title="0">{
        // Get LiveKit configuration
        config := services.GetLiveKitConfig()

        // Initialize LiveKit service
        livekitService := services.NewLiveKitService(config.WSURL, config.APIKey, config.APISecret)

        // Initialize calendar service (optional)
        var calendarService *services.CalendarService
        // TODO: Initialize calendar service with credentials when available

        // Initialize meeting service
        meetingService = services.NewMeetingService(db, livekitService, calendarService)

        // Initialize and start scheduler service
        schedulerService = services.NewSchedulerService(db, meetingService)
        schedulerService.Start(time.Minute) // Check every minute

        // Fix existing meetings without room names
        log.Println("Ensuring all virtual meetings have room names...")
        err := meetingService.EnsureVirtualMeetingsHaveRoomNames()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to ensure room names for existing meetings: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Meeting service and scheduler initialized successfully")</span>
}

// CreateMeetingWithLiveKit creates a new meeting with LiveKit integration
func CreateMeetingWithLiveKit(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ChamaID          string `json:"chamaId" binding:"required"`
                Title            string `json:"title" binding:"required"`
                Description      string `json:"description"`
                ScheduledAt      string `json:"scheduledAt" binding:"required"`
                Duration         int    `json:"duration"`
                Location         string `json:"location"`
                MeetingURL       string `json:"meetingUrl"`
                MeetingType      string `json:"meetingType" binding:"required"` // 'physical', 'virtual', 'hybrid'
                RecordingEnabled bool   `json:"recordingEnabled"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Validate meeting type
        <span class="cov0" title="0">if req.MeetingType != "physical" &amp;&amp; req.MeetingType != "virtual" &amp;&amp; req.MeetingType != "hybrid" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid meeting type. Must be 'physical', 'virtual', or 'hybrid'",
                })
                return
        }</span>

        // Parse scheduled time
        <span class="cov0" title="0">meetingTime, err := time.Parse(time.RFC3339, req.ScheduledAt)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid scheduled time format. Use RFC3339 format",
                })
                return
        }</span>

        // Check if meeting is in the future
        <span class="cov0" title="0">if meetingTime.Before(time.Now()) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting cannot be scheduled in the past",
                })
                return
        }</span>

        // Set default duration if not provided
        <span class="cov0" title="0">duration := req.Duration
        if duration &lt;= 0 </span><span class="cov0" title="0">{
                duration = 60 // Default 1 hour
        }</span>

        // Create meeting object
        <span class="cov0" title="0">meetingID := uuid.New().String()
        meeting := &amp;services.Meeting{
                ID:               meetingID,
                ChamaID:          req.ChamaID,
                Title:            req.Title,
                Description:      req.Description,
                ScheduledAt:      meetingTime,
                Duration:         duration,
                Location:         req.Location,
                MeetingURL:       req.MeetingURL,
                MeetingType:      req.MeetingType,
                Status:           "scheduled",
                RecordingEnabled: req.RecordingEnabled,
                CreatedBy:        userID.(string),
        }

        // Create meeting with LiveKit integration
        err = meetingService.CreateVirtualMeeting(meeting)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create meeting: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Meeting created successfully with LiveKit integration!",
                "data": gin.H{
                        "id":               meeting.ID,
                        "chamaId":          meeting.ChamaID,
                        "title":            meeting.Title,
                        "description":      meeting.Description,
                        "scheduledAt":      meeting.ScheduledAt.Format(time.RFC3339),
                        "duration":         meeting.Duration,
                        "location":         meeting.Location,
                        "meetingUrl":       meeting.MeetingURL,
                        "meetingType":      meeting.MeetingType,
                        "livekitRoomName":  meeting.LiveKitRoomName,
                        "status":           meeting.Status,
                        "recordingEnabled": meeting.RecordingEnabled,
                        "createdBy":        meeting.CreatedBy,
                },
        })</span>
}

// StartMeeting starts a meeting
func StartMeeting(c *gin.Context) <span class="cov0" title="0">{
        meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">err := meetingService.StartMeeting(meetingID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to start meeting: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Meeting started successfully",
        })</span>
}

// EndMeeting ends a meeting
func EndMeeting(c *gin.Context) <span class="cov0" title="0">{
        meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">err := meetingService.EndMeeting(meetingID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to end meeting: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Meeting ended successfully",
        })</span>
}

// JoinMeetingWithLiveKit generates a LiveKit access token for joining a meeting
func JoinMeetingWithLiveKit(c *gin.Context) <span class="cov0" title="0">{
        meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                UserRole string `json:"userRole"` // 'chairperson', 'secretary', 'treasurer', 'member'
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Default to member role if not specified
                req.UserRole = "member"
        }</span>

        // Generate LiveKit access token
        <span class="cov0" title="0">token, err := meetingService.GenerateJoinToken(meetingID, userID.(string), req.UserRole)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to generate join token: " + err.Error(),
                })
                return
        }</span>

        // Get meeting details
        <span class="cov0" title="0">meeting, err := meetingService.GetMeeting(meetingID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get meeting details: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Join token generated successfully",
                "data": gin.H{
                        "token":            token,
                        "roomName":         meeting.LiveKitRoomName,
                        "wsUrl":            services.GetLiveKitConfig().WSURL,
                        "meetingId":        meetingID,
                        "userRole":         req.UserRole,
                        "meetingTitle":     meeting.Title,
                        "meetingType":      meeting.MeetingType,
                        "recordingEnabled": meeting.RecordingEnabled,
                },
        })</span>
}

// JoinMeetingWithJitsi generates a Jitsi Meet room URL and authentication data for joining a meeting
func JoinMeetingWithJitsi(c *gin.Context) <span class="cov0" title="0">{
        meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                UserRole string `json:"userRole"` // 'chairperson', 'secretary', 'treasurer', 'member'
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Default to member role if not specified
                req.UserRole = "member"
        }</span>

        // Get meeting details
        <span class="cov0" title="0">meeting, err := meetingService.GetMeeting(meetingID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get meeting details: " + err.Error(),
                })
                return
        }</span>

        // Generate Jitsi room data
        <span class="cov0" title="0">jitsiData, err := meetingService.GenerateJitsiRoomData(meetingID, userID.(string), req.UserRole)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to generate Jitsi room data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Jitsi room data generated successfully",
                "data": gin.H{
                        "roomName":         jitsiData.RoomName,
                        "joinUrl":          jitsiData.JoinURL,
                        "roomPassword":     jitsiData.RoomPassword,
                        "isModerator":      jitsiData.IsModerator,
                        "displayName":      jitsiData.DisplayName,
                        "chamaId":          meeting.ChamaID,
                        "meetingId":        meetingID,
                        "userRole":         req.UserRole,
                        "meetingTitle":     meeting.Title,
                        "meetingType":      meeting.MeetingType,
                        "recordingEnabled": meeting.RecordingEnabled,
                },
        })</span>
}

// MarkAttendance marks a user's attendance for a meeting
func MarkAttendance(c *gin.Context) <span class="cov0" title="0">{
        meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                AttendanceType string `json:"attendanceType" binding:"required"` // 'physical', 'virtual'
                IsPresent      bool   `json:"isPresent"`
                UserID         string `json:"userId"` // Optional: for secretary to mark attendance for others
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Determine which user's attendance to mark
        <span class="cov0" title="0">targetUserID := userID.(string) // Default to current user
        if req.UserID != "" </span><span class="cov0" title="0">{
                // Secretary is marking attendance for another user
                targetUserID = req.UserID

                // Verify that the current user has permission to mark attendance for others
                // This should be a secretary or chairperson
                // TODO: Add proper role verification here
                log.Printf("User %s is marking attendance for user %s", userID.(string), targetUserID)
        }</span>

        <span class="cov0" title="0">err := meetingService.MarkAttendance(meetingID, targetUserID, req.AttendanceType, req.IsPresent)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to mark attendance: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Attendance marked successfully",
        })</span>
}

// GetMeetingAttendance retrieves attendance records for a meeting
func GetMeetingAttendance(c *gin.Context) <span class="cov0" title="0">{
        meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">attendances, err := meetingService.GetMeetingAttendance(meetingID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get meeting attendance: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    attendances,
        })</span>
}

// UploadMeetingDocument handles document uploads for meetings
func UploadMeetingDocument(c *gin.Context) <span class="cov0" title="0">{
        log.Printf("📄 UploadMeetingDocument called")

        meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                log.Printf("📄 Missing meeting ID")
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">log.Printf("📄 Meeting ID: %s", meetingID)

        // Get user ID from context
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Debug: Log request details
        <span class="cov0" title="0">log.Printf("📄 Document upload request - Content-Type: %s", c.Request.Header.Get("Content-Type"))
        log.Printf("📄 Document upload request - Content-Length: %d", c.Request.ContentLength)
        log.Printf("📄 Document upload request - Method: %s", c.Request.Method)

        // Parse multipart form
        err := c.Request.ParseMultipartForm(10 &lt;&lt; 20) // 10 MB max
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("📄 Failed to parse multipart form: %v", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Failed to parse multipart form: " + err.Error(),
                })
                return
        }</span>

        // Get file from form
        <span class="cov0" title="0">file, header, err := c.Request.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "No file provided: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Validate file size (10MB max)
        if header.Size &gt; 10*1024*1024 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "File too large. Maximum size is 10MB",
                })
                return
        }</span>

        // Create uploads directory
        <span class="cov0" title="0">uploadsDir := "./uploads/meetings"
        if err := os.MkdirAll(uploadsDir, 0o755); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create upload directory: " + err.Error(),
                })
                return
        }</span>

        // Generate unique filename
        <span class="cov0" title="0">fileExt := filepath.Ext(header.Filename)
        fileName := fmt.Sprintf("%s_%d%s", uuid.New().String(), time.Now().Unix(), fileExt)
        filePath := filepath.Join(uploadsDir, fileName)

        // Save file
        dst, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create file: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer dst.Close()

        if _, err := io.Copy(dst, file); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to save file: " + err.Error(),
                })
                return
        }</span>

        // Create file URL
        <span class="cov0" title="0">fileURL := fmt.Sprintf("/uploads/meetings/%s", fileName)

        // Get form values
        documentType := c.PostForm("documentType")
        description := c.PostForm("description")

        if documentType == "" </span><span class="cov0" title="0">{
                documentType = "meeting_document"
        }</span>

        // Save document info to database
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">documentID := uuid.New().String()
        _, err = db.(*sql.DB).Exec(`
                INSERT INTO meeting_documents (
                        id, meeting_id, uploaded_by, file_name, file_path, file_url,
                        file_size, file_type, document_type, description, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `, documentID, meetingID, userID, header.Filename, filePath, fileURL,
                header.Size, header.Header.Get("Content-Type"), documentType, description)
        if err != nil </span><span class="cov0" title="0">{
                // Clean up uploaded file if database insert fails
                os.Remove(filePath)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to save document info: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Document uploaded successfully",
                "data": map[string]interface{}{
                        "id":           documentID,
                        "meetingId":    meetingID,
                        "fileName":     header.Filename,
                        "fileSize":     header.Size,
                        "fileType":     header.Header.Get("Content-Type"),
                        "documentType": documentType,
                        "description":  description,
                        "url":          fileURL,
                        "uploadedBy":   userID,
                        "uploadedAt":   time.Now().Format(time.RFC3339),
                },
        })</span>
}

// GetMeetingDocuments retrieves all documents for a meeting
func GetMeetingDocuments(c *gin.Context) <span class="cov0" title="0">{
        meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Query documents
        <span class="cov0" title="0">rows, err := db.(*sql.DB).Query(`
                SELECT id, meeting_id, uploaded_by, file_name, file_url, file_size,
                           file_type, document_type, description, created_at
                FROM meeting_documents
                WHERE meeting_id = ?
                ORDER BY created_at DESC
        `, meetingID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch documents: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var documents []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var doc struct {
                        ID           string    `json:"id"`
                        MeetingID    string    `json:"meetingId"`
                        UploadedBy   string    `json:"uploadedBy"`
                        FileName     string    `json:"fileName"`
                        FileURL      string    `json:"fileUrl"`
                        FileSize     int64     `json:"fileSize"`
                        FileType     string    `json:"fileType"`
                        DocumentType string    `json:"documentType"`
                        Description  string    `json:"description"`
                        CreatedAt    time.Time `json:"createdAt"`
                }

                err := rows.Scan(&amp;doc.ID, &amp;doc.MeetingID, &amp;doc.UploadedBy, &amp;doc.FileName,
                        &amp;doc.FileURL, &amp;doc.FileSize, &amp;doc.FileType, &amp;doc.DocumentType,
                        &amp;doc.Description, &amp;doc.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">documents = append(documents, map[string]interface{}{
                        "id":           doc.ID,
                        "meetingId":    doc.MeetingID,
                        "uploadedBy":   doc.UploadedBy,
                        "name":         doc.FileName,
                        "url":          doc.FileURL,
                        "size":         doc.FileSize,
                        "type":         doc.FileType,
                        "documentType": doc.DocumentType,
                        "description":  doc.Description,
                        "uploadedAt":   doc.CreatedAt.Format(time.RFC3339),
                })</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    documents,
        })</span>
}

// DeleteMeetingDocument deletes a document from a meeting
func DeleteMeetingDocument(c *gin.Context) <span class="cov0" title="0">{
        meetingID := c.Param("id")
        documentID := c.Param("docId")

        if meetingID == "" || documentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID and Document ID are required",
                })
                return
        }</span>

        // Get user ID from context for authentication
        <span class="cov0" title="0">_, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get document info first to delete the file
        <span class="cov0" title="0">var filePath string
        err := db.(*sql.DB).QueryRow(`
                SELECT file_path FROM meeting_documents
                WHERE id = ? AND meeting_id = ?
        `, documentID, meetingID).Scan(&amp;filePath)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Document not found",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to find document: " + err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Delete from database first
        <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(`
                DELETE FROM meeting_documents
                WHERE id = ? AND meeting_id = ?
        `, documentID, meetingID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to delete document from database: " + err.Error(),
                })
                return
        }</span>

        // Delete physical file
        <span class="cov0" title="0">if filePath != "" </span><span class="cov0" title="0">{
                os.Remove(filePath) // Ignore error if file doesn't exist
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Document deleted successfully",
        })</span>
}

// SaveMeetingMinutes saves meeting notes/minutes
func SaveMeetingMinutes(c *gin.Context) <span class="cov0" title="0">{
        meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Content   string `json:"content" binding:"required"`
                Status    string `json:"status"`
                MeetingID string `json:"meetingId"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Set default status
        <span class="cov0" title="0">if req.Status == "" </span><span class="cov0" title="0">{
                req.Status = "draft"
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if minutes already exist for this meeting
        <span class="cov0" title="0">var existingID string
        err := db.(*sql.DB).QueryRow(`
                SELECT id FROM meeting_minutes WHERE meeting_id = ?
        `, meetingID).Scan(&amp;existingID)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                // Create new minutes
                minutesID := uuid.New().String()
                _, err = db.(*sql.DB).Exec(`
                        INSERT INTO meeting_minutes (
                                id, meeting_id, content, status, taken_by, created_at, updated_at
                        ) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                `, minutesID, meetingID, req.Content, req.Status, userID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to save meeting minutes: " + err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                        "success": true,
                        "message": "Meeting minutes saved successfully",
                        "data": map[string]interface{}{
                                "id":        minutesID,
                                "meetingId": meetingID,
                                "content":   req.Content,
                                "status":    req.Status,
                                "takenBy":   userID,
                                "createdAt": time.Now().Format(time.RFC3339),
                        },
                })</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to check existing minutes: " + err.Error(),
                })
                return
        }</span> else<span class="cov0" title="0"> {
                // Update existing minutes
                _, err = db.(*sql.DB).Exec(`
                        UPDATE meeting_minutes
                        SET content = ?, status = ?, taken_by = ?, updated_at = CURRENT_TIMESTAMP
                        WHERE id = ?
                `, req.Content, req.Status, userID, existingID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to update meeting minutes: " + err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "Meeting minutes updated successfully",
                        "data": map[string]interface{}{
                                "id":        existingID,
                                "meetingId": meetingID,
                                "content":   req.Content,
                                "status":    req.Status,
                                "takenBy":   userID,
                                "updatedAt": time.Now().Format(time.RFC3339),
                        },
                })</span>
        }
}

// GetMeetingMinutes retrieves meeting minutes
func GetMeetingMinutes(c *gin.Context) <span class="cov0" title="0">{
        meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">var minutes struct {
                ID        string    `json:"id"`
                MeetingID string    `json:"meetingId"`
                Content   string    `json:"content"`
                Status    string    `json:"status"`
                TakenBy   string    `json:"takenBy"`
                CreatedAt time.Time `json:"createdAt"`
                UpdatedAt time.Time `json:"updatedAt"`
        }

        err := db.(*sql.DB).QueryRow(`
                SELECT id, meeting_id, content, status, taken_by, created_at, updated_at
                FROM meeting_minutes
                WHERE meeting_id = ?
        `, meetingID).Scan(&amp;minutes.ID, &amp;minutes.MeetingID, &amp;minutes.Content, &amp;minutes.Status,
                &amp;minutes.TakenBy, &amp;minutes.CreatedAt, &amp;minutes.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{
                                "success": true,
                                "data":    nil,
                                "message": "No minutes found for this meeting",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to fetch meeting minutes: " + err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": map[string]interface{}{
                        "id":        minutes.ID,
                        "meetingId": minutes.MeetingID,
                        "content":   minutes.Content,
                        "status":    minutes.Status,
                        "takenBy":   minutes.TakenBy,
                        "createdAt": minutes.CreatedAt.Format(time.RFC3339),
                        "updatedAt": minutes.UpdatedAt.Format(time.RFC3339),
                },
        })</span>
}

// CreateMeetingWithCalendar creates a new meeting with Google Calendar integration
func CreateMeetingWithCalendar(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ChamaID          string   `json:"chamaId" binding:"required"`
                Title            string   `json:"title" binding:"required"`
                Description      string   `json:"description"`
                ScheduledAt      string   `json:"scheduledAt" binding:"required"`
                Duration         int      `json:"duration" binding:"required"`
                Location         string   `json:"location"`
                MeetingURL       string   `json:"meetingUrl"`
                MeetingType      string   `json:"meetingType" binding:"required"`
                RecordingEnabled bool     `json:"recordingEnabled"`
                AttendeeEmails   []string `json:"attendeeEmails"`
                CalendarID       string   `json:"calendarId"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Parse scheduled time
        <span class="cov0" title="0">scheduledAt, err := time.Parse(time.RFC3339, req.ScheduledAt)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid scheduled time format. Use RFC3339 format",
                })
                return
        }</span>

        // Create meeting object
        <span class="cov0" title="0">meeting := &amp;services.Meeting{
                ID:               uuid.New().String(),
                ChamaID:          req.ChamaID,
                Title:            req.Title,
                Description:      req.Description,
                ScheduledAt:      scheduledAt,
                Duration:         req.Duration,
                Location:         req.Location,
                MeetingURL:       req.MeetingURL,
                MeetingType:      req.MeetingType,
                Status:           "scheduled",
                RecordingEnabled: req.RecordingEnabled,
                CreatedBy:        userID.(string),
        }

        // Create meeting with calendar integration
        err = meetingService.CreateMeetingWithCalendar(meeting, req.AttendeeEmails, req.CalendarID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create meeting with calendar: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create meeting: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Meeting created successfully with calendar integration",
                "data": gin.H{
                        "id":               meeting.ID,
                        "chamaId":          meeting.ChamaID,
                        "title":            meeting.Title,
                        "description":      meeting.Description,
                        "scheduledAt":      meeting.ScheduledAt.Format(time.RFC3339),
                        "duration":         meeting.Duration,
                        "location":         meeting.Location,
                        "meetingUrl":       meeting.MeetingURL,
                        "meetingType":      meeting.MeetingType,
                        "livekitRoomName":  meeting.LiveKitRoomName,
                        "status":           meeting.Status,
                        "recordingEnabled": meeting.RecordingEnabled,
                        "createdBy":        meeting.CreatedBy,
                },
        })</span>
}

// PreviewMeeting allows chairpersons and secretaries to preview a meeting room
func PreviewMeeting(c *gin.Context) <span class="cov0" title="0">{
        meetingID := c.Param("id")
        if meetingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Meeting ID is required",
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get user role from query parameter or request body
        <span class="cov0" title="0">userRole := c.Query("role")
        if userRole == "" </span><span class="cov0" title="0">{
                var req struct {
                        UserRole string `json:"userRole"`
                }
                if err := c.ShouldBindJSON(&amp;req); err == nil </span><span class="cov0" title="0">{
                        userRole = req.UserRole
                }</span>
        }

        // Default to member if no role specified (will be rejected by service)
        <span class="cov0" title="0">if userRole == "" </span><span class="cov0" title="0">{
                userRole = "member"
        }</span>

        // Debug logging before calling preview
        <span class="cov0" title="0">log.Printf("Attempting to preview meeting %s for user %s with role %s", meetingID, userID.(string), userRole)

        // Get meeting preview information
        previewInfo, err := meetingService.GetMeetingPreviewInfo(meetingID, userID.(string), userRole)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Preview error for meeting %s: %v", meetingID, err)
                if err.Error() == "only chairpersons and secretaries can preview meetings" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "success": false,
                                "error":   err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to get meeting preview: " + err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Debug logging
        <span class="cov0" title="0">log.Printf("Preview info generated for meeting %s, user %s, role %s", meetingID, userID.(string), userRole)
        log.Printf("Preview data: accessToken exists: %v, wsURL: %v, roomName: %v",
                previewInfo["accessToken"] != nil &amp;&amp; previewInfo["accessToken"] != "",
                previewInfo["wsURL"],
                previewInfo["roomName"])

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Meeting preview information retrieved successfully",
                "data":    previewInfo,
        })</span>
}

// TestLiveKitConnection tests the LiveKit configuration and connection
func TestLiveKitConnection(c *gin.Context) <span class="cov0" title="0">{
        // Get LiveKit configuration
        config := services.GetLiveKitConfig()

        // Initialize LiveKit service
        livekitService := services.NewLiveKitService(config.WSURL, config.APIKey, config.APISecret)

        // Validate configuration
        err := livekitService.ValidateConfig()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "LiveKit configuration invalid: " + err.Error(),
                        "config": gin.H{
                                "wsUrl":           config.WSURL,
                                "hasApiKey":       config.APIKey != "",
                                "hasApiSecret":    config.APISecret != "",
                                "apiKeyLength":    len(config.APIKey),
                                "apiSecretLength": len(config.APISecret),
                        },
                })
                return
        }</span>

        // Try to generate a test token
        <span class="cov0" title="0">testToken, err := livekitService.GenerateAccessToken("test-room", "test-user", "member")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to generate test token: " + err.Error(),
                        "config": gin.H{
                                "wsUrl":           config.WSURL,
                                "hasApiKey":       config.APIKey != "",
                                "hasApiSecret":    config.APISecret != "",
                                "apiKeyLength":    len(config.APIKey),
                                "apiSecretLength": len(config.APISecret),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "LiveKit configuration is valid",
                "config": gin.H{
                        "wsUrl":           config.WSURL,
                        "hasApiKey":       config.APIKey != "",
                        "hasApiSecret":    config.APISecret != "",
                        "apiKeyLength":    len(config.APIKey),
                        "apiSecretLength": len(config.APISecret),
                },
                "testToken": gin.H{
                        "generated":    true,
                        "tokenLength":  len(testToken),
                        "tokenPreview": testToken[:50] + "...",
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

// Merry-Go-Round handlers
func GetMerryGoRounds(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">chamaID := c.Query("chamaId")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "chamaId parameter is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if user is a member of the chama
        <span class="cov0" title="0">var membershipExists bool
        err := db.(*sql.DB).QueryRow(`
                SELECT EXISTS(
                        SELECT 1 FROM chama_members
                        WHERE chama_id = ? AND user_id = ? AND is_active = TRUE
                )
        `, chamaID, userID).Scan(&amp;membershipExists)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify chama membership",
                })
                return
        }</span>

        <span class="cov0" title="0">if !membershipExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Access denied. You are not a member of this chama.",
                })
                return
        }</span>

        // Query merry-go-rounds for the chama
        <span class="cov0" title="0">rows, err := db.(*sql.DB).Query(`
                SELECT
                        mgr.id, mgr.chama_id, mgr.name, mgr.description, mgr.amount_per_round,
                        mgr.frequency, mgr.total_participants, mgr.current_round, mgr.status,
                        mgr.start_date, mgr.next_payout_date, mgr.created_by, mgr.created_at,
                        u.first_name, u.last_name, u.email
                FROM merry_go_rounds mgr
                JOIN users u ON mgr.created_by = u.id
                WHERE mgr.chama_id = ?
                ORDER BY mgr.created_at DESC
        `, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch merry-go-rounds: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var merryGoRounds []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var mgr struct {
                        ID                string     `json:"id"`
                        ChamaID           string     `json:"chamaId"`
                        Name              string     `json:"name"`
                        Description       string     `json:"description"`
                        AmountPerRound    float64    `json:"amountPerRound"`
                        Frequency         string     `json:"frequency"`
                        TotalParticipants int        `json:"totalParticipants"`
                        CurrentRound      int        `json:"currentRound"`
                        Status            string     `json:"status"`
                        StartDate         time.Time  `json:"startDate"`
                        NextPayoutDate    *time.Time `json:"nextPayoutDate"`
                        CreatedBy         string     `json:"createdBy"`
                        CreatedAt         time.Time  `json:"createdAt"`
                        CreatorFirstName  string     `json:"creatorFirstName"`
                        CreatorLastName   string     `json:"creatorLastName"`
                        CreatorEmail      string     `json:"creatorEmail"`
                }

                err := rows.Scan(
                        &amp;mgr.ID, &amp;mgr.ChamaID, &amp;mgr.Name, &amp;mgr.Description, &amp;mgr.AmountPerRound,
                        &amp;mgr.Frequency, &amp;mgr.TotalParticipants, &amp;mgr.CurrentRound, &amp;mgr.Status,
                        &amp;mgr.StartDate, &amp;mgr.NextPayoutDate, &amp;mgr.CreatedBy, &amp;mgr.CreatedAt,
                        &amp;mgr.CreatorFirstName, &amp;mgr.CreatorLastName, &amp;mgr.CreatorEmail,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid rows
                }

                <span class="cov0" title="0">nextPayoutDateStr := ""
                if mgr.NextPayoutDate != nil </span><span class="cov0" title="0">{
                        nextPayoutDateStr = mgr.NextPayoutDate.Format(time.RFC3339)
                }</span>

                // Get participants for this merry-go-round
                <span class="cov0" title="0">participantRows, err := db.(*sql.DB).Query(`
                        SELECT
                                mgrp.user_id, mgrp.position, mgrp.has_received,
                                u.first_name, u.last_name, u.email
                        FROM merry_go_round_participants mgrp
                        JOIN users u ON mgrp.user_id = u.id
                        WHERE mgrp.merry_go_round_id = ?
                        ORDER BY mgrp.position ASC
                `, mgr.ID)

                var participants []map[string]interface{}
                if err == nil </span><span class="cov0" title="0">{
                        defer participantRows.Close()
                        for participantRows.Next() </span><span class="cov0" title="0">{
                                var p struct {
                                        UserID      string `json:"userId"`
                                        Position    int    `json:"position"`
                                        HasReceived bool   `json:"hasReceived"`
                                        FirstName   string `json:"firstName"`
                                        LastName    string `json:"lastName"`
                                        Email       string `json:"email"`
                                }

                                err := participantRows.Scan(&amp;p.UserID, &amp;p.Position, &amp;p.HasReceived, &amp;p.FirstName, &amp;p.LastName, &amp;p.Email)
                                if err == nil </span><span class="cov0" title="0">{
                                        // Determine status based on position and current round
                                        var status string
                                        if p.Position &lt; mgr.CurrentRound </span><span class="cov0" title="0">{
                                                status = "completed"
                                        }</span> else<span class="cov0" title="0"> if p.Position == mgr.CurrentRound </span><span class="cov0" title="0">{
                                                status = "current"
                                        }</span> else<span class="cov0" title="0"> {
                                                status = "pending"
                                        }</span>

                                        <span class="cov0" title="0">participant := map[string]interface{}{
                                                "id":           fmt.Sprintf("%s-%d", mgr.ID, p.Position), // Unique participant ID
                                                "user_id":      p.UserID,
                                                "position":     p.Position,
                                                "status":       status,
                                                "has_received": p.HasReceived,
                                                "user": map[string]interface{}{
                                                        "id":         p.UserID,
                                                        "first_name": p.FirstName,
                                                        "last_name":  p.LastName,
                                                        "email":      p.Email,
                                                        "username":   p.Email, // Use email as username fallback
                                                        "full_name":  p.FirstName + " " + p.LastName,
                                                },
                                                "has_contributed_this_cycle": false, // Mock - would need real tracking
                                        }
                                        participants = append(participants, participant)</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        fmt.Printf("❌ Failed to query participants for merry-go-round %s: %v\n", mgr.ID, err)
                }</span>

                // Calculate total payout (amount per round * number of participants)
                <span class="cov0" title="0">totalPayout := mgr.AmountPerRound * float64(len(participants))

                mgrMap := map[string]interface{}{
                        "id":                 mgr.ID,
                        "chamaId":            mgr.ChamaID,
                        "name":               mgr.Name,
                        "description":        mgr.Description,
                        "amountPerRound":     mgr.AmountPerRound,
                        "amount_per_round":   mgr.AmountPerRound, // Alternative field name
                        "frequency":          mgr.Frequency,
                        "totalParticipants":  mgr.TotalParticipants,
                        "total_participants": len(participants), // Use actual participant count
                        "currentRound":       mgr.CurrentRound,
                        "current_round":      mgr.CurrentRound,     // Alternative field name
                        "current_position":   mgr.CurrentRound - 1, // Zero-based position
                        "status":             mgr.Status,
                        "startDate":          mgr.StartDate.Format("2006-01-02"),
                        "start_date":         mgr.StartDate.Format("2006-01-02"), // Alternative field name
                        "nextPayoutDate":     nextPayoutDateStr,
                        "next_payout_date":   nextPayoutDateStr, // Alternative field name
                        "createdBy":          mgr.CreatedBy,
                        "created_by":         mgr.CreatedBy, // Alternative field name
                        "createdAt":          mgr.CreatedAt.Format(time.RFC3339),
                        "created_at":         mgr.CreatedAt.Format(time.RFC3339), // Alternative field name
                        "total_payout":       totalPayout,
                        "members":            participants,
                        "participants":       participants, // Alternative field name
                        "creator": map[string]interface{}{
                                "id":        mgr.CreatedBy,
                                "firstName": mgr.CreatorFirstName,
                                "lastName":  mgr.CreatorLastName,
                                "email":     mgr.CreatorEmail,
                                "fullName":  mgr.CreatorFirstName + " " + mgr.CreatorLastName,
                        },
                }

                merryGoRounds = append(merryGoRounds, mgrMap)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    merryGoRounds,
                "message": fmt.Sprintf("Found %d merry-go-rounds", len(merryGoRounds)),
                "meta": map[string]interface{}{
                        "total":   len(merryGoRounds),
                        "chamaId": chamaID,
                },
        })</span>
}

func CreateMerryGoRound(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ChamaID           string  `json:"chamaId" binding:"required"`
                Name              string  `json:"name" binding:"required"`
                Description       string  `json:"description"`
                AmountPerRound    float64 `json:"amountPerRound" binding:"required"`
                Frequency         string  `json:"frequency" binding:"required"`
                TotalParticipants int     `json:"totalParticipants" binding:"required"`
                StartDate         string  `json:"startDate" binding:"required"`
                Participants      []struct {
                        UserID   string `json:"userId"`
                        Position int    `json:"position"`
                        Name     string `json:"name"`
                        Email    string `json:"email"`
                } `json:"participants"`
                ParticipantOrder string `json:"participantOrder"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Validate amount
        <span class="cov0" title="0">if req.AmountPerRound &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Amount per round must be greater than 0",
                })
                return
        }</span>

        // Validate total participants
        <span class="cov0" title="0">if req.TotalParticipants &lt; 2 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "At least 2 participants are required",
                })
                return
        }</span>

        // Validate frequency
        <span class="cov0" title="0">validFrequencies := map[string]bool{"weekly": true, "monthly": true}
        if !validFrequencies[req.Frequency] </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Frequency must be 'weekly' or 'monthly'",
                })
                return
        }</span>

        // Parse start date
        <span class="cov0" title="0">startDate, err := time.Parse("2006-01-02", req.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid start date format. Use YYYY-MM-DD",
                })
                return
        }</span>

        // Check if start date is not too far in the past (allow today and future dates)
        <span class="cov0" title="0">today := time.Now().Truncate(24 * time.Hour)
        if startDate.Before(today) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Start date cannot be in the past. Please select today or a future date.",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if user is a member of the chama
        <span class="cov0" title="0">var membershipExists bool
        err = db.(*sql.DB).QueryRow(`
                SELECT EXISTS(
                        SELECT 1 FROM chama_members
                        WHERE chama_id = ? AND user_id = ? AND is_active = TRUE
                )
        `, req.ChamaID, userID).Scan(&amp;membershipExists)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify chama membership",
                })
                return
        }</span>

        <span class="cov0" title="0">if !membershipExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Access denied. You are not a member of this chama.",
                })
                return
        }</span>

        // Generate merry-go-round ID
        <span class="cov0" title="0">mgrID := fmt.Sprintf("mgr-%d", time.Now().UnixNano())

        // Calculate next payout date
        var nextPayoutDate time.Time
        if req.Frequency == "weekly" </span><span class="cov0" title="0">{
                nextPayoutDate = startDate.AddDate(0, 0, 7)
        }</span> else<span class="cov0" title="0"> { // monthly
                nextPayoutDate = startDate.AddDate(0, 1, 0)
        }</span>

        // Insert merry-go-round into database
        <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(`
                INSERT INTO merry_go_rounds (
                        id, chama_id, name, description, amount_per_round, frequency,
                        total_participants, current_round, status, start_date, next_payout_date,
                        created_by, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, 1, 'active', ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `, mgrID, req.ChamaID, req.Name, req.Description, req.AmountPerRound, req.Frequency, req.TotalParticipants, startDate, nextPayoutDate, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create merry-go-round: " + err.Error(),
                })
                return
        }</span>

        // Insert participants into merry_go_round_participants table
        <span class="cov0" title="0">if len(req.Participants) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("🔄 Inserting %d participants into merry_go_round_participants table\n", len(req.Participants))

                for i, participant := range req.Participants </span><span class="cov0" title="0">{
                        participantID := fmt.Sprintf("mgrp-%d-%d", time.Now().UnixNano(), i)

                        fmt.Printf("📝 Adding participant: ID=%s, UserID=%s, Position=%d\n", participantID, participant.UserID, participant.Position)

                        _, err = db.(*sql.DB).Exec(`
                                INSERT INTO merry_go_round_participants (
                                        id, merry_go_round_id, user_id, position, has_received, received_at,
                                        total_contributed, joined_at
                                ) VALUES (?, ?, ?, ?, FALSE, NULL, 0, CURRENT_TIMESTAMP)
                        `, participantID, mgrID, participant.UserID, participant.Position)

                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("❌ Failed to add participant %s (UserID: %s): %v\n", participantID, participant.UserID, err)
                                // Continue with other participants instead of failing completely
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("✅ Successfully added participant %s\n", participantID)
                        }</span>
                }

                // Verify participants were inserted
                <span class="cov0" title="0">var participantCount int
                err = db.(*sql.DB).QueryRow(`
                        SELECT COUNT(*) FROM merry_go_round_participants
                        WHERE merry_go_round_id = ?
                `, mgrID).Scan(&amp;participantCount)

                if err == nil </span><span class="cov0" title="0">{
                        fmt.Printf("🔍 Verification: %d participants found in database for merry-go-round %s\n", participantCount, mgrID)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("⚠️ No participants provided in request\n")
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Merry-go-round created successfully! Members can now join.",
                "data": map[string]interface{}{
                        "id":                mgrID,
                        "chamaId":           req.ChamaID,
                        "name":              req.Name,
                        "description":       req.Description,
                        "amountPerRound":    req.AmountPerRound,
                        "frequency":         req.Frequency,
                        "totalParticipants": req.TotalParticipants,
                        "currentRound":      1,
                        "status":            "active",
                        "startDate":         req.StartDate,
                        "nextPayoutDate":    nextPayoutDate.Format("2006-01-02"),
                        "createdBy":         userID,
                        "createdAt":         time.Now().Format(time.RFC3339),
                },
        })</span>
}

func GetMerryGoRound(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Get merry-go-round endpoint - coming soon",
        })
}</span>

func UpdateMerryGoRound(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Update merry-go-round endpoint - coming soon",
        })
}</span>

func DeleteMerryGoRound(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delete merry-go-round endpoint - coming soon",
        })
}</span>

func JoinMerryGoRound(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Join merry-go-round endpoint - coming soon",
        })
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "net/http"
        "regexp"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type MoneyRequestHandlers struct {
        db *sql.DB
}

func NewMoneyRequestHandlers(db *sql.DB) *MoneyRequestHandlers <span class="cov0" title="0">{
        return &amp;MoneyRequestHandlers{db: db}
}</span>

// normalizePhoneNumber removes spaces, dashes and normalizes phone number format
func normalizePhoneNumber(phone string) string <span class="cov0" title="0">{
        // Remove all non-digit characters except +
        re := regexp.MustCompile(`[^\d+]`)
        normalized := re.ReplaceAllString(phone, "")

        // Remove leading + if present
        normalized = strings.TrimPrefix(normalized, "+")

        // If it starts with 254, keep as is
        if strings.HasPrefix(normalized, "254") </span><span class="cov0" title="0">{
                return normalized
        }</span>

        // If it starts with 0, replace with 254
        <span class="cov0" title="0">if strings.HasPrefix(normalized, "0") </span><span class="cov0" title="0">{
                return "254" + normalized[1:]
        }</span>

        // If it's 9 digits starting with 7, add 254
        <span class="cov0" title="0">if len(normalized) == 9 &amp;&amp; strings.HasPrefix(normalized, "7") </span><span class="cov0" title="0">{
                return "254" + normalized
        }</span>

        <span class="cov0" title="0">return normalized</span>
}

type CreateMoneyRequestRequest struct {
        Amount      float64 `json:"amount" binding:"required,gt=0"`
        Reason      string  `json:"reason"`
        RequestType string  `json:"requestType" binding:"required,oneof=qr_code direct"`
}

type SendMoneyRequestRequest struct {
        Amount       float64 `json:"amount" binding:"required,gt=0"`
        Reason       string  `json:"reason"`
        TargetUserID string  `json:"targetUserId"`
        TargetPhone  string  `json:"targetPhone"`
        RequestType  string  `json:"requestType" binding:"required,oneof=direct"`
}

type MoneyRequest struct {
        ID           string    `json:"id"`
        RequesterID  string    `json:"requesterId"`
        TargetUserID *string   `json:"targetUserId,omitempty"`
        Amount       float64   `json:"amount"`
        Reason       string    `json:"reason"`
        RequestType  string    `json:"requestType"`
        Status       string    `json:"status"`
        CreatedAt    time.Time `json:"createdAt"`
        ExpiresAt    time.Time `json:"expiresAt"`
}

// CreateMoneyRequest creates a new money request (for QR codes)
func (h *MoneyRequestHandlers) CreateMoneyRequest(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req CreateMoneyRequestRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Generate unique request ID
        <span class="cov0" title="0">requestID := uuid.New().String()
        expiresAt := time.Now().Add(24 * time.Hour) // Expires in 24 hours

        // Insert money request into database
        query := `
                INSERT INTO money_requests (id, requester_id, amount, reason, request_type, status, created_at, expires_at)
                VALUES (?, ?, ?, ?, ?, 'pending', ?, ?)
        `

        _, err := h.db.Exec(query, requestID, userID, req.Amount, req.Reason, req.RequestType, time.Now(), expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create money request: " + err.Error(),
                })
                return
        }</span>

        // Return the created request
        <span class="cov0" title="0">moneyRequest := MoneyRequest{
                ID:          requestID,
                RequesterID: userID,
                Amount:      req.Amount,
                Reason:      req.Reason,
                RequestType: req.RequestType,
                Status:      "pending",
                CreatedAt:   time.Now(),
                ExpiresAt:   expiresAt,
        }

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    moneyRequest,
                "message": "Money request created successfully",
        })</span>
}

// SendMoneyRequest sends a direct money request to a specific user
func (h *MoneyRequestHandlers) SendMoneyRequest(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req SendMoneyRequestRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Find target user by ID or phone
        <span class="cov0" title="0">var targetUserID string
        if req.TargetUserID != "" </span><span class="cov0" title="0">{
                targetUserID = req.TargetUserID
        }</span> else<span class="cov0" title="0"> if req.TargetPhone != "" </span><span class="cov0" title="0">{
                // Normalize phone number (remove spaces, dashes, and ensure proper format)
                normalizedPhone := normalizePhoneNumber(req.TargetPhone)

                // Find user by phone number - try multiple formats
                query := `
                        SELECT id FROM users
                        WHERE phone = ? OR phone = ? OR phone = ? OR phone = ?
                `

                // Try different phone number formats
                formats := []string{
                        normalizedPhone,              // As provided (normalized)
                        req.TargetPhone,              // Original format
                        "+254" + normalizedPhone[1:], // Add country code if missing
                        "254" + normalizedPhone[1:],  // Add country code without +
                }

                err := h.db.QueryRow(query, formats[0], formats[1], formats[2], formats[3]).Scan(&amp;targetUserID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   fmt.Sprintf("User not found with phone number: %s (tried formats: %v)", req.TargetPhone, formats),
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Either targetUserId or targetPhone must be provided",
                })
                return
        }</span>

        // Generate unique request ID
        <span class="cov0" title="0">requestID := uuid.New().String()
        expiresAt := time.Now().Add(24 * time.Hour) // Expires in 24 hours

        // Insert money request into database
        query := `
                INSERT INTO money_requests (id, requester_id, target_user_id, amount, reason, request_type, status, created_at, expires_at)
                VALUES (?, ?, ?, ?, ?, ?, 'pending', ?, ?)
        `

        _, err := h.db.Exec(query, requestID, userID, targetUserID, req.Amount, req.Reason, req.RequestType, time.Now(), expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to send money request: " + err.Error(),
                })
                return
        }</span>

        // Create in-app notification for target user
        <span class="cov0" title="0">notificationID := uuid.New().String()
        notificationQuery := `
                INSERT INTO notifications (id, user_id, type, title, message, data, created_at, is_read)
                VALUES (?, ?, 'money_request', ?, ?, ?, ?, false)
        `

        // Get requester name for notification
        var requesterName string
        err = h.db.QueryRow("SELECT CONCAT(COALESCE(first_name, ''), ' ', COALESCE(last_name, '')) FROM users WHERE id = ?", userID).Scan(&amp;requesterName)
        if err != nil </span><span class="cov0" title="0">{
                requesterName = "Someone"
        }</span>

        <span class="cov0" title="0">notificationTitle := "Money Request"
        notificationMessage := fmt.Sprintf("%s has requested KES %.2f from you", requesterName, req.Amount)
        notificationData := fmt.Sprintf(`{"requestId": "%s", "amount": %.2f, "reason": "%s", "requesterId": "%s"}`, requestID, req.Amount, req.Reason, userID)

        _, err = h.db.Exec(notificationQuery, notificationID, targetUserID, notificationTitle, notificationMessage, notificationData, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the request
                fmt.Printf("Failed to create notification: %v\n", err)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Money request sent successfully",
                "data": gin.H{
                        "requestId":    requestID,
                        "targetUserId": targetUserID,
                },
        })</span>
}

// GetRecentContacts returns users who have previously sent money to the current user
func (h *MoneyRequestHandlers) GetRecentContacts(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Query for users who have sent money to this user before
        // Since recipient_id might not be populated in existing transactions,
        // we'll also check initiated_by field and return some sample users for now
        <span class="cov0" title="0">query := `
                SELECT DISTINCT
                        u.id,
                        u.first_name,
                        u.last_name,
                        u.phone,
                        u.email,
                        COALESCE(MAX(t.amount), 1000.0) as last_amount,
                        COALESCE(MAX(t.created_at), datetime('now', '-1 day')) as last_transaction_date
                FROM users u
                LEFT JOIN transactions t ON (u.id = t.recipient_id OR u.id = t.initiated_by)
                WHERE u.id != ?
                        AND (t.recipient_id = ? OR t.initiated_by != ? OR t.id IS NULL)
                        AND (t.type IN ('transfer', 'payment', 'deposit') OR t.id IS NULL)
                        AND (t.status = 'completed' OR t.id IS NULL)
                GROUP BY u.id, u.first_name, u.last_name, u.phone, u.email
                ORDER BY last_transaction_date DESC
                LIMIT 5
        `

        rows, err := h.db.Query(query, userID, userID, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch recent contacts: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var contacts []gin.H
        for rows.Next() </span><span class="cov0" title="0">{
                var contact struct {
                        ID                  string    `db:"id"`
                        FirstName           *string   `db:"first_name"`
                        LastName            *string   `db:"last_name"`
                        Phone               *string   `db:"phone"`
                        Email               *string   `db:"email"`
                        LastAmount          float64   `db:"last_amount"`
                        LastTransactionDate time.Time `db:"last_transaction_date"`
                }

                err := rows.Scan(
                        &amp;contact.ID,
                        &amp;contact.FirstName,
                        &amp;contact.LastName,
                        &amp;contact.Phone,
                        &amp;contact.Email,
                        &amp;contact.LastAmount,
                        &amp;contact.LastTransactionDate,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">contacts = append(contacts, gin.H{
                        "id":                  contact.ID,
                        "first_name":          contact.FirstName,
                        "last_name":           contact.LastName,
                        "phone":               contact.Phone,
                        "email":               contact.Email,
                        "lastAmount":          contact.LastAmount,
                        "lastTransactionDate": contact.LastTransactionDate,
                })</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    contacts,
        })</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "log"
        "net/http"
        "strings"
        "time"
        "vaultke-backend/internal/config"
        "vaultke-backend/internal/models"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// Payment handlers
func InitiateMpesaSTK(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var req models.MpesaTransaction
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request format: " + err.Error(),
                })
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.PhoneNumber == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Phone number is required",
                })
                return
        }</span>

        <span class="cov0" title="0">if req.Amount &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Amount must be greater than 0",
                })
                return
        }</span>

        // Validate phone number format (Kenyan format)
        <span class="cov0" title="0">phoneNumber := strings.TrimSpace(req.PhoneNumber)
        if strings.HasPrefix(phoneNumber, "0") </span><span class="cov0" title="0">{
                phoneNumber = "254" + phoneNumber[1:]
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(phoneNumber, "+254") </span><span class="cov0" title="0">{
                phoneNumber = phoneNumber[1:]
        }</span> else<span class="cov0" title="0"> if !strings.HasPrefix(phoneNumber, "254") </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid phone number format. Use format: 254XXXXXXXXX",
                })
                return
        }</span>

        // Update phone number in request
        <span class="cov0" title="0">req.PhoneNumber = phoneNumber

        // Set default values if not provided
        if req.AccountReference == "" </span><span class="cov0" title="0">{
                req.AccountReference = "VaultKe"
        }</span>
        <span class="cov0" title="0">if req.TransactionDesc == "" </span><span class="cov0" title="0">{
                req.TransactionDesc = "VaultKe Deposit"
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get configuration
        <span class="cov0" title="0">cfg, exists := c.Get("config")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Configuration not available",
                })
                return
        }</span>

        // Create M-Pesa service
        <span class="cov0" title="0">mpesaService := services.NewMpesaService(db.(*sql.DB), cfg.(*config.Config))

        // Generate reference for direct STK push
        reference := fmt.Sprintf("STK_%d_%s", time.Now().UnixNano(), userID.(string)[:8])

        // Create pending transaction record first
        transactionID, err := createPendingMpesaTransaction(db.(*sql.DB), &amp;req, userID.(string), reference)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create pending transaction: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create transaction record",
                })
                return
        }</span>

        // Initiate STK push
        <span class="cov0" title="0">stkResponse, err := mpesaService.InitiateSTKPush(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("STK Push failed: %v", err)

                // Mark transaction as failed with proper error details
                failureReason := fmt.Sprintf("M-Pesa STK Push failed: %v", err)

                // Update transaction status to failed
                updateErr := updateTransactionStatus(db.(*sql.DB), transactionID, models.TransactionStatusFailed)
                if updateErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to update transaction status to failed: %v", updateErr)
                }</span>

                // Update additional failure details
                <span class="cov0" title="0">_, updateErr = db.(*sql.DB).Exec(`
                        UPDATE transactions
                        SET reference = ?,
                            description = CONCAT(description, ' - ', ?),
                            updated_at = CURRENT_TIMESTAMP
                        WHERE id = ?
                `, fmt.Sprintf("FAILED_STK_%d", time.Now().UnixNano()), failureReason, transactionID)

                if updateErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to update transaction failure details: %v", updateErr)
                }</span>

                // Return proper error response
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to initiate M-Pesa payment: STK push failed",
                        "details": err.Error(),
                        "data": gin.H{
                                "transactionId": transactionID,
                                "status":        "failed",
                                "reason":        failureReason,
                        },
                })
                return</span>
        }

        // Update transaction with checkout request ID
        <span class="cov0" title="0">updateTransactionReference(db.(*sql.DB), transactionID, stkResponse.CheckoutRequestID)

        // Return success response
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "STK push initiated successfully",
                "data": gin.H{
                        "transactionId":       transactionID,
                        "checkoutRequestId":   stkResponse.CheckoutRequestID,
                        "merchantRequestId":   stkResponse.MerchantRequestID,
                        "customerMessage":     stkResponse.CustomerMessage,
                        "responseDescription": stkResponse.ResponseDescription,
                },
        })</span>
}

func HandleMpesaCallback(c *gin.Context) <span class="cov0" title="0">{
        log.Println("📱 M-Pesa callback received")

        // Parse callback data
        var callback models.MpesaCallback
        if err := c.ShouldBindJSON(&amp;callback); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to parse callback: %v", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid callback format",
                })
                return
        }</span>

        <span class="cov0" title="0">log.Printf("📱 Callback data: %+v", callback)

        // Get database connection
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                log.Println("Database connection not available")
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get configuration
        <span class="cov0" title="0">cfg, exists := c.Get("config")
        if !exists </span><span class="cov0" title="0">{
                log.Println("Configuration not available")
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Configuration not available",
                })
                return
        }</span>

        // Create M-Pesa service
        <span class="cov0" title="0">mpesaService := services.NewMpesaService(db.(*sql.DB), cfg.(*config.Config))

        // Process the callback
        err := mpesaService.ProcessMpesaCallback(&amp;callback)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to process M-Pesa callback: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to process callback",
                })
                return
        }</span>

        <span class="cov0" title="0">log.Println("✅ M-Pesa callback processed successfully")

        // Return success response (required by Safaricom)
        c.JSON(http.StatusOK, gin.H{
                "ResultCode": 0,
                "ResultDesc": "Success",
        })</span>
}

// GetMpesaTransactionStatus checks the status of an M-Pesa transaction
func GetMpesaTransactionStatus(c *gin.Context) <span class="cov0" title="0">{
        checkoutRequestID := c.Param("checkoutRequestId")
        if checkoutRequestID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Checkout request ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get configuration
        <span class="cov0" title="0">cfg, exists := c.Get("config")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Configuration not available",
                })
                return
        }</span>

        // Create M-Pesa service
        <span class="cov0" title="0">mpesaService := services.NewMpesaService(db.(*sql.DB), cfg.(*config.Config))

        // Check transaction status
        status, err := mpesaService.GetTransactionStatus(checkoutRequestID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get transaction status: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to check transaction status",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "checkoutRequestId": checkoutRequestID,
                        "status":            status,
                },
        })</span>
}

// createPendingMpesaTransaction creates a pending transaction record
func createPendingMpesaTransaction(db *sql.DB, req *models.MpesaTransaction, userID string, reference string) (string, error) <span class="cov0" title="0">{
        // Find user's personal wallet
        var walletID string
        walletQuery := "SELECT id FROM wallets WHERE owner_id = ? AND type = ?"
        err := db.QueryRow(walletQuery, userID, models.WalletTypePersonal).Scan(&amp;walletID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to find user wallet: %w", err)
        }</span>

        // Generate transaction ID
        <span class="cov0" title="0">transactionID := fmt.Sprintf("TXN_%d", time.Now().UnixNano())

        // Create pending transaction with proper reference and auto-approval
        insertQuery := `
                INSERT INTO transactions (
                        id, to_wallet_id, type, status, amount, currency, description,
                        reference, payment_method, initiated_by, approved_by, requires_approval, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `

        _, err = db.Exec(insertQuery,
                transactionID, walletID, models.TransactionTypeDeposit, models.TransactionStatusPending,
                req.Amount, "KES", req.TransactionDesc, reference, models.PaymentMethodMpesa,
                userID, userID, false, // approved_by = userID (self-approved deposit)
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create pending transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return transactionID, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "net/http"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
)

// GetNotifications retrieves all types of notifications for the authenticated user
func GetNotifications(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, _ := strconv.Atoi(limitStr)
        offset, _ := strconv.Atoi(offsetStr)

        // Get database from context
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get all notifications from different sources
        <span class="cov0" title="0">allNotifications := []map[string]interface{}{}

        // Get deleted virtual notification IDs for filtering
        deletedVirtualNotifications := getDeletedVirtualNotificationIDs(db.(*sql.DB), userID)

        // 1. Get system notifications
        systemNotifications, err := getSystemNotifications(db.(*sql.DB), userID)
        if err == nil </span><span class="cov0" title="0">{
                allNotifications = append(allNotifications, systemNotifications...)
        }</span>

        // 2. Get chama invitations
        <span class="cov0" title="0">invitationNotifications, err := getChamaInvitationNotifications(db.(*sql.DB), userID)
        if err == nil </span><span class="cov0" title="0">{
                // Filter out deleted virtual notifications
                filteredInvitations := filterDeletedNotifications(invitationNotifications, deletedVirtualNotifications)
                allNotifications = append(allNotifications, filteredInvitations...)
        }</span>

        // 3. Get meeting notifications
        <span class="cov0" title="0">meetingNotifications, err := getMeetingNotifications(db.(*sql.DB), userID)
        if err == nil </span><span class="cov0" title="0">{
                // Filter out deleted virtual notifications
                filteredMeetings := filterDeletedNotifications(meetingNotifications, deletedVirtualNotifications)
                allNotifications = append(allNotifications, filteredMeetings...)
        }</span>

        // 4. Get financial notifications
        <span class="cov0" title="0">financialNotifications, err := getFinancialNotifications(db.(*sql.DB), userID)
        if err == nil </span><span class="cov0" title="0">{
                // Filter out deleted virtual notifications
                filteredFinancial := filterDeletedNotifications(financialNotifications, deletedVirtualNotifications)
                allNotifications = append(allNotifications, filteredFinancial...)
        }</span>

        // 5. Get chama activity notifications
        <span class="cov0" title="0">chamaNotifications, err := getChamaActivityNotifications(db.(*sql.DB), userID)
        if err == nil </span><span class="cov0" title="0">{
                // Filter out deleted virtual notifications
                filteredChama := filterDeletedNotifications(chamaNotifications, deletedVirtualNotifications)
                allNotifications = append(allNotifications, filteredChama...)
        }</span>

        // 6. Get support request notifications
        <span class="cov0" title="0">supportNotifications, err := getSupportRequestNotifications(db.(*sql.DB), userID)
        if err == nil </span><span class="cov0" title="0">{
                // Filter out deleted virtual notifications
                filteredSupport := filterDeletedNotifications(supportNotifications, deletedVirtualNotifications)
                allNotifications = append(allNotifications, filteredSupport...)
        }</span>

        // Sort all notifications by created_at (most recent first)
        <span class="cov0" title="0">sortNotificationsByDate(allNotifications)

        // Apply pagination
        totalCount := len(allNotifications)
        start := offset
        end := offset + limit
        if start &gt; totalCount </span><span class="cov0" title="0">{
                start = totalCount
        }</span>
        <span class="cov0" title="0">if end &gt; totalCount </span><span class="cov0" title="0">{
                end = totalCount
        }</span>

        <span class="cov0" title="0">paginatedNotifications := allNotifications[start:end]

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    paginatedNotifications,
                "meta": map[string]interface{}{
                        "total":  totalCount,
                        "limit":  limit,
                        "offset": offset,
                },
        })</span>
}

// GetUnreadNotificationCount returns the count of unread notifications for the authenticated user
func GetUnreadNotificationCount(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // For now, return a simple count from the notifications table
        // This can be enhanced later to include counts from other notification sources
        <span class="cov0" title="0">query := `
                SELECT COUNT(*)
                FROM notifications
                WHERE user_id = ? AND is_read = false
        `

        var count int
        err := db.(*sql.DB).QueryRow(query, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get unread notification count",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "count": count,
                },
        })</span>
}

// MarkNotificationAsRead marks a notification as read
func MarkNotificationAsRead(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        notificationID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Handle different notification sources
        <span class="cov0" title="0">if handleSpecialNotificationRead(db.(*sql.DB), notificationID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "Notification marked as read",
                })
                return
        }</span>

        // Update notification in the notifications table
        <span class="cov0" title="0">query := `
                UPDATE notifications
                SET is_read = true
                WHERE id = ? AND user_id = ?
        `

        result, err := db.(*sql.DB).Exec(query, notificationID, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to mark notification as read",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Notification not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Notification marked as read",
        })</span>
}

// MarkAllNotificationsAsRead marks all notifications as read for a user
func MarkAllNotificationsAsRead(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Update all notifications for the user in the notifications table
        <span class="cov0" title="0">query := `
                UPDATE notifications
                SET is_read = true
                WHERE user_id = ? AND is_read = false
        `

        result, err := db.(*sql.DB).Exec(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to mark notifications as read",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()

        // For virtual notifications (chama activities, meetings, etc.), we'll just return success
        // since they don't need persistent read status tracking for now
        totalMarked := rowsAffected

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": fmt.Sprintf("All notifications marked as read (updated %d system notifications)", totalMarked),
        })</span>
}

// DeleteNotification deletes a notification
func DeleteNotification(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        notificationID := c.Param("id")

        fmt.Printf("🗑️ DELETE NOTIFICATION: userID=%s, notificationID=%s\n", userID, notificationID)

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // First, check if this notification exists in the database
        <span class="cov0" title="0">var count int
        checkQuery := "SELECT COUNT(*) FROM notifications WHERE id = ? AND user_id = ?"
        err := db.(*sql.DB).QueryRow(checkQuery, notificationID, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ Error checking notification existence: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("🗑️ Notification count in DB: %d\n", count)
        }</span>

        // Handle different notification sources
        <span class="cov0" title="0">if handleSpecialNotificationDelete(db.(*sql.DB), notificationID, userID) </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ Successfully handled as special notification\n")
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "Notification deleted successfully",
                })
                return
        }</span>

        // Delete notification from the notifications table
        <span class="cov0" title="0">query := `
                DELETE FROM notifications
                WHERE id = ? AND user_id = ?
        `

        fmt.Printf("🗑️ Attempting to delete from notifications table with query: %s\n", query)
        fmt.Printf("🗑️ Parameters: notificationID=%s, userID=%s\n", notificationID, userID)

        result, err := db.(*sql.DB).Exec(query, notificationID, userID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ Error deleting notification from database: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to delete notification from database",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        fmt.Printf("🗑️ Database deletion completed - Rows affected: %d\n", rowsAffected)

        if rowsAffected == 0 </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ No rows affected - notification not found in database\n")
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Notification not found in database",
                })
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("🗑️ Notification successfully deleted from database\n")
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Notification deleted successfully",
        })</span>
}

// Helper functions to get different types of notifications

// getSystemNotifications retrieves system notifications from the notifications table
func getSystemNotifications(db *sql.DB, userID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, title, message, type, data, is_read, created_at
                FROM notifications
                WHERE user_id = ?
                ORDER BY created_at DESC
        `

        rows, err := db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notifications []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var notification struct {
                        ID        string         `json:"id"`
                        UserID    string         `json:"userId"`
                        Title     string         `json:"title"`
                        Message   string         `json:"message"`
                        Type      string         `json:"type"`
                        Data      sql.NullString `json:"data"`
                        IsRead    bool           `json:"isRead"`
                        CreatedAt string         `json:"createdAt"`
                }

                err := rows.Scan(
                        &amp;notification.ID,
                        &amp;notification.UserID,
                        &amp;notification.Title,
                        &amp;notification.Message,
                        &amp;notification.Type,
                        &amp;notification.Data,
                        &amp;notification.IsRead,
                        &amp;notification.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">notificationMap := map[string]interface{}{
                        "id":        notification.ID,
                        "userId":    notification.UserID,
                        "title":     notification.Title,
                        "message":   notification.Message,
                        "type":      notification.Type,
                        "isRead":    notification.IsRead,
                        "createdAt": notification.CreatedAt,
                        "source":    "system",
                }

                if notification.Data.Valid </span><span class="cov0" title="0">{
                        notificationMap["data"] = notification.Data.String
                }</span>

                <span class="cov0" title="0">notifications = append(notifications, notificationMap)</span>
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

// getChamaInvitationNotifications retrieves chama invitation notifications
func getChamaInvitationNotifications(db *sql.DB, userID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Get user's email first
        var userEmail string
        err := db.QueryRow("SELECT email FROM users WHERE id = ?", userID).Scan(&amp;userEmail)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">query := `
                SELECT
                        ci.id, ci.chama_id, ci.email, ci.message, ci.created_at, ci.expires_at,
                        c.name as chama_name, c.description as chama_description,
                        c.contribution_amount, c.contribution_frequency,
                        u.first_name as inviter_first_name, u.last_name as inviter_last_name
                FROM chama_invitations ci
                INNER JOIN chamas c ON ci.chama_id = c.id
                INNER JOIN users u ON ci.inviter_id = u.id
                WHERE ci.email = ? AND ci.status = 'pending' AND ci.expires_at &gt; ?
                ORDER BY ci.created_at DESC
        `

        rows, err := db.Query(query, userEmail, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notifications []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        id, chamaID, email, chamaName, chamaDescription          string
                        contributionFrequency, inviterFirstName, inviterLastName string
                        createdAt, expiresAt                                     string
                        message                                                  *string
                        contributionAmount                                       float64
                )

                err := rows.Scan(
                        &amp;id, &amp;chamaID, &amp;email, &amp;message, &amp;createdAt, &amp;expiresAt,
                        &amp;chamaName, &amp;chamaDescription, &amp;contributionAmount, &amp;contributionFrequency,
                        &amp;inviterFirstName, &amp;inviterLastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">inviterName := fmt.Sprintf("%s %s", inviterFirstName, inviterLastName)
                title := fmt.Sprintf("Chama Invitation: %s", chamaName)
                messageText := fmt.Sprintf("%s invited you to join %s", inviterName, chamaName)
                if message != nil &amp;&amp; *message != "" </span><span class="cov0" title="0">{
                        messageText = *message
                }</span>

                <span class="cov0" title="0">notificationMap := map[string]interface{}{
                        "id":        id,
                        "userId":    userID,
                        "title":     title,
                        "message":   messageText,
                        "type":      "chama_invitation",
                        "isRead":    false, // Invitations are always unread until responded
                        "createdAt": createdAt,
                        "source":    "chama_invitation",
                        "data": map[string]interface{}{
                                "invitationId":          id,
                                "chamaId":               chamaID,
                                "chamaName":             chamaName,
                                "chamaDescription":      chamaDescription,
                                "contributionAmount":    contributionAmount,
                                "contributionFrequency": contributionFrequency,
                                "inviterName":           inviterName,
                                "expiresAt":             expiresAt,
                        },
                }

                notifications = append(notifications, notificationMap)</span>
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

// getMeetingNotifications retrieves meeting-related notifications
func getMeetingNotifications(db *sql.DB, userID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        m.id, m.chama_id, m.title, m.description, m.scheduled_at,
                        m.meeting_type, m.status, m.created_at,
                        c.name as chama_name,
                        u.first_name as creator_first_name, u.last_name as creator_last_name
                FROM meetings m
                INNER JOIN chamas c ON m.chama_id = c.id
                INNER JOIN users u ON m.created_by = u.id
                INNER JOIN chama_members cm ON c.id = cm.chama_id
                WHERE cm.user_id = ? AND cm.is_active = true
                AND (
                        (m.status = 'scheduled' AND m.scheduled_at &gt; datetime('now', '-1 day'))
                        OR (m.status = 'active')
                        OR (m.created_at &gt; datetime('now', '-7 days'))
                )
                ORDER BY m.scheduled_at DESC
        `

        rows, err := db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notifications []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        id, chamaID, title, meetingType, status, createdAt string
                        chamaName, creatorFirstName, creatorLastName       string
                        description, scheduledAt                           *string
                )

                err := rows.Scan(
                        &amp;id, &amp;chamaID, &amp;title, &amp;description, &amp;scheduledAt,
                        &amp;meetingType, &amp;status, &amp;createdAt,
                        &amp;chamaName, &amp;creatorFirstName, &amp;creatorLastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">creatorName := fmt.Sprintf("%s %s", creatorFirstName, creatorLastName)

                var notificationTitle, messageText, notificationType string

                switch status </span>{
                case "scheduled":<span class="cov0" title="0">
                        notificationTitle = fmt.Sprintf("Upcoming Meeting: %s", title)
                        messageText = fmt.Sprintf("Meeting '%s' in %s is scheduled", title, chamaName)
                        notificationType = "meeting_scheduled"</span>
                case "active":<span class="cov0" title="0">
                        notificationTitle = fmt.Sprintf("Meeting Started: %s", title)
                        messageText = fmt.Sprintf("Meeting '%s' in %s has started", title, chamaName)
                        notificationType = "meeting_started"</span>
                default:<span class="cov0" title="0">
                        notificationTitle = fmt.Sprintf("Meeting Created: %s", title)
                        messageText = fmt.Sprintf("%s created a new meeting '%s' in %s", creatorName, title, chamaName)
                        notificationType = "meeting_created"</span>
                }

                <span class="cov0" title="0">notificationMap := map[string]interface{}{
                        "id":        fmt.Sprintf("meeting_%s", id),
                        "userId":    userID,
                        "title":     notificationTitle,
                        "message":   messageText,
                        "type":      notificationType,
                        "isRead":    false,
                        "createdAt": createdAt,
                        "source":    "meeting",
                        "data": map[string]interface{}{
                                "meetingId":    id,
                                "chamaId":      chamaID,
                                "chamaName":    chamaName,
                                "meetingTitle": title,
                                "description":  description,
                                "scheduledAt":  scheduledAt,
                                "meetingType":  meetingType,
                                "status":       status,
                                "creatorName":  creatorName,
                        },
                }

                notifications = append(notifications, notificationMap)</span>
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

// getFinancialNotifications retrieves financial-related notifications
func getFinancialNotifications(db *sql.DB, userID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var notifications []map[string]interface{}

        // 1. Get loan notifications (applications, approvals, disbursements)
        loanNotifications, err := getLoanNotifications(db, userID)
        if err == nil </span><span class="cov0" title="0">{
                notifications = append(notifications, loanNotifications...)
        }</span>

        // 2. Get welfare request notifications
        <span class="cov0" title="0">welfareNotifications, err := getWelfareNotifications(db, userID)
        if err == nil </span><span class="cov0" title="0">{
                notifications = append(notifications, welfareNotifications...)
        }</span>

        // 3. Get transaction notifications (contributions, payments)
        <span class="cov0" title="0">transactionNotifications, err := getTransactionNotifications(db, userID)
        if err == nil </span><span class="cov0" title="0">{
                notifications = append(notifications, transactionNotifications...)
        }</span>

        <span class="cov0" title="0">return notifications, nil</span>
}

// getLoanNotifications retrieves loan-related notifications
func getLoanNotifications(db *sql.DB, userID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        l.id, l.chama_id, l.applicant_id, l.amount, l.purpose,
                        l.status, l.created_at, l.approved_at, l.disbursed_at,
                        c.name as chama_name,
                        u.first_name as applicant_first_name, u.last_name as applicant_last_name
                FROM loans l
                INNER JOIN chamas c ON l.chama_id = c.id
                INNER JOIN users u ON l.applicant_id = u.id
                INNER JOIN chama_members cm ON c.id = cm.chama_id
                WHERE (cm.user_id = ? OR l.applicant_id = ?) AND cm.is_active = true
                AND l.created_at &gt; datetime('now', '-30 days')
                ORDER BY l.created_at DESC
        `

        rows, err := db.Query(query, userID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notifications []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        id, chamaID, applicantID, purpose, status, createdAt string
                        chamaName, applicantFirstName, applicantLastName     string
                        amount                                               float64
                        approvedAt, disbursedAt                              *string
                )

                err := rows.Scan(
                        &amp;id, &amp;chamaID, &amp;applicantID, &amp;amount, &amp;purpose,
                        &amp;status, &amp;createdAt, &amp;approvedAt, &amp;disbursedAt,
                        &amp;chamaName, &amp;applicantFirstName, &amp;applicantLastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">applicantName := fmt.Sprintf("%s %s", applicantFirstName, applicantLastName)

                var notificationTitle, messageText, notificationType string

                if applicantID == userID </span><span class="cov0" title="0">{
                        // Notifications for the loan applicant
                        switch status </span>{
                        case "pending":<span class="cov0" title="0">
                                notificationTitle = "Loan Application Submitted"
                                messageText = fmt.Sprintf("Your loan application for KES %.2f in %s is under review", amount, chamaName)
                                notificationType = "loan_application_submitted"</span>
                        case "approved":<span class="cov0" title="0">
                                notificationTitle = "Loan Application Approved"
                                messageText = fmt.Sprintf("Your loan application for KES %.2f in %s has been approved", amount, chamaName)
                                notificationType = "loan_approved"</span>
                        case "disbursed":<span class="cov0" title="0">
                                notificationTitle = "Loan Disbursed"
                                messageText = fmt.Sprintf("Your loan of KES %.2f from %s has been disbursed", amount, chamaName)
                                notificationType = "loan_disbursed"</span>
                        case "rejected":<span class="cov0" title="0">
                                notificationTitle = "Loan Application Rejected"
                                messageText = fmt.Sprintf("Your loan application for KES %.2f in %s was rejected", amount, chamaName)
                                notificationType = "loan_rejected"</span>
                        default:<span class="cov0" title="0">
                                continue</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Notifications for other chama members
                        switch status </span>{
                        case "pending":<span class="cov0" title="0">
                                notificationTitle = "New Loan Application"
                                messageText = fmt.Sprintf("%s applied for a loan of KES %.2f in %s", applicantName, amount, chamaName)
                                notificationType = "loan_application_new"</span>
                        case "approved":<span class="cov0" title="0">
                                notificationTitle = "Loan Application Approved"
                                messageText = fmt.Sprintf("%s's loan application for KES %.2f in %s was approved", applicantName, amount, chamaName)
                                notificationType = "loan_approved_member"</span>
                        default:<span class="cov0" title="0">
                                continue</span>
                        }
                }

                <span class="cov0" title="0">notificationMap := map[string]interface{}{
                        "id":        fmt.Sprintf("loan_%s", id),
                        "userId":    userID,
                        "title":     notificationTitle,
                        "message":   messageText,
                        "type":      notificationType,
                        "isRead":    false,
                        "createdAt": createdAt,
                        "source":    "loan",
                        "data": map[string]interface{}{
                                "loanId":        id,
                                "chamaId":       chamaID,
                                "chamaName":     chamaName,
                                "applicantName": applicantName,
                                "amount":        amount,
                                "purpose":       purpose,
                                "status":        status,
                                "approvedAt":    approvedAt,
                                "disbursedAt":   disbursedAt,
                        },
                }

                notifications = append(notifications, notificationMap)</span>
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

// getWelfareNotifications retrieves welfare-related notifications
func getWelfareNotifications(db *sql.DB, userID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        wr.id, wr.chama_id, wr.beneficiary_id, wr.amount, wr.reason,
                        wr.status, wr.created_at, wr.approved_at,
                        c.name as chama_name,
                        u.first_name as beneficiary_first_name, u.last_name as beneficiary_last_name,
                        creator.first_name as creator_first_name, creator.last_name as creator_last_name
                FROM welfare_requests wr
                INNER JOIN chamas c ON wr.chama_id = c.id
                INNER JOIN users u ON wr.beneficiary_id = u.id
                INNER JOIN users creator ON wr.created_by = creator.id
                INNER JOIN chama_members cm ON c.id = cm.chama_id
                WHERE (cm.user_id = ? OR wr.beneficiary_id = ? OR wr.created_by = ?) AND cm.is_active = true
                AND wr.created_at &gt; datetime('now', '-30 days')
                ORDER BY wr.created_at DESC
        `

        rows, err := db.Query(query, userID, userID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notifications []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        id, chamaID, beneficiaryID, reason, status, createdAt string
                        chamaName, beneficiaryFirstName, beneficiaryLastName  string
                        creatorFirstName, creatorLastName                     string
                        amount                                                float64
                        approvedAt                                            *string
                )

                err := rows.Scan(
                        &amp;id, &amp;chamaID, &amp;beneficiaryID, &amp;amount, &amp;reason,
                        &amp;status, &amp;createdAt, &amp;approvedAt,
                        &amp;chamaName, &amp;beneficiaryFirstName, &amp;beneficiaryLastName,
                        &amp;creatorFirstName, &amp;creatorLastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">beneficiaryName := fmt.Sprintf("%s %s", beneficiaryFirstName, beneficiaryLastName)
                creatorName := fmt.Sprintf("%s %s", creatorFirstName, creatorLastName)

                var notificationTitle, messageText, notificationType string

                if beneficiaryID == userID </span><span class="cov0" title="0">{
                        // Notifications for the beneficiary
                        switch status </span>{
                        case "pending":<span class="cov0" title="0">
                                notificationTitle = "Welfare Request Created"
                                messageText = fmt.Sprintf("A welfare request for KES %.2f has been created for you in %s", amount, chamaName)
                                notificationType = "welfare_request_created"</span>
                        case "approved":<span class="cov0" title="0">
                                notificationTitle = "Welfare Request Approved"
                                messageText = fmt.Sprintf("Your welfare request for KES %.2f in %s has been approved", amount, chamaName)
                                notificationType = "welfare_approved"</span>
                        case "rejected":<span class="cov0" title="0">
                                notificationTitle = "Welfare Request Rejected"
                                messageText = fmt.Sprintf("Your welfare request for KES %.2f in %s was rejected", amount, chamaName)
                                notificationType = "welfare_rejected"</span>
                        default:<span class="cov0" title="0">
                                continue</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Notifications for other chama members
                        switch status </span>{
                        case "pending":<span class="cov0" title="0">
                                notificationTitle = "New Welfare Request"
                                messageText = fmt.Sprintf("%s created a welfare request for %s (KES %.2f) in %s", creatorName, beneficiaryName, amount, chamaName)
                                notificationType = "welfare_request_new"</span>
                        case "approved":<span class="cov0" title="0">
                                notificationTitle = "Welfare Request Approved"
                                messageText = fmt.Sprintf("Welfare request for %s (KES %.2f) in %s was approved", beneficiaryName, amount, chamaName)
                                notificationType = "welfare_approved_member"</span>
                        default:<span class="cov0" title="0">
                                continue</span>
                        }
                }

                <span class="cov0" title="0">notificationMap := map[string]interface{}{
                        "id":        fmt.Sprintf("welfare_%s", id),
                        "userId":    userID,
                        "title":     notificationTitle,
                        "message":   messageText,
                        "type":      notificationType,
                        "isRead":    false,
                        "createdAt": createdAt,
                        "source":    "welfare",
                        "data": map[string]interface{}{
                                "welfareId":       id,
                                "chamaId":         chamaID,
                                "chamaName":       chamaName,
                                "beneficiaryName": beneficiaryName,
                                "creatorName":     creatorName,
                                "amount":          amount,
                                "reason":          reason,
                                "status":          status,
                                "approvedAt":      approvedAt,
                        },
                }

                notifications = append(notifications, notificationMap)</span>
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

// getTransactionNotifications retrieves transaction-related notifications
func getTransactionNotifications(db *sql.DB, userID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        t.id, t.chama_id, t.user_id, t.amount, t.type, t.description,
                        t.status, t.created_at,
                        c.name as chama_name,
                        u.first_name as user_first_name, u.last_name as user_last_name
                FROM transactions t
                INNER JOIN chamas c ON t.chama_id = c.id
                INNER JOIN users u ON t.user_id = u.id
                INNER JOIN chama_members cm ON c.id = cm.chama_id
                WHERE cm.user_id = ? AND cm.is_active = true
                AND t.created_at &gt; datetime('now', '-7 days')
                AND t.type IN ('contribution', 'welfare_contribution', 'loan_payment')
                ORDER BY t.created_at DESC
        `

        rows, err := db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notifications []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        id, chamaID, transactionUserID, transactionType, status, createdAt string
                        chamaName, userFirstName, userLastName                             string
                        amount                                                             float64
                        description                                                        *string
                )

                err := rows.Scan(
                        &amp;id, &amp;chamaID, &amp;transactionUserID, &amp;amount, &amp;transactionType, &amp;description,
                        &amp;status, &amp;createdAt,
                        &amp;chamaName, &amp;userFirstName, &amp;userLastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">userName := fmt.Sprintf("%s %s", userFirstName, userLastName)

                var notificationTitle, messageText, notificationType string

                if transactionUserID == userID </span><span class="cov0" title="0">{
                        // Notifications for the transaction creator
                        switch transactionType </span>{
                        case "contribution":<span class="cov0" title="0">
                                notificationTitle = "Contribution Recorded"
                                messageText = fmt.Sprintf("Your contribution of KES %.2f to %s has been recorded", amount, chamaName)
                                notificationType = "contribution_recorded"</span>
                        case "welfare_contribution":<span class="cov0" title="0">
                                notificationTitle = "Welfare Contribution Recorded"
                                messageText = fmt.Sprintf("Your welfare contribution of KES %.2f to %s has been recorded", amount, chamaName)
                                notificationType = "welfare_contribution_recorded"</span>
                        case "loan_payment":<span class="cov0" title="0">
                                notificationTitle = "Loan Payment Recorded"
                                messageText = fmt.Sprintf("Your loan payment of KES %.2f to %s has been recorded", amount, chamaName)
                                notificationType = "loan_payment_recorded"</span>
                        default:<span class="cov0" title="0">
                                continue</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Notifications for other chama members (only for significant transactions)
                        if amount &gt;= 1000 </span><span class="cov0" title="0">{ // Only notify for transactions &gt;= 1000 KES
                                switch transactionType </span>{
                                case "contribution":<span class="cov0" title="0">
                                        notificationTitle = "Member Contribution"
                                        messageText = fmt.Sprintf("%s made a contribution of KES %.2f to %s", userName, amount, chamaName)
                                        notificationType = "member_contribution"</span>
                                case "welfare_contribution":<span class="cov0" title="0">
                                        notificationTitle = "Welfare Contribution"
                                        messageText = fmt.Sprintf("%s made a welfare contribution of KES %.2f to %s", userName, amount, chamaName)
                                        notificationType = "member_welfare_contribution"</span>
                                default:<span class="cov0" title="0">
                                        continue</span>
                                }
                        } else<span class="cov0" title="0"> {
                                continue</span>
                        }
                }

                <span class="cov0" title="0">notificationMap := map[string]interface{}{
                        "id":        fmt.Sprintf("transaction_%s", id),
                        "userId":    userID,
                        "title":     notificationTitle,
                        "message":   messageText,
                        "type":      notificationType,
                        "isRead":    false,
                        "createdAt": createdAt,
                        "source":    "transaction",
                        "data": map[string]interface{}{
                                "transactionId":   id,
                                "chamaId":         chamaID,
                                "chamaName":       chamaName,
                                "userName":        userName,
                                "amount":          amount,
                                "transactionType": transactionType,
                                "description":     description,
                                "status":          status,
                        },
                }

                notifications = append(notifications, notificationMap)</span>
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

// getChamaActivityNotifications retrieves chama activity notifications (member joins, role changes, etc.)
func getChamaActivityNotifications(db *sql.DB, userID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        cm.id, cm.chama_id, cm.user_id, cm.role, cm.joined_at,
                        c.name as chama_name,
                        u.first_name as user_first_name, u.last_name as user_last_name
                FROM chama_members cm
                INNER JOIN chamas c ON cm.chama_id = c.id
                INNER JOIN users u ON cm.user_id = u.id
                INNER JOIN chama_members my_membership ON c.id = my_membership.chama_id
                WHERE my_membership.user_id = ? AND my_membership.is_active = true
                AND cm.user_id != ? -- Don't notify about own activities
                AND cm.joined_at &gt; datetime('now', '-7 days')
                AND cm.is_active = true
                ORDER BY cm.joined_at DESC
        `

        rows, err := db.Query(query, userID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notifications []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        id, chamaID, memberUserID, role, joinedAt string
                        chamaName, userFirstName, userLastName    string
                )

                err := rows.Scan(
                        &amp;id, &amp;chamaID, &amp;memberUserID, &amp;role, &amp;joinedAt,
                        &amp;chamaName, &amp;userFirstName, &amp;userLastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">userName := fmt.Sprintf("%s %s", userFirstName, userLastName)

                notificationTitle := "New Member Joined"
                messageText := fmt.Sprintf("%s joined %s", userName, chamaName)
                if role != "member" </span><span class="cov0" title="0">{
                        messageText = fmt.Sprintf("%s joined %s as %s", userName, chamaName, role)
                }</span>

                <span class="cov0" title="0">notificationMap := map[string]interface{}{
                        "id":        fmt.Sprintf("chama_activity_%s", id),
                        "userId":    userID,
                        "title":     notificationTitle,
                        "message":   messageText,
                        "type":      "member_joined",
                        "isRead":    false,
                        "createdAt": joinedAt,
                        "source":    "chama_activity",
                        "data": map[string]interface{}{
                                "chamaId":    chamaID,
                                "chamaName":  chamaName,
                                "memberName": userName,
                                "memberRole": role,
                                "joinedAt":   joinedAt,
                        },
                }

                notifications = append(notifications, notificationMap)</span>
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

// sortNotificationsByDate sorts notifications by created_at in descending order (most recent first)
func sortNotificationsByDate(notifications []map[string]interface{}) <span class="cov0" title="0">{
        // Simple bubble sort for small datasets
        n := len(notifications)
        for i := 0; i &lt; n-1; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; n-i-1; j++ </span><span class="cov0" title="0">{
                        date1, ok1 := notifications[j]["createdAt"].(string)
                        date2, ok2 := notifications[j+1]["createdAt"].(string)

                        if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                                // Parse dates and compare
                                time1, err1 := time.Parse("2006-01-02 15:04:05", date1)
                                time2, err2 := time.Parse("2006-01-02 15:04:05", date2)

                                if err1 == nil &amp;&amp; err2 == nil &amp;&amp; time1.Before(time2) </span><span class="cov0" title="0">{
                                        // Swap if j is older than j+1
                                        notifications[j], notifications[j+1] = notifications[j+1], notifications[j]
                                }</span>
                        }
                }
        }
}

// handleSpecialNotificationRead handles marking special notification types as read
func handleSpecialNotificationRead(db *sql.DB, notificationID, userID string) bool <span class="cov0" title="0">{
        // Handle prefixed notification IDs from aggregated notifications

        // Check for chama activity notifications
        if strings.HasPrefix(notificationID, "chama_activity_") </span><span class="cov0" title="0">{
                // These are virtual notifications based on chama member activities
                // We don't need to store read status for these, just return success
                return true
        }</span>

        // Check for meeting notifications
        <span class="cov0" title="0">if strings.HasPrefix(notificationID, "meeting_") </span><span class="cov0" title="0">{
                // These are virtual notifications based on meetings
                // We don't need to store read status for these, just return success
                return true
        }</span>

        // Check for loan notifications
        <span class="cov0" title="0">if strings.HasPrefix(notificationID, "loan_") </span><span class="cov0" title="0">{
                // These are virtual notifications based on loans
                // We don't need to store read status for these, just return success
                return true
        }</span>

        // Check for welfare notifications
        <span class="cov0" title="0">if strings.HasPrefix(notificationID, "welfare_") </span><span class="cov0" title="0">{
                // These are virtual notifications based on welfare requests
                // We don't need to store read status for these, just return success
                return true
        }</span>

        // Check for transaction notifications
        <span class="cov0" title="0">if strings.HasPrefix(notificationID, "transaction_") </span><span class="cov0" title="0">{
                // These are virtual notifications based on transactions
                // We don't need to store read status for these, just return success
                return true
        }</span>

        // Check if this is a chama invitation notification
        <span class="cov0" title="0">if len(notificationID) &gt; 0 </span><span class="cov0" title="0">{
                // Chama invitations are handled by accept/reject, so we consider them "read" when accessed
                var count int
                err := db.QueryRow("SELECT COUNT(*) FROM chama_invitations WHERE id = ?", notificationID).Scan(&amp;count)
                if err == nil &amp;&amp; count &gt; 0 </span><span class="cov0" title="0">{
                        // This is a chama invitation, consider it handled
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// handleSpecialNotificationDelete handles deleting special notification types
func handleSpecialNotificationDelete(db *sql.DB, notificationID, userID string) bool <span class="cov0" title="0">{
        fmt.Printf("🗑️ SPECIAL DELETE: Checking notification ID: %s\n", notificationID)

        // Handle prefixed notification IDs from aggregated notifications
        // These are virtual notifications that don't exist in the main notifications table
        // We'll mark them as "deleted" by creating a deletion record or just return success

        // Check for chama activity notifications
        if strings.HasPrefix(notificationID, "chama_activity_") </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ SPECIAL DELETE: Chama activity notification - storing deletion record\n")
                return storeVirtualNotificationDeletion(db, userID, notificationID, "chama_activity")
        }</span>

        // Check for meeting notifications
        <span class="cov0" title="0">if strings.HasPrefix(notificationID, "meeting_") </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ SPECIAL DELETE: Meeting notification - storing deletion record\n")
                return storeVirtualNotificationDeletion(db, userID, notificationID, "meeting")
        }</span>

        // Check for loan notifications
        <span class="cov0" title="0">if strings.HasPrefix(notificationID, "loan_") </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ SPECIAL DELETE: Loan notification - storing deletion record\n")
                return storeVirtualNotificationDeletion(db, userID, notificationID, "loan")
        }</span>

        // Check for welfare notifications
        <span class="cov0" title="0">if strings.HasPrefix(notificationID, "welfare_") </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ SPECIAL DELETE: Welfare notification - storing deletion record\n")
                return storeVirtualNotificationDeletion(db, userID, notificationID, "welfare")
        }</span>

        // Check for transaction notifications
        <span class="cov0" title="0">if strings.HasPrefix(notificationID, "transaction_") </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ SPECIAL DELETE: Transaction notification - storing deletion record\n")
                return storeVirtualNotificationDeletion(db, userID, notificationID, "transaction")
        }</span>

        // Check for support request notifications
        <span class="cov0" title="0">if strings.HasPrefix(notificationID, "support_update_") </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ SPECIAL DELETE: Support request notification - storing deletion record\n")
                return storeVirtualNotificationDeletion(db, userID, notificationID, "support_update")
        }</span>

        // Check for new support request notifications (for admins)
        <span class="cov0" title="0">if strings.HasPrefix(notificationID, "support_new_") </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ SPECIAL DELETE: New support request notification - storing deletion record\n")
                return storeVirtualNotificationDeletion(db, userID, notificationID, "support_new")
        }</span>

        // Check for timestamp-based notification IDs (format: YYYYMMDDHHMMSS-XXXXX)
        // These are often generated notifications that might not be in the main notifications table
        <span class="cov0" title="0">if matched, _ := regexp.MatchString(`^\d{14}-[a-zA-Z0-9]+$`, notificationID); matched </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ SPECIAL DELETE: Timestamp-based notification - storing deletion record\n")
                return storeVirtualNotificationDeletion(db, userID, notificationID, "timestamp_based")
        }</span>

        // Check if this is a chama invitation notification
        <span class="cov0" title="0">if len(notificationID) &gt; 0 </span><span class="cov0" title="0">{
                // For chama invitations, try to delete from chama_invitations table
                var count int
                err := db.QueryRow("SELECT COUNT(*) FROM chama_invitations WHERE id = ?", notificationID).Scan(&amp;count)
                if err == nil &amp;&amp; count &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("🗑️ SPECIAL DELETE: Chama invitation found - attempting to delete\n")

                        // Actually delete the chama invitation
                        deleteQuery := "DELETE FROM chama_invitations WHERE id = ? AND invited_email = (SELECT email FROM users WHERE id = ?)"
                        result, err := db.Exec(deleteQuery, notificationID, userID)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("🗑️ SPECIAL DELETE: Failed to delete chama invitation: %v\n", err)
                                return false
                        }</span>

                        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
                        fmt.Printf("🗑️ SPECIAL DELETE: Chama invitation deleted, rows affected: %d\n", rowsAffected)
                        return rowsAffected &gt; 0</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("🗑️ SPECIAL DELETE: Not a special notification\n")
        return false</span>
}

// storeVirtualNotificationDeletion stores a record that a virtual notification was deleted
func storeVirtualNotificationDeletion(db *sql.DB, userID, notificationID, notificationType string) bool <span class="cov0" title="0">{
        // Create a table to track deleted virtual notifications if it doesn't exist
        createTableQuery := `
                CREATE TABLE IF NOT EXISTS deleted_virtual_notifications (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id TEXT NOT NULL,
                        notification_id TEXT NOT NULL,
                        notification_type TEXT NOT NULL,
                        deleted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(user_id, notification_id)
                )
        `

        _, err := db.Exec(createTableQuery)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ Failed to create deleted_virtual_notifications table: %v\n", err)
                // Even if table creation fails, we can still return success for virtual notifications
                return true
        }</span>

        // Insert deletion record
        <span class="cov0" title="0">insertQuery := `
                INSERT OR REPLACE INTO deleted_virtual_notifications
                (user_id, notification_id, notification_type)
                VALUES (?, ?, ?)
        `

        _, err = db.Exec(insertQuery, userID, notificationID, notificationType)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ Failed to store virtual notification deletion: %v\n", err)
                // Even if storage fails, we can still return success for virtual notifications
                return true
        }</span>

        <span class="cov0" title="0">fmt.Printf("🗑️ Virtual notification deletion stored successfully\n")
        return true</span>
}

// getDeletedVirtualNotificationIDs retrieves the IDs of deleted virtual notifications for a user
func getDeletedVirtualNotificationIDs(db *sql.DB, userID string) map[string]bool <span class="cov0" title="0">{
        deletedIDs := make(map[string]bool)

        // Create the table if it doesn't exist
        createTableQuery := `
                CREATE TABLE IF NOT EXISTS deleted_virtual_notifications (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id TEXT NOT NULL,
                        notification_id TEXT NOT NULL,
                        notification_type TEXT NOT NULL,
                        deleted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(user_id, notification_id)
                )
        `

        _, err := db.Exec(createTableQuery)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ Failed to create deleted_virtual_notifications table: %v\n", err)
                return deletedIDs
        }</span>

        <span class="cov0" title="0">query := `
                SELECT notification_id
                FROM deleted_virtual_notifications
                WHERE user_id = ?
        `

        rows, err := db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("🗑️ Failed to get deleted virtual notifications: %v\n", err)
                return deletedIDs
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var notificationID string
                if err := rows.Scan(&amp;notificationID); err == nil </span><span class="cov0" title="0">{
                        deletedIDs[notificationID] = true
                }</span>
        }

        <span class="cov0" title="0">return deletedIDs</span>
}

// getSupportRequestNotifications retrieves support request related notifications
func getSupportRequestNotifications(db *sql.DB, userID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var notifications []map[string]interface{}

        // Get user role to determine what notifications to show
        var userRole string
        err := db.QueryRow("SELECT role FROM users WHERE id = ?", userID).Scan(&amp;userRole)
        if err != nil </span><span class="cov0" title="0">{
                return notifications, err
        }</span>

        <span class="cov0" title="0">if userRole == "admin" </span><span class="cov0" title="0">{
                // Admins get notifications about new support requests
                query := `
                        SELECT
                                sr.id, sr.user_id, sr.category, sr.subject, sr.priority, sr.created_at,
                                u.first_name, u.last_name, u.email
                        FROM support_requests sr
                        LEFT JOIN users u ON sr.user_id = u.id
                        WHERE sr.created_at &gt;= datetime('now', '-7 days')
                        AND sr.status = 'open'
                        ORDER BY sr.created_at DESC
                `

                rows, err := db.Query(query)
                if err != nil </span><span class="cov0" title="0">{
                        return notifications, err
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                for rows.Next() </span><span class="cov0" title="0">{
                        var requestID, requestUserID, category, subject, priority, createdAt string
                        var firstName, lastName, email *string

                        err := rows.Scan(&amp;requestID, &amp;requestUserID, &amp;category, &amp;subject, &amp;priority, &amp;createdAt, &amp;firstName, &amp;lastName, &amp;email)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Create virtual notification ID
                        <span class="cov0" title="0">notificationID := fmt.Sprintf("support_new_%s", requestID)

                        userName := "Unknown User"
                        if firstName != nil &amp;&amp; lastName != nil </span><span class="cov0" title="0">{
                                userName = fmt.Sprintf("%s %s", *firstName, *lastName)
                        }</span> else<span class="cov0" title="0"> if email != nil </span><span class="cov0" title="0">{
                                userName = *email
                        }</span>

                        <span class="cov0" title="0">notification := map[string]interface{}{
                                "id":         notificationID,
                                "type":       "new_support_request",
                                "title":      "New Support Request",
                                "message":    fmt.Sprintf("New %s support request from %s: %s", category, userName, subject),
                                "data":       fmt.Sprintf(`{"supportRequestId": "%s", "category": "%s", "priority": "%s"}`, requestID, category, priority),
                                "is_read":    false,
                                "created_at": createdAt,
                                "user_id":    userID,
                                "is_virtual": true,
                        }

                        notifications = append(notifications, notification)</span>
                }
        } else<span class="cov0" title="0"> {
                // Regular users get notifications about updates to their support requests
                query := `
                        SELECT
                                sr.id, sr.category, sr.subject, sr.description, sr.status, sr.priority,
                                sr.updated_at, sr.admin_notes, sr.created_at
                        FROM support_requests sr
                        WHERE sr.user_id = ?
                        AND sr.updated_at &gt;= datetime('now', '-30 days')
                        AND sr.status != 'open'
                        ORDER BY sr.updated_at DESC
                `

                rows, err := db.Query(query, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return notifications, err
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                for rows.Next() </span><span class="cov0" title="0">{
                        var requestID, category, subject, description, status, priority, updatedAt, createdAt string
                        var adminNotes *string

                        err := rows.Scan(&amp;requestID, &amp;category, &amp;subject, &amp;description, &amp;status, &amp;priority, &amp;updatedAt, &amp;adminNotes, &amp;createdAt)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Create virtual notification ID
                        <span class="cov0" title="0">notificationID := fmt.Sprintf("support_update_%s_%s", requestID, status)

                        // Create detailed status message
                        statusMessage := getStatusDisplayText(status)

                        // Create comprehensive message with status and details
                        message := fmt.Sprintf("Your %s support request has been %s", category, statusMessage)

                        // Add subject for context
                        if subject != "" </span><span class="cov0" title="0">{
                                message += fmt.Sprintf("\n\nSubject: %s", subject)
                        }</span>

                        // Add current status
                        <span class="cov0" title="0">message += fmt.Sprintf("\nStatus: %s", strings.ToUpper(status))

                        // Add admin notes if available
                        if adminNotes != nil &amp;&amp; *adminNotes != "" &amp;&amp; *adminNotes != "Status updated to "+status+" via quick action" </span><span class="cov0" title="0">{
                                message += fmt.Sprintf("\n\nAdmin Response: %s", *adminNotes)
                        }</span>

                        // Add priority if high or urgent
                        <span class="cov0" title="0">if priority == "high" || priority == "urgent" </span><span class="cov0" title="0">{
                                message += fmt.Sprintf("\nPriority: %s", strings.ToUpper(priority))
                        }</span>

                        <span class="cov0" title="0">notification := map[string]interface{}{
                                "id":         notificationID,
                                "type":       "support_update",
                                "title":      fmt.Sprintf("Support Request %s", strings.Title(statusMessage)),
                                "message":    message,
                                "data":       fmt.Sprintf(`{"supportRequestId": "%s", "status": "%s", "category": "%s", "priority": "%s", "subject": "%s"}`, requestID, status, category, priority, subject),
                                "is_read":    false,
                                "created_at": updatedAt,
                                "user_id":    userID,
                                "is_virtual": true,
                        }

                        notifications = append(notifications, notification)</span>
                }
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

// getStatusDisplayText converts status to user-friendly text
func getStatusDisplayText(status string) string <span class="cov0" title="0">{
        switch status </span>{
        case "in_progress":<span class="cov0" title="0">
                return "being reviewed"</span>
        case "resolved":<span class="cov0" title="0">
                return "resolved"</span>
        case "closed":<span class="cov0" title="0">
                return "closed"</span>
        case "rejected":<span class="cov0" title="0">
                return "declined"</span>
        default:<span class="cov0" title="0">
                return "updated"</span>
        }
}

// filterDeletedNotifications filters out notifications that have been deleted
func filterDeletedNotifications(notifications []map[string]interface{}, deletedIDs map[string]bool) []map[string]interface{} <span class="cov0" title="0">{
        filtered := []map[string]interface{}{}

        for _, notification := range notifications </span><span class="cov0" title="0">{
                if id, ok := notification["id"].(string); ok </span><span class="cov0" title="0">{
                        if !deletedIDs[id] </span><span class="cov0" title="0">{
                                filtered = append(filtered, notification)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // If ID is not a string or doesn't exist, include the notification
                        filtered = append(filtered, notification)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

// AcceptChamaInvitation handles accepting a chama invitation
func AcceptChamaInvitation(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">invitationID := c.Param("id")
        if invitationID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invitation ID is required",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get user's email
        <span class="cov0" title="0">var userEmail string
        err := db.(*sql.DB).QueryRow("SELECT email FROM users WHERE id = ?", userID).Scan(&amp;userEmail)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get user email",
                })
                return
        }</span>

        // Verify invitation exists and belongs to user
        <span class="cov0" title="0">var invitation struct {
                ID        string `json:"id"`
                ChamaID   string `json:"chamaId"`
                Email     string `json:"email"`
                Status    string `json:"status"`
                ExpiresAt string `json:"expiresAt"`
        }

        query := `
                SELECT id, chama_id, email, status, expires_at
                FROM chama_invitations
                WHERE id = ? AND email = ? AND status = 'pending'
        `

        err = db.(*sql.DB).QueryRow(query, invitationID, userEmail).Scan(
                &amp;invitation.ID, &amp;invitation.ChamaID, &amp;invitation.Email,
                &amp;invitation.Status, &amp;invitation.ExpiresAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Invitation not found or already processed",
                })
                return
        }</span>

        // Check if invitation has expired
        <span class="cov0" title="0">expiresAt, err := time.Parse("2006-01-02 15:04:05", invitation.ExpiresAt)
        if err != nil || time.Now().After(expiresAt) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invitation has expired",
                })
                return
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := db.(*sql.DB).Begin()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to start transaction",
                })
                return
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Update invitation status
        _, err = tx.Exec("UPDATE chama_invitations SET status = 'accepted', responded_at = ? WHERE id = ?",
                time.Now(), invitationID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update invitation",
                })
                return
        }</span>

        // Add user to chama
        <span class="cov0" title="0">_, err = tx.Exec(`
                INSERT INTO chama_members (id, chama_id, user_id, role, joined_at, is_active)
                VALUES (?, ?, ?, 'member', ?, true)
        `, fmt.Sprintf("cm_%d", time.Now().UnixNano()), invitation.ChamaID, userID, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to add user to chama",
                })
                return
        }</span>

        // Update chama member count
        <span class="cov0" title="0">_, err = tx.Exec("UPDATE chamas SET current_members = current_members + 1, updated_at = ? WHERE id = ?",
                time.Now(), invitation.ChamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update chama member count",
                })
                return
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to commit transaction",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Invitation accepted successfully",
        })</span>
}

// RejectChamaInvitation handles rejecting a chama invitation
func RejectChamaInvitation(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">invitationID := c.Param("id")
        if invitationID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invitation ID is required",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get user's email
        <span class="cov0" title="0">var userEmail string
        err := db.(*sql.DB).QueryRow("SELECT email FROM users WHERE id = ?", userID).Scan(&amp;userEmail)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get user email",
                })
                return
        }</span>

        // Update invitation status
        <span class="cov0" title="0">result, err := db.(*sql.DB).Exec(`
                UPDATE chama_invitations
                SET status = 'rejected', responded_at = ?
                WHERE id = ? AND email = ? AND status = 'pending'
        `, time.Now(), invitationID, userEmail)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to reject invitation",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Invitation not found or already processed",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Invitation rejected successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "log"
        "net/http"
        "strconv"
        "strings"
        "time"
        "vaultke-backend/internal/config"
        "vaultke-backend/internal/models"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

func GetOrder(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get order ID from URL parameter
        <span class="cov0" title="0">orderID := c.Param("id")
        if orderID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Order ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Get order by ID
        order, err := marketplaceService.GetOrderByID(orderID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "order not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Order not found",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to get order: " + err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    order,
                "message": "Order retrieved successfully",
        })</span>
}

func UpdateOrder(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Update order endpoint - coming soon",
        })
}</span>

func CreateOrder(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var req struct {
                Items           []string `json:"items" binding:"required"`         // Cart item IDs
                PaymentMethod   string   `json:"paymentMethod" binding:"required"` // wallet, mpesa, bank
                DeliveryCounty  string   `json:"deliveryCounty" binding:"required"`
                DeliveryTown    string   `json:"deliveryTown" binding:"required"`
                DeliveryAddress string   `json:"deliveryAddress" binding:"required"`
                DeliveryPhone   string   `json:"deliveryPhone" binding:"required"`
                Notes           string   `json:"notes"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Create order from cart items
        var notes *string
        if req.Notes != "" </span><span class="cov0" title="0">{
                notes = &amp;req.Notes
        }</span>

        <span class="cov0" title="0">order, err := marketplaceService.CreateOrderFromCart(userID.(string), req.Items, &amp;models.OrderCreation{
                PaymentMethod:   req.PaymentMethod,
                DeliveryCounty:  req.DeliveryCounty,
                DeliveryTown:    req.DeliveryTown,
                DeliveryAddress: req.DeliveryAddress,
                DeliveryPhone:   req.DeliveryPhone,
                Notes:           notes,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Failed to create order: " + err.Error(),
                })
                return
        }</span>

        // If payment method is M-Pesa, initiate STK push
        <span class="cov0" title="0">if req.PaymentMethod == "mpesa" </span><span class="cov0" title="0">{
                // Get configuration
                cfg, exists := c.Get("config")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Configuration not available",
                        })
                        return
                }</span>

                // Create M-Pesa service
                <span class="cov0" title="0">mpesaService := services.NewMpesaService(db.(*sql.DB), cfg.(*config.Config))

                // Prepare M-Pesa transaction request
                mpesaReq := &amp;models.MpesaTransaction{
                        PhoneNumber:      req.DeliveryPhone,
                        Amount:           order.TotalAmount,
                        AccountReference: fmt.Sprintf("ORDER_%s", order.ID[:8]),
                        TransactionDesc:  fmt.Sprintf("Payment for Order %s", order.ID[:8]),
                }

                // Validate and format phone number
                phoneNumber := strings.TrimSpace(mpesaReq.PhoneNumber)
                if strings.HasPrefix(phoneNumber, "0") </span><span class="cov0" title="0">{
                        phoneNumber = "254" + phoneNumber[1:]
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(phoneNumber, "+254") </span><span class="cov0" title="0">{
                        phoneNumber = phoneNumber[1:]
                }</span> else<span class="cov0" title="0"> if !strings.HasPrefix(phoneNumber, "254") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "Invalid phone number format for M-Pesa payment",
                        })
                        return
                }</span>
                <span class="cov0" title="0">mpesaReq.PhoneNumber = phoneNumber

                // Generate reference for the payment
                reference := fmt.Sprintf("ORDER_%s_%d", order.ID[:8], time.Now().UnixNano())

                // Create pending M-Pesa transaction record
                transactionID, err := createPendingMpesaTransaction(db.(*sql.DB), mpesaReq, userID.(string), reference)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to create pending M-Pesa transaction: %v", err)
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to create payment transaction",
                        })
                        return
                }</span>

                // Initiate STK push
                <span class="cov0" title="0">stkResponse, err := mpesaService.InitiateSTKPush(mpesaReq)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("STK Push failed for order %s: %v", order.ID, err)

                        // Mark transaction as failed
                        _, updateErr := db.(*sql.DB).Exec(`
                                UPDATE transactions
                                SET status = 'failed',
                                    description = CONCAT(description, ' - STK Push failed'),
                                    updated_at = CURRENT_TIMESTAMP
                                WHERE id = ?
                        `, transactionID)

                        if updateErr != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to update transaction status: %v", updateErr)
                        }</span>

                        <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Order created but M-Pesa payment failed to initiate",
                                "data": gin.H{
                                        "orderId":       order.ID,
                                        "transactionId": transactionID,
                                        "status":        "payment_failed",
                                },
                        })
                        return</span>
                }

                // Update transaction with checkout request ID
                <span class="cov0" title="0">updateTransactionReference(db.(*sql.DB), transactionID, stkResponse.CheckoutRequestID)

                // Return success response with payment details
                c.JSON(http.StatusCreated, gin.H{
                        "success": true,
                        "message": "Order created and M-Pesa payment initiated successfully",
                        "data": gin.H{
                                "order":             order,
                                "transactionId":     transactionID,
                                "checkoutRequestId": stkResponse.CheckoutRequestID,
                                "paymentStatus":     "pending",
                                "message":           "Please check your phone for M-Pesa payment prompt",
                        },
                })</span>
        } else<span class="cov0" title="0"> {
                // Return success response for non-M-Pesa payments
                c.JSON(http.StatusCreated, gin.H{
                        "success": true,
                        "message": "Order created successfully",
                        "data":    order,
                })
        }</span>
}

func GetOrders(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get query parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "20")
        offsetStr := c.DefaultQuery("offset", "0")
        status := c.Query("status")
        role := c.DefaultQuery("role", "buyer") // buyer or seller

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Build filters
        filters := make(map[string]interface{})
        if status != "" </span><span class="cov0" title="0">{
                filters["status"] = status
        }</span>
        <span class="cov0" title="0">filters["role"] = role

        // Get orders
        orders, err := marketplaceService.GetOrders(userID.(string), filters, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get orders: " + err.Error(),
                })
                return
        }</span>

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    orders,
                "meta": map[string]interface{}{
                        "limit":  limit,
                        "offset": offset,
                        "count":  len(orders),
                        "role":   role,
                },
        })</span>
}

// UpdateOrderStatus updates the status of an order
func UpdateOrderStatus(c *gin.Context) <span class="cov0" title="0">{
        orderID := c.Param("id")
        if orderID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Order ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Status string `json:"status" binding:"required"`
                Notes  string `json:"notes"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Update order status
        <span class="cov0" title="0">query := `
                UPDATE orders
                SET status = ?, notes = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ? AND seller_id = ?
        `
        result, err := db.(*sql.DB).Exec(query, req.Status, req.Notes, orderID, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update order status: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update order status",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil || rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Order not found or you don't have permission to update it",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Order status updated successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package api

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
)

func JoinChama(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Join chama endpoint - coming soon",
        })
}</span>

func GetChamaTransactions(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Get chama transactions endpoint - coming soon",
        })
}</span>

// Missing API functions for test compatibility

func CreateNotification(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Create notification endpoint - coming soon",
        })
}</span>

func GetReminders(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Get reminders endpoint - coming soon",
                "data":    []interface{}{},
        })
}</span>

func CreateReminder(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Create reminder endpoint - coming soon",
        })
}</span>

func GetLoans(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Get loans endpoint - coming soon",
                "data":    []interface{}{},
        })
}</span>

func CreateLoan(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Create loan endpoint - coming soon",
        })
}</span>

func GetLoan(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    gin.H{"id": c.Param("id"), "status": "pending"},
                "message": "Get loan endpoint - coming soon",
        })
}</span>

func UpdateLoan(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Update loan endpoint - coming soon",
        })
}</span>

func DeleteLoan(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delete loan endpoint - coming soon",
        })
}</span>

// DisburseLoan is implemented in loan_handlers.go

func RepayLoan(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Repay loan endpoint - coming soon",
        })
}</span>

func GetLoanRepayments(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    []interface{}{},
                "message": "Get loan repayments endpoint - coming soon",
        })
}</span>

func GetLoanGuarantors(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    []interface{}{},
                "message": "Get loan guarantors endpoint - coming soon",
        })
}</span>

func AddGuarantor(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Add guarantor endpoint - coming soon",
        })
}</span>

func RemoveGuarantor(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Remove guarantor endpoint - coming soon",
        })
}</span>

func ApproveGuarantor(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Approve guarantor endpoint - coming soon",
        })
}</span>

func RejectGuarantor(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Reject guarantor endpoint - coming soon",
        })
}</span>

func GetLoanStatistics(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    gin.H{"totalLoans": 0, "activeLoans": 0, "defaultedLoans": 0},
                "message": "Get loan statistics endpoint - coming soon",
        })
}</span>

// Marketplace API handlers are implemented in market_handlers.go

func GetCategories(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    []interface{}{},
                "message": "Get categories endpoint - coming soon",
        })
}</span>

func SearchProducts(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    []interface{}{},
                "message": "Search products endpoint - coming soon",
        })
}</span>

// Missing cart handlers
func UpdateCartItem(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Update cart item endpoint - coming soon",
        })
}</span>

func ClearCart(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Clear cart endpoint - coming soon",
        })
}</span>

// Missing order handler
func CancelOrder(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Cancel order endpoint - coming soon",
        })
}</span>

// sanitizeInput removes dangerous characters from user input
func sanitizeInput(input string) string <span class="cov8" title="1">{
        // Remove null bytes and control characters
        result := ""
        for _, char := range input </span><span class="cov8" title="1">{
                if char &gt;= 32 &amp;&amp; char != 127 </span><span class="cov8" title="1">{ // Keep printable characters except DEL
                        result += string(char)
                }</span>
        }

        // Remove dangerous patterns
        <span class="cov8" title="1">dangerous := []string{
                "&lt;script", "&lt;/script", "javascript:", "vbscript:", "onload=", "onerror=",
                "onclick=", "onmouseover=", "onfocus=", "onblur=", "onchange=", "onsubmit=",
                "&lt;iframe", "&lt;object", "&lt;embed", "&lt;link", "&lt;meta", "data:text/html",
                "eval(", "expression(", "url(javascript:", "&amp;#", "&amp;#x", "&lt;svg", "&lt;img",
                "union", "select", "insert", "update", "delete", "drop", "create", "alter",
                "truncate", "exec", "execute", "declare", "cast", "convert", "grant", "revoke",
                "'", "\"", ";", "--", "/*", "*/",
        }

        for _, pattern := range dangerous </span><span class="cov8" title="1">{
                result = strings.ReplaceAll(strings.ToLower(result), pattern, "")
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "strconv"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// PollsHandlers handles poll-related HTTP requests
type PollsHandlers struct {
        pollsService *services.PollsService
}

// NewPollsHandlers creates a new polls handlers instance
func NewPollsHandlers(db *sql.DB) *PollsHandlers <span class="cov0" title="0">{
        return &amp;PollsHandlers{
                pollsService: services.NewPollsService(db),
        }
}</span>

// CreatePoll creates a new poll
func (h *PollsHandlers) CreatePoll(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.PollResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.PollResponse{
                        Success: false,
                        Error:   "Chama ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreatePollRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.PollResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">poll, err := h.pollsService.CreatePoll(chamaID, userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.PollResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, models.PollResponse{
                Success: true,
                Data:    poll,
                Message: "Poll created successfully",
        })</span>
}

// GetChamaPolls retrieves polls for a chama
func (h *PollsHandlers) GetChamaPolls(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.PollsListResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.PollsListResponse{
                        Success: false,
                        Error:   "Chama ID is required",
                })
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">polls, err := h.pollsService.GetChamaPolls(chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.PollsListResponse{
                        Success: false,
                        Error:   "Failed to retrieve polls",
                })
                return
        }</span>

        // Convert to basic polls for list response
        <span class="cov0" title="0">basicPolls := make([]models.Poll, len(polls))
        for i, poll := range polls </span><span class="cov0" title="0">{
                basicPolls[i] = poll.Poll
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.PollsListResponse{
                Success: true,
                Data:    basicPolls,
                Count:   len(basicPolls),
        })</span>
}

// GetPollDetails retrieves detailed information about a poll
func (h *PollsHandlers) GetPollDetails(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        pollID := c.Param("pollId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.PollResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" || pollID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.PollResponse{
                        Success: false,
                        Error:   "Chama ID and Poll ID are required",
                })
                return
        }</span>

        <span class="cov0" title="0">pollDetails, err := h.pollsService.GetPollDetails(pollID, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "poll not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, models.PollResponse{
                                Success: false,
                                Error:   "Poll not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.PollResponse{
                        Success: false,
                        Error:   "Failed to retrieve poll details",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.PollResponse{
                Success: true,
                Data:    pollDetails,
        })</span>
}

// CastVote casts a vote in a poll
func (h *PollsHandlers) CastVote(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        pollID := c.Param("pollId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.VoteResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" || pollID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.VoteResponse{
                        Success: false,
                        Error:   "Chama ID and Poll ID are required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CastVoteRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.VoteResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">err := h.pollsService.CastVote(pollID, userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.VoteResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.VoteResponse{
                Success: true,
                Message: "Vote cast successfully",
        })</span>
}

// CreateRoleEscalationPoll creates a poll for role escalation
func (h *PollsHandlers) CreateRoleEscalationPoll(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.PollResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.PollResponse{
                        Success: false,
                        Error:   "Chama ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateRoleEscalationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.PollResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">escalationReq, err := h.pollsService.CreateRoleEscalationPoll(chamaID, userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.PollResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, models.PollResponse{
                Success: true,
                Data:    escalationReq,
                Message: "Role escalation poll created successfully",
        })</span>
}

// GetActivePolls retrieves active polls for a chama
func (h *PollsHandlers) GetActivePolls(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.PollsListResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.PollsListResponse{
                        Success: false,
                        Error:   "Chama ID is required",
                })
                return
        }</span>

        // Get all polls and filter active ones
        <span class="cov0" title="0">polls, err := h.pollsService.GetChamaPolls(chamaID, 100, 0)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.PollsListResponse{
                        Success: false,
                        Error:   "Failed to retrieve polls",
                })
                return
        }</span>

        // Filter active polls
        <span class="cov0" title="0">var activePolls []models.Poll
        for _, poll := range polls </span><span class="cov0" title="0">{
                if poll.Poll.Status == models.PollStatusActive </span><span class="cov0" title="0">{
                        activePolls = append(activePolls, poll.Poll)
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.PollsListResponse{
                Success: true,
                Data:    activePolls,
                Count:   len(activePolls),
        })</span>
}

// GetPollResults retrieves results for completed polls
func (h *PollsHandlers) GetPollResults(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.PollsListResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.PollsListResponse{
                        Success: false,
                        Error:   "Chama ID is required",
                })
                return
        }</span>

        // Get all polls and filter completed ones
        <span class="cov0" title="0">polls, err := h.pollsService.GetChamaPolls(chamaID, 100, 0)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.PollsListResponse{
                        Success: false,
                        Error:   "Failed to retrieve polls",
                })
                return
        }</span>

        // Filter completed polls with results
        <span class="cov0" title="0">var completedPolls []models.Poll
        for _, poll := range polls </span><span class="cov0" title="0">{
                if poll.Status == models.PollStatusCompleted &amp;&amp; poll.Result != nil </span><span class="cov0" title="0">{
                        completedPolls = append(completedPolls, poll.Poll)
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.PollsListResponse{
                Success: true,
                Data:    completedPolls,
                Count:   len(completedPolls),
        })</span>
}

// GetChamaMembers retrieves chama members for role voting
func (h *PollsHandlers) GetChamaMembers(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">members, err := h.pollsService.GetChamaMembers(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve chama members",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    members,
                "count":   len(members),
        })</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package api

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "time"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

func GetReviews(c *gin.Context) <span class="cov0" title="0">{
        productID := c.Param("productId")
        if productID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Product ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Get reviews for product
        reviews, err := marketplaceService.GetProductReviews(productID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get reviews: " + err.Error(),
                })
                return
        }</span>

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    reviews,
        })</span>
}

func CreateReview(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Parse multipart form
        <span class="cov0" title="0">err := c.Request.ParseMultipartForm(10 &lt;&lt; 20) // 10MB max
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Failed to parse form data: " + err.Error(),
                })
                return
        }</span>

        // Get form values
        <span class="cov0" title="0">productID := c.PostForm("productId")
        orderID := c.PostForm("orderId")
        ratingStr := c.PostForm("rating")
        comment := c.PostForm("comment")

        // Validate required fields
        if productID == "" || orderID == "" || ratingStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Product ID, Order ID, and Rating are required",
                })
                return
        }</span>

        // Parse rating
        <span class="cov0" title="0">rating, err := strconv.Atoi(ratingStr)
        if err != nil || rating &lt; 1 || rating &gt; 5 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Rating must be between 1 and 5",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Handle image uploads
        <span class="cov0" title="0">var imageURLs []string
        form := c.Request.MultipartForm
        if files, ok := form.File["images"]; ok </span><span class="cov0" title="0">{
                for _, file := range files </span><span class="cov0" title="0">{
                        // Validate file type
                        allowedTypes := map[string]bool{
                                "image/jpeg": true,
                                "image/jpg":  true,
                                "image/png":  true,
                                "image/webp": true,
                        }

                        if !allowedTypes[file.Header.Get("Content-Type")] </span><span class="cov0" title="0">{
                                c.JSON(http.StatusBadRequest, gin.H{
                                        "success": false,
                                        "error":   "Invalid file type. Only JPEG, PNG, and WebP images are allowed",
                                })
                                return
                        }</span>

                        // Validate file size (5MB max per image)
                        <span class="cov0" title="0">if file.Size &gt; 5*1024*1024 </span><span class="cov0" title="0">{
                                c.JSON(http.StatusBadRequest, gin.H{
                                        "success": false,
                                        "error":   "Image too large. Maximum size is 5MB per image",
                                })
                                return
                        }</span>

                        // Create uploads directory
                        <span class="cov0" title="0">uploadDir := "./uploads/reviews"
                        if err := os.MkdirAll(uploadDir, 0755); err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusInternalServerError, gin.H{
                                        "success": false,
                                        "error":   "Failed to create upload directory",
                                })
                                return
                        }</span>

                        // Generate unique filename
                        <span class="cov0" title="0">ext := filepath.Ext(file.Filename)
                        filename := fmt.Sprintf("review_%d_%s%s", time.Now().UnixNano(), userID.(string), ext)
                        filePath := filepath.Join(uploadDir, filename)

                        // Save file
                        if err := c.SaveUploadedFile(file, filePath); err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusInternalServerError, gin.H{
                                        "success": false,
                                        "error":   "Failed to save image",
                                })
                                return
                        }</span>

                        // Add to image URLs (store relative path)
                        <span class="cov0" title="0">imageURLs = append(imageURLs, "/uploads/reviews/"+filename)</span>
                }
        }

        // Convert image URLs to JSON
        <span class="cov0" title="0">var imagesJSON string
        if len(imageURLs) &gt; 0 </span><span class="cov0" title="0">{
                imagesBytes, _ := json.Marshal(imageURLs)
                imagesJSON = string(imagesBytes)
        }</span>

        // Create review
        <span class="cov0" title="0">reviewID := fmt.Sprintf("REV_%d", time.Now().UnixNano())

        insertQuery := `
                INSERT INTO product_reviews (
                        id, reviewer_id, product_id, order_id, rating, comment, images, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `

        _, err = db.(*sql.DB).Exec(insertQuery,
                reviewID, userID.(string), productID, orderID,
                rating, comment, imagesJSON,
        )
        if err != nil </span><span class="cov0" title="0">{
                // Clean up uploaded files on error
                for _, imageURL := range imageURLs </span><span class="cov0" title="0">{
                        os.Remove("." + imageURL)
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create review: " + err.Error(),
                })
                return</span>
        }

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Review created successfully",
                "data": map[string]interface{}{
                        "id":        reviewID,
                        "productId": productID,
                        "orderId":   orderID,
                        "rating":    rating,
                        "comment":   comment,
                        "images":    imageURLs,
                },
        })</span>
}

func GetProductReviewStats(c *gin.Context) <span class="cov0" title="0">{
        productID := c.Param("productId")
        if productID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Product ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get review statistics
        <span class="cov0" title="0">query := `
                SELECT
                        COUNT(*) as total_reviews,
                        AVG(rating) as average_rating,
                        COUNT(CASE WHEN rating = 5 THEN 1 END) as five_star,
                        COUNT(CASE WHEN rating = 4 THEN 1 END) as four_star,
                        COUNT(CASE WHEN rating = 3 THEN 1 END) as three_star,
                        COUNT(CASE WHEN rating = 2 THEN 1 END) as two_star,
                        COUNT(CASE WHEN rating = 1 THEN 1 END) as one_star
                FROM product_reviews
                WHERE product_id = ?
        `

        var stats struct {
                TotalReviews  int     `json:"totalReviews"`
                AverageRating float64 `json:"averageRating"`
                FiveStar      int     `json:"fiveStar"`
                FourStar      int     `json:"fourStar"`
                ThreeStar     int     `json:"threeStar"`
                TwoStar       int     `json:"twoStar"`
                OneStar       int     `json:"oneStar"`
        }

        var averageRating sql.NullFloat64

        err := db.(*sql.DB).QueryRow(query, productID).Scan(
                &amp;stats.TotalReviews, &amp;averageRating,
                &amp;stats.FiveStar, &amp;stats.FourStar, &amp;stats.ThreeStar,
                &amp;stats.TwoStar, &amp;stats.OneStar,
        )
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get review statistics: " + err.Error(),
                })
                return
        }</span>

        // Handle NULL average rating (when no reviews exist)
        <span class="cov0" title="0">if averageRating.Valid </span><span class="cov0" title="0">{
                // Round average rating to 1 decimal place
                stats.AverageRating = float64(int(averageRating.Float64*10)) / 10
        }</span> else<span class="cov0" title="0"> {
                stats.AverageRating = 0.0
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    stats,
        })</span>
}

func GetMyReviews(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get user's reviews with product information
        <span class="cov0" title="0">query := `
                SELECT r.id, r.reviewer_id, r.product_id, r.order_id, r.rating, r.comment, r.images, r.created_at,
                           p.name as product_name, p.price as product_price, p.images as product_images
                FROM product_reviews r
                INNER JOIN products p ON r.product_id = p.id
                WHERE r.reviewer_id = ?
                ORDER BY r.created_at DESC
        `

        rows, err := db.(*sql.DB).Query(query, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to query reviews: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reviews []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var reviewID, reviewerID, productID, orderID, comment string
                var rating int
                var createdAt string
                var reviewImages, productName sql.NullString
                var productPrice float64
                var productImages sql.NullString

                err := rows.Scan(
                        &amp;reviewID, &amp;reviewerID, &amp;productID, &amp;orderID, &amp;rating, &amp;comment, &amp;reviewImages, &amp;createdAt,
                        &amp;productName, &amp;productPrice, &amp;productImages,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse review images
                <span class="cov0" title="0">var reviewImagesList []string
                if reviewImages.Valid &amp;&amp; reviewImages.String != "" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal([]byte(reviewImages.String), &amp;reviewImagesList); err == nil </span>{<span class="cov0" title="0">
                                // Images parsed successfully
                        }</span>
                }

                // Parse product images
                <span class="cov0" title="0">var productImagesList []string
                if productImages.Valid &amp;&amp; productImages.String != "" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal([]byte(productImages.String), &amp;productImagesList); err == nil </span>{<span class="cov0" title="0">
                                // Images parsed successfully
                        }</span>
                }

                <span class="cov0" title="0">review := map[string]interface{}{
                        "id":        reviewID,
                        "productId": productID,
                        "orderId":   orderID,
                        "rating":    rating,
                        "comment":   comment,
                        "images":    reviewImagesList,
                        "createdAt": createdAt,
                        "product": map[string]interface{}{
                                "name":   productName.String,
                                "price":  productPrice,
                                "images": productImagesList,
                        },
                }

                reviews = append(reviews, review)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    reviews,
        })</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package api

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "vaultke-backend/internal/models"

        "github.com/gin-gonic/gin"
)

// ReceiptHandlers handles receipt-related API endpoints
type ReceiptHandlers struct {
        db *sql.DB
}

// NewReceiptHandlers creates a new receipt handlers instance
func NewReceiptHandlers(db *sql.DB) *ReceiptHandlers <span class="cov0" title="0">{
        return &amp;ReceiptHandlers{db: db}
}</span>

// CompanyInfo represents company information for receipts
type CompanyInfo struct {
        Name    string `json:"name"`
        Address string `json:"address"`
        Phone   string `json:"phone"`
        Email   string `json:"email"`
        Website string `json:"website"`
        Logo    string `json:"logo"`
}

// ReceiptData represents the complete receipt data
type ReceiptData struct {
        ReceiptID   string                 `json:"receiptId"`
        CompanyInfo CompanyInfo            `json:"companyInfo"`
        Transaction models.Transaction     `json:"transaction"`
        UserInfo    map[string]interface{} `json:"userInfo"`
        GeneratedAt time.Time              `json:"generatedAt"`
        Version     string                 `json:"version"`
}

// GetTransactionReceipt generates and returns a transaction receipt
func (h *ReceiptHandlers) GetTransactionReceipt(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">transactionID := c.Param("transactionId")
        if transactionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Transaction ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">format := c.DefaultQuery("format", "json")
        if format != "json" &amp;&amp; format != "html" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Supported formats: json, html",
                })
                return
        }</span>

        // Get transaction details
        <span class="cov0" title="0">transaction, err := h.getTransactionByID(transactionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Transaction not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve transaction",
                })
                return</span>
        }

        // Get user information
        <span class="cov0" title="0">userInfo, err := h.getUserInfo(userID)
        if err != nil </span><span class="cov0" title="0">{
                // Continue without user info if not found
                userInfo = make(map[string]interface{})
        }</span>

        // Generate receipt data
        <span class="cov0" title="0">receiptData := h.generateReceiptData(transaction, userInfo)

        switch format </span>{
        case "json":<span class="cov0" title="0">
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "data":    receiptData,
                })</span>
        case "html":<span class="cov0" title="0">
                html := h.generateReceiptHTML(receiptData)
                c.Header("Content-Type", "text/html")
                c.String(http.StatusOK, html)</span>
        }
}

// DownloadTransactionReceipt generates and serves a downloadable receipt
func (h *ReceiptHandlers) DownloadTransactionReceipt(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">transactionID := c.Param("transactionId")
        if transactionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Transaction ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">format := c.DefaultQuery("format", "json")
        if format != "json" &amp;&amp; format != "html" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Supported formats: json, html",
                })
                return
        }</span>

        // Get transaction details
        <span class="cov0" title="0">transaction, err := h.getTransactionByID(transactionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Transaction not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve transaction",
                })
                return</span>
        }

        // Get user information
        <span class="cov0" title="0">userInfo, err := h.getUserInfo(userID)
        if err != nil </span><span class="cov0" title="0">{
                userInfo = make(map[string]interface{})
        }</span>

        // Generate receipt data
        <span class="cov0" title="0">receiptData := h.generateReceiptData(transaction, userInfo)
        receiptID := fmt.Sprintf("RCP-%s", transaction.ID[:8])
        fileName := fmt.Sprintf("VaultKe_Receipt_%s_%s.%s",
                receiptID,
                time.Now().Format("2006-01-02"),
                format)

        switch format </span>{
        case "json":<span class="cov0" title="0">
                jsonData, _ := json.MarshalIndent(receiptData, "", "  ")
                c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", fileName))
                c.Header("Content-Type", "application/json")
                c.String(http.StatusOK, string(jsonData))</span>
        case "html":<span class="cov0" title="0">
                html := h.generateReceiptHTML(receiptData)
                c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", fileName))
                c.Header("Content-Type", "text/html")
                c.String(http.StatusOK, html)</span>
        }
}

// getTransactionByID retrieves a transaction by ID for a specific user
func (h *ReceiptHandlers) getTransactionByID(transactionID, userID string) (*models.Transaction, error) <span class="cov0" title="0">{
        query := `
                SELECT id, from_wallet_id, to_wallet_id, type, status, amount, currency,
                           description, reference, payment_method, metadata, fees, initiated_by,
                           approved_by, requires_approval, approval_deadline, created_at, updated_at
                FROM transactions 
                WHERE id = ? AND (initiated_by = ? OR approved_by = ?)
        `

        var transaction models.Transaction
        var fromWalletID, toWalletID, approvedBy sql.NullString
        var approvalDeadline sql.NullTime
        var metadataJSON string

        err := h.db.QueryRow(query, transactionID, userID, userID).Scan(
                &amp;transaction.ID,
                &amp;fromWalletID,
                &amp;toWalletID,
                &amp;transaction.Type,
                &amp;transaction.Status,
                &amp;transaction.Amount,
                &amp;transaction.Currency,
                &amp;transaction.Description,
                &amp;transaction.Reference,
                &amp;transaction.PaymentMethod,
                &amp;metadataJSON,
                &amp;transaction.Fees,
                &amp;transaction.InitiatedBy,
                &amp;approvedBy,
                &amp;transaction.RequiresApproval,
                &amp;approvalDeadline,
                &amp;transaction.CreatedAt,
                &amp;transaction.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle nullable fields
        <span class="cov0" title="0">if fromWalletID.Valid </span><span class="cov0" title="0">{
                transaction.FromWalletID = &amp;fromWalletID.String
        }</span>
        <span class="cov0" title="0">if toWalletID.Valid </span><span class="cov0" title="0">{
                transaction.ToWalletID = &amp;toWalletID.String
        }</span>
        <span class="cov0" title="0">if approvedBy.Valid </span><span class="cov0" title="0">{
                transaction.ApprovedBy = &amp;approvedBy.String
        }</span>
        <span class="cov0" title="0">if approvalDeadline.Valid </span><span class="cov0" title="0">{
                transaction.ApprovalDeadline = &amp;approvalDeadline.Time
        }</span>

        // Parse metadata
        <span class="cov0" title="0">if metadataJSON != "" </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(metadataJSON), &amp;transaction.Metadata)
        }</span>

        <span class="cov0" title="0">return &amp;transaction, nil</span>
}

// getUserInfo retrieves user information for the receipt
func (h *ReceiptHandlers) getUserInfo(userID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT first_name, last_name, email, phone, county, town
                FROM users 
                WHERE id = ?
        `

        var firstName, lastName, email, phone, county, town sql.NullString
        err := h.db.QueryRow(query, userID).Scan(
                &amp;firstName, &amp;lastName, &amp;email, &amp;phone, &amp;county, &amp;town,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">userInfo := make(map[string]interface{})
        if firstName.Valid </span><span class="cov0" title="0">{
                userInfo["firstName"] = firstName.String
        }</span>
        <span class="cov0" title="0">if lastName.Valid </span><span class="cov0" title="0">{
                userInfo["lastName"] = lastName.String
        }</span>
        <span class="cov0" title="0">if email.Valid </span><span class="cov0" title="0">{
                userInfo["email"] = email.String
        }</span>
        <span class="cov0" title="0">if phone.Valid </span><span class="cov0" title="0">{
                userInfo["phone"] = phone.String
        }</span>
        <span class="cov0" title="0">if county.Valid </span><span class="cov0" title="0">{
                userInfo["county"] = county.String
        }</span>
        <span class="cov0" title="0">if town.Valid </span><span class="cov0" title="0">{
                userInfo["town"] = town.String
        }</span>

        <span class="cov0" title="0">return userInfo, nil</span>
}

// generateReceiptData creates the complete receipt data structure
func (h *ReceiptHandlers) generateReceiptData(transaction *models.Transaction, userInfo map[string]interface{}) *ReceiptData <span class="cov0" title="0">{
        receiptID := fmt.Sprintf("RCP-%s", transaction.ID[:8])

        companyInfo := CompanyInfo{
                Name:    "VaultKe",
                Address: "Nairobi, Kenya",
                Phone:   "+254 700 000 000",
                Email:   "support@vaultke.co.ke",
                Website: "www.vaultke.co.ke",
                Logo:    "https://vaultke.co.ke/logo.png",
        }

        return &amp;ReceiptData{
                ReceiptID:   receiptID,
                CompanyInfo: companyInfo,
                Transaction: *transaction,
                UserInfo:    userInfo,
                GeneratedAt: time.Now(),
                Version:     "1.0",
        }
}</span>

// generateReceiptHTML creates HTML receipt from receipt data
func (h *ReceiptHandlers) generateReceiptHTML(receiptData *ReceiptData) string <span class="cov0" title="0">{
        formatCurrency := func(amount float64) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("KES %.2f", amount)
        }</span>

        <span class="cov0" title="0">getTransactionTypeLabel := func(txType models.TransactionType) string </span><span class="cov0" title="0">{
                switch txType </span>{
                case models.TransactionTypeDeposit:<span class="cov0" title="0">
                        return "Deposit"</span>
                case models.TransactionTypeWithdrawal:<span class="cov0" title="0">
                        return "Withdrawal"</span>
                case models.TransactionTypeTransfer:<span class="cov0" title="0">
                        return "Transfer"</span>
                case models.TransactionTypeContribution:<span class="cov0" title="0">
                        return "Contribution"</span>
                case models.TransactionTypeLoan:<span class="cov0" title="0">
                        return "Loan"</span>
                case models.TransactionTypeLoanRepayment:<span class="cov0" title="0">
                        return "Loan Repayment"</span>
                case models.TransactionTypePurchase:<span class="cov0" title="0">
                        return "Purchase"</span>
                case models.TransactionTypeRefund:<span class="cov0" title="0">
                        return "Refund"</span>
                case models.TransactionTypeFee:<span class="cov0" title="0">
                        return "Fee"</span>
                default:<span class="cov0" title="0">
                        return "Transaction"</span>
                }
        }

        <span class="cov0" title="0">transactionDate := receiptData.Transaction.CreatedAt.Format("January 2, 2006 at 3:04:05 PM")
        amount := formatCurrency(receiptData.Transaction.Amount)
        fees := formatCurrency(receiptData.Transaction.Fees)
        totalAmount := formatCurrency(receiptData.Transaction.Amount + receiptData.Transaction.Fees)

        html := fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;title&gt;Transaction Receiptppp - %s&lt;/title&gt;
    &lt;style&gt;
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; padding: 20px; }
        .receipt-container { max-width: 600px; margin: 0 auto; background: white; border-radius: 10px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); overflow: hidden; }
        .receipt-header { background: linear-gradient(135deg, #6366F1, #8B5CF6); color: white; padding: 30px; text-align: center; }
        .company-logo { width: 60px; height: 60px; margin: 0 auto 15px; background: white; border-radius: 50%%; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: #6366F1; }
        .company-name { font-size: 28px; font-weight: bold; margin-bottom: 5px; }
        .receipt-title { font-size: 18px; opacity: 0.9; }
        .receipt-body { padding: 30px; }
        .receipt-info { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; }
        .info-item { display: flex; flex-direction: column; }
        .info-label { font-size: 12px; color: #666; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 5px; }
        .info-value { font-size: 14px; font-weight: 600; color: #333; }
        .transaction-details { border: 1px solid #e5e7eb; border-radius: 8px; overflow: hidden; margin-bottom: 30px; }
        .detail-row { display: flex; justify-content: space-between; align-items: center; padding: 15px 20px; border-bottom: 1px solid #e5e7eb; }
        .detail-row:last-child { border-bottom: none; }
        .detail-row.total { background: #f8f9fa; font-weight: bold; font-size: 16px; }
        .detail-label { color: #666; }
        .detail-value { font-weight: 600; color: #333; }
        .status-badge { display: inline-block; padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
        .status-completed { background: #dcfce7; color: #166534; }
        .status-pending { background: #fef3c7; color: #92400e; }
        .status-failed { background: #fee2e2; color: #991b1b; }
        .receipt-footer { background: #f8f9fa; padding: 20px 30px; text-align: center; border-top: 1px solid #e5e7eb; }
        .company-details { font-size: 12px; color: #666; line-height: 1.5; }
        .thank-you { font-size: 14px; color: #333; margin-bottom: 10px; font-weight: 600; }
        @media print { body { background: white; padding: 0; } .receipt-container { box-shadow: none; border-radius: 0; } }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="receipt-container"&gt;
        &lt;div class="receipt-header"&gt;
            &lt;div class="company-logo"&gt;VK&lt;/div&gt;
            &lt;div class="company-name"&gt;%s&lt;/div&gt;
            &lt;div class="receipt-title"&gt;Transaction Receipt&lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="receipt-body"&gt;
            &lt;div class="receipt-info"&gt;
                &lt;div class="info-item"&gt;
                    &lt;div class="info-label"&gt;Receipt ID&lt;/div&gt;
                    &lt;div class="info-value"&gt;%s&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="info-item"&gt;
                    &lt;div class="info-label"&gt;Transaction ID&lt;/div&gt;
                    &lt;div class="info-value"&gt;%s...&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="info-item"&gt;
                    &lt;div class="info-label"&gt;Date &amp; Time&lt;/div&gt;
                    &lt;div class="info-value"&gt;%s&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="info-item"&gt;
                    &lt;div class="info-label"&gt;Status&lt;/div&gt;
                    &lt;div class="info-value"&gt;
                        &lt;span class="status-badge status-%s"&gt;%s&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class="transaction-details"&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="detail-label"&gt;Transaction Type&lt;/span&gt;
                    &lt;span class="detail-value"&gt;%s&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="detail-label"&gt;Description&lt;/span&gt;
                    &lt;span class="detail-value"&gt;%s&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="detail-label"&gt;Amount&lt;/span&gt;
                    &lt;span class="detail-value"&gt;%s&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="detail-label"&gt;Transaction Fees&lt;/span&gt;
                    &lt;span class="detail-value"&gt;%s&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="detail-row total"&gt;
                    &lt;span class="detail-label"&gt;Total Amount&lt;/span&gt;
                    &lt;span class="detail-value"&gt;%s&lt;/span&gt;
                &lt;/div&gt;`,
                receiptData.ReceiptID,
                receiptData.CompanyInfo.Name,
                receiptData.ReceiptID,
                receiptData.Transaction.ID[:16],
                transactionDate,
                receiptData.Transaction.Status,
                receiptData.Transaction.Status,
                getTransactionTypeLabel(receiptData.Transaction.Type),
                func() string </span><span class="cov0" title="0">{
                        if receiptData.Transaction.Description != nil </span><span class="cov0" title="0">{
                                return *receiptData.Transaction.Description
                        }</span>
                        <span class="cov0" title="0">return "N/A"</span>
                }(),
                amount,
                fees,
                totalAmount,
        )

        // Add optional fields
        <span class="cov0" title="0">if receiptData.Transaction.Reference != nil &amp;&amp; *receiptData.Transaction.Reference != "" </span><span class="cov0" title="0">{
                html += fmt.Sprintf(`
                &lt;div class="detail-row"&gt;
                    &lt;span class="detail-label"&gt;Reference&lt;/span&gt;
                    &lt;span class="detail-value"&gt;%s&lt;/span&gt;
                &lt;/div&gt;`, *receiptData.Transaction.Reference)
        }</span>

        <span class="cov0" title="0">if receiptData.Transaction.PaymentMethod != "" </span><span class="cov0" title="0">{
                html += fmt.Sprintf(`
                &lt;div class="detail-row"&gt;
                    &lt;span class="detail-label"&gt;Payment Method&lt;/span&gt;
                    &lt;span class="detail-value"&gt;%s&lt;/span&gt;
                &lt;/div&gt;`, receiptData.Transaction.PaymentMethod)
        }</span>

        // Close the HTML
        <span class="cov0" title="0">html += fmt.Sprintf(`
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="receipt-footer"&gt;
            &lt;div class="thank-you"&gt;Thank you for using %s!&lt;/div&gt;
            &lt;div class="company-details"&gt;
                %s&lt;br&gt;
                Phone: %s | Email: %s&lt;br&gt;
                %s
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`,
                receiptData.CompanyInfo.Name,
                receiptData.CompanyInfo.Address,
                receiptData.CompanyInfo.Phone,
                receiptData.CompanyInfo.Email,
                receiptData.CompanyInfo.Website,
        )

        return html</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "strconv"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// ReminderHandlers handles reminder-related HTTP requests
type ReminderHandlers struct {
        reminderService *services.ReminderService
}

// NewReminderHandlers creates a new reminder handlers instance
func NewReminderHandlers(db *sql.DB) *ReminderHandlers <span class="cov8" title="1">{
        return &amp;ReminderHandlers{
                reminderService: services.NewReminderService(db),
        }
}</span>

// CreateReminder creates a new reminder for the authenticated user
func (h *ReminderHandlers) CreateReminder(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.ReminderResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">var req models.CreateReminderRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, models.ReminderResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">reminder, err := h.reminderService.CreateReminder(userID, &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, models.ReminderResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, models.ReminderResponse{
                Success: true,
                Data:    reminder,
                Message: "Reminder created successfully",
        })</span>
}

// GetUserReminders retrieves all reminders for the authenticated user
func (h *ReminderHandlers) GetUserReminders(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.RemindersListResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        // Parse pagination parameters
        <span class="cov8" title="1">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov8" title="1">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov8" title="1">reminders, err := h.reminderService.GetUserReminders(userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.RemindersListResponse{
                        Success: false,
                        Error:   "Failed to retrieve reminders",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, models.RemindersListResponse{
                Success: true,
                Data:    reminders,
                Count:   len(reminders),
        })</span>
}

// GetReminder retrieves a specific reminder by ID
func (h *ReminderHandlers) GetReminder(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.ReminderResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">reminderID := c.Param("id")
        if reminderID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.ReminderResponse{
                        Success: false,
                        Error:   "Reminder ID is required",
                })
                return
        }</span>

        <span class="cov8" title="1">reminder, err := h.reminderService.GetReminderByID(reminderID, userID)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "reminder not found" </span><span class="cov8" title="1">{
                        c.JSON(http.StatusNotFound, models.ReminderResponse{
                                Success: false,
                                Error:   "Reminder not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.ReminderResponse{
                        Success: false,
                        Error:   "Failed to retrieve reminder",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.ReminderResponse{
                Success: true,
                Data:    reminder,
        })</span>
}

// UpdateReminder updates an existing reminder
func (h *ReminderHandlers) UpdateReminder(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.ReminderResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">reminderID := c.Param("id")
        if reminderID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.ReminderResponse{
                        Success: false,
                        Error:   "Reminder ID is required",
                })
                return
        }</span>

        <span class="cov8" title="1">var req models.UpdateReminderRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.ReminderResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">reminder, err := h.reminderService.UpdateReminder(reminderID, userID, &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "reminder not found" </span><span class="cov8" title="1">{
                        c.JSON(http.StatusNotFound, models.ReminderResponse{
                                Success: false,
                                Error:   "Reminder not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, models.ReminderResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.ReminderResponse{
                Success: true,
                Data:    reminder,
                Message: "Reminder updated successfully",
        })</span>
}

// DeleteReminder deletes a reminder
func (h *ReminderHandlers) DeleteReminder(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.ReminderResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">reminderID := c.Param("id")
        if reminderID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.ReminderResponse{
                        Success: false,
                        Error:   "Reminder ID is required",
                })
                return
        }</span>

        <span class="cov8" title="1">err := h.reminderService.DeleteReminder(reminderID, userID)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "reminder not found" </span><span class="cov8" title="1">{
                        c.JSON(http.StatusNotFound, models.ReminderResponse{
                                Success: false,
                                Error:   "Reminder not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.ReminderResponse{
                        Success: false,
                        Error:   "Failed to delete reminder",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.ReminderResponse{
                Success: true,
                Message: "Reminder deleted successfully",
        })</span>
}

// ToggleReminder toggles the enabled status of a reminder
func (h *ReminderHandlers) ToggleReminder(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.ReminderResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">reminderID := c.Param("id")
        if reminderID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.ReminderResponse{
                        Success: false,
                        Error:   "Reminder ID is required",
                })
                return
        }</span>

        // Get current reminder
        <span class="cov8" title="1">reminder, err := h.reminderService.GetReminderByID(reminderID, userID)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "reminder not found" </span><span class="cov8" title="1">{
                        c.JSON(http.StatusNotFound, models.ReminderResponse{
                                Success: false,
                                Error:   "Reminder not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, models.ReminderResponse{
                        Success: false,
                        Error:   "Failed to retrieve reminder",
                })
                return</span>
        }

        // Toggle the enabled status
        <span class="cov0" title="0">newEnabled := !reminder.IsEnabled
        updateReq := models.UpdateReminderRequest{
                IsEnabled: &amp;newEnabled,
        }

        updatedReminder, err := h.reminderService.UpdateReminder(reminderID, userID, &amp;updateReq)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.ReminderResponse{
                        Success: false,
                        Error:   "Failed to toggle reminder",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.ReminderResponse{
                Success: true,
                Data:    updatedReminder,
                Message: "Reminder toggled successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "golang.org/x/crypto/bcrypt"
)

// LoginSession represents a user login session
type LoginSession struct {
        ID              string    `json:"id" db:"id"`
        UserID          string    `json:"userId" db:"user_id"`
        DeviceType      string    `json:"deviceType" db:"device_type"`
        DeviceName      string    `json:"deviceName" db:"device_name"`
        OperatingSystem string    `json:"operatingSystem" db:"operating_system"`
        Browser         string    `json:"browser" db:"browser"`
        IPAddress       string    `json:"ipAddress" db:"ip_address"`
        Location        string    `json:"location" db:"location"`
        LoginTime       time.Time `json:"loginTime" db:"login_time"`
        LastActivity    time.Time `json:"lastActivity" db:"last_activity"`
        Status          string    `json:"status" db:"status"`
        IsCurrent       bool      `json:"isCurrent" db:"is_current"`
}

// ChangePassword handles password change requests
func ChangePassword(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var requestData struct {
                CurrentPassword string `json:"currentPassword" binding:"required"`
                NewPassword     string `json:"newPassword" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;requestData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get current password hash from database
        <span class="cov0" title="0">var currentPasswordHash string
        err := db.(*sql.DB).QueryRow("SELECT password_hash FROM users WHERE id = ?", userID).Scan(&amp;currentPasswordHash)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get user password: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify current password",
                })
                return
        }</span>

        // Verify current password
        <span class="cov0" title="0">err = bcrypt.CompareHashAndPassword([]byte(currentPasswordHash), []byte(requestData.CurrentPassword))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Current password is incorrect",
                })
                return
        }</span>

        // Hash new password
        <span class="cov0" title="0">newPasswordHash, err := bcrypt.GenerateFromPassword([]byte(requestData.NewPassword), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to hash new password: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to process new password",
                })
                return
        }</span>

        // Update password in database
        <span class="cov0" title="0">updateQuery := `
                UPDATE users
                SET password_hash = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
        `

        _, err = db.(*sql.DB).Exec(updateQuery, string(newPasswordHash), userID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update password: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update password",
                })
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Password changed successfully for user: %s\n", userID)

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Password changed successfully",
        })</span>
}

// GetLoginHistory retrieves user login history
func GetLoginHistory(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, _ := strconv.Atoi(limitStr)
        offset, _ := strconv.Atoi(offsetStr)

        // Create login_sessions table if it doesn't exist
        createTableQuery := `
                CREATE TABLE IF NOT EXISTS login_sessions (
                        id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
                        user_id TEXT NOT NULL,
                        device_type TEXT,
                        device_name TEXT,
                        operating_system TEXT,
                        browser TEXT,
                        ip_address TEXT,
                        location TEXT,
                        login_time DATETIME DEFAULT CURRENT_TIMESTAMP,
                        last_activity DATETIME DEFAULT CURRENT_TIMESTAMP,
                        status TEXT DEFAULT 'active',
                        is_current BOOLEAN DEFAULT FALSE,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )
        `

        _, err := db.(*sql.DB).Exec(createTableQuery)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create login_sessions table: %v\n", err)
        }</span>

        // Get login sessions
        <span class="cov0" title="0">query := `
                SELECT 
                        id, user_id, device_type, device_name, operating_system, 
                        browser, ip_address, location, login_time, last_activity, 
                        status, is_current
                FROM login_sessions 
                WHERE user_id = ? 
                ORDER BY login_time DESC 
                LIMIT ? OFFSET ?
        `

        rows, err := db.(*sql.DB).Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get login history: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve login history",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var sessions []LoginSession
        for rows.Next() </span><span class="cov0" title="0">{
                var session LoginSession
                err := rows.Scan(
                        &amp;session.ID, &amp;session.UserID, &amp;session.DeviceType, &amp;session.DeviceName,
                        &amp;session.OperatingSystem, &amp;session.Browser, &amp;session.IPAddress,
                        &amp;session.Location, &amp;session.LoginTime, &amp;session.LastActivity,
                        &amp;session.Status, &amp;session.IsCurrent,
                )
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to scan login session: %v\n", err)
                        continue</span>
                }
                <span class="cov0" title="0">sessions = append(sessions, session)</span>
        }

        // If no sessions exist, try to create a current session with real device info from headers
        <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                // Extract device info from request headers (sent by frontend)
                deviceType := c.GetHeader("X-Device-Type")
                deviceName := c.GetHeader("X-Device-Name")
                browserName := c.GetHeader("X-Browser-Name")
                osName := c.GetHeader("X-OS-Name")
                timezone := c.GetHeader("X-Timezone")

                // Fallback values if headers are not present
                if deviceType == "" </span><span class="cov0" title="0">{
                        deviceType = "unknown"
                }</span>
                <span class="cov0" title="0">if deviceName == "" </span><span class="cov0" title="0">{
                        deviceName = "Current Device"
                }</span>
                <span class="cov0" title="0">if browserName == "" </span><span class="cov0" title="0">{
                        browserName = "VaultKe App"
                }</span>
                <span class="cov0" title="0">if osName == "" </span><span class="cov0" title="0">{
                        osName = "Unknown OS"
                }</span>

                // Determine location based on IP
                <span class="cov0" title="0">ip := c.ClientIP()
                location := "Unknown"
                if ip == "127.0.0.1" || ip == "::1" </span><span class="cov0" title="0">{
                        location = "Local Development"
                }</span> else<span class="cov0" title="0"> if ip != "" </span><span class="cov0" title="0">{
                        location = fmt.Sprintf("IP: %s", ip)
                }</span>

                // Add timezone info if available
                <span class="cov0" title="0">if timezone != "" &amp;&amp; timezone != "UTC" </span><span class="cov0" title="0">{
                        location = fmt.Sprintf("%s (%s)", location, timezone)
                }</span>

                <span class="cov0" title="0">currentSession := LoginSession{
                        ID:              "current-session",
                        UserID:          userID,
                        DeviceType:      deviceType,
                        DeviceName:      deviceName,
                        OperatingSystem: osName,
                        Browser:         browserName,
                        IPAddress:       ip,
                        Location:        location,
                        LoginTime:       time.Now(),
                        LastActivity:    time.Now(),
                        Status:          "active",
                        IsCurrent:       true,
                }

                // Try to insert this session into the database for future reference
                insertQuery := `
                        INSERT OR REPLACE INTO login_sessions
                        (id, user_id, device_type, device_name, operating_system, browser, ip_address, location, is_current)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, TRUE)
                `
                _, err := db.(*sql.DB).Exec(insertQuery,
                        currentSession.ID, currentSession.UserID, currentSession.DeviceType,
                        currentSession.DeviceName, currentSession.OperatingSystem, currentSession.Browser,
                        currentSession.IPAddress, currentSession.Location)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to insert current session: %v\n", err)
                }</span>

                <span class="cov0" title="0">sessions = append(sessions, currentSession)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    sessions,
                "meta": gin.H{
                        "total":  len(sessions),
                        "limit":  limit,
                        "offset": offset,
                },
        })</span>
}

// LogoutAllDevices logs out user from all other devices
func LogoutAllDevices(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Update all sessions except current to revoked status
        <span class="cov0" title="0">updateQuery := `
                UPDATE login_sessions 
                SET status = 'revoked', last_activity = CURRENT_TIMESTAMP 
                WHERE user_id = ? AND is_current = FALSE
        `

        result, err := db.(*sql.DB).Exec(updateQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to logout all devices: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to logout from all devices",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        fmt.Printf("✅ Logged out from %d devices for user: %s\n", rowsAffected, userID)

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": fmt.Sprintf("Logged out from %d other devices", rowsAffected),
        })</span>
}

// LogoutSpecificDevice logs out user from a specific device
func LogoutSpecificDevice(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">sessionID := c.Param("sessionId")
        if sessionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Session ID is required",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Update specific session to revoked status (only if it belongs to the user)
        <span class="cov0" title="0">updateQuery := `
                UPDATE login_sessions
                SET status = 'revoked', last_activity = CURRENT_TIMESTAMP
                WHERE id = ? AND user_id = ? AND is_current = FALSE
        `

        result, err := db.(*sql.DB).Exec(updateQuery, sessionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to logout specific device: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to logout from device",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Session not found or cannot logout from current device",
                })
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Logged out from specific device (session: %s) for user: %s\n", sessionID, userID)

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Logged out from device successfully",
        })</span>
}

// RecordLoginSession records a new login session
func RecordLoginSession(db *sql.DB, userID, deviceType, deviceName, os, browser, ipAddress, location string) error <span class="cov0" title="0">{
        // Ensure the table exists first
        createTableQuery := `
                CREATE TABLE IF NOT EXISTS login_sessions (
                        id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
                        user_id TEXT NOT NULL,
                        device_type TEXT,
                        device_name TEXT,
                        operating_system TEXT,
                        browser TEXT,
                        ip_address TEXT,
                        location TEXT,
                        login_time DATETIME DEFAULT CURRENT_TIMESTAMP,
                        last_activity DATETIME DEFAULT CURRENT_TIMESTAMP,
                        status TEXT DEFAULT 'active',
                        is_current BOOLEAN DEFAULT FALSE,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )
        `

        _, err := db.Exec(createTableQuery)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create login_sessions table in RecordLoginSession: %v\n", err)
                return err
        }</span>

        // Mark all previous sessions as not current
        <span class="cov0" title="0">_, err = db.Exec("UPDATE login_sessions SET is_current = FALSE WHERE user_id = ?", userID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update previous sessions: %v\n", err)
        }</span>

        // Insert new session with debug logging
        <span class="cov0" title="0">insertQuery := `
                INSERT INTO login_sessions
                (user_id, device_type, device_name, operating_system, browser, ip_address, location, is_current)
                VALUES (?, ?, ?, ?, ?, ?, ?, TRUE)
        `

        fmt.Printf("Recording login session for user %s: device=%s, name=%s, os=%s, browser=%s, ip=%s, location=%s\n",
                userID, deviceType, deviceName, os, browser, ipAddress, location)

        _, err = db.Exec(insertQuery, userID, deviceType, deviceName, os, browser, ipAddress, location)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to record login session: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("Successfully recorded login session for user %s\n", userID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package api

import (
        "database/sql"
        "encoding/json"
        "log"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

// GetSellerAnalytics returns analytics data for sellers
func GetSellerAnalytics(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context
        userIDInterface, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>
        <span class="cov0" title="0">userID := userIDInterface.(string)

        period := c.DefaultQuery("period", "30d")

        // Get database connection
        dbInterface, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>
        <span class="cov0" title="0">db := dbInterface.(*sql.DB)

        // Get real analytics data from database
        analytics, err := getSellerAnalyticsFromDB(db, userID, period)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting seller analytics: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get analytics data"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    analytics,
        })</span>
}

// getSellerAnalyticsFromDB retrieves real analytics data from the database
func getSellerAnalyticsFromDB(db *sql.DB, userID, period string) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Calculate date range based on period
        var startDate time.Time
        now := time.Now()

        switch period </span>{
        case "7d":<span class="cov0" title="0">
                startDate = now.AddDate(0, 0, -7)</span>
        case "30d":<span class="cov0" title="0">
                startDate = now.AddDate(0, 0, -30)</span>
        case "90d":<span class="cov0" title="0">
                startDate = now.AddDate(0, 0, -90)</span>
        case "1y":<span class="cov0" title="0">
                startDate = now.AddDate(-1, 0, 0)</span>
        default:<span class="cov0" title="0">
                startDate = now.AddDate(0, 0, -30)</span>
        }

        <span class="cov0" title="0">analytics := map[string]interface{}{
                "overview": map[string]interface{}{
                        "totalRevenue":      0.0,
                        "totalOrders":       0,
                        "averageOrderValue": 0.0,
                        "conversionRate":    0.0,
                        "totalProducts":     0,
                        "activeProducts":    0,
                        "totalViews":        0,
                        "totalCustomers":    0,
                },
                "trends": map[string]interface{}{
                        "revenueGrowth":  0.0,
                        "orderGrowth":    0.0,
                        "customerGrowth": 0.0,
                },
                "topProducts":    []map[string]interface{}{},
                "ordersByStatus": []map[string]interface{}{},
                "customerInsights": map[string]interface{}{
                        "newCustomers":             0,
                        "returningCustomers":       0,
                        "averageOrdersPerCustomer": 0.0,
                },
                "deliveryMetrics": map[string]interface{}{
                        "onTimeDeliveries":    0,
                        "averageDeliveryTime": 0.0,
                        "deliverySuccessRate": 0,
                },
        }

        // Get total revenue and orders for the seller
        revenueQuery := `
                SELECT
                        COALESCE(SUM(total_amount), 0) as total_revenue,
                        COUNT(*) as total_orders,
                        COALESCE(AVG(total_amount), 0) as avg_order_value
                FROM orders
                WHERE seller_id = ? AND created_at &gt;= ? AND status != 'cancelled'
        `

        var totalRevenue, avgOrderValue float64
        var totalOrders int
        err := db.QueryRow(revenueQuery, userID, startDate).Scan(&amp;totalRevenue, &amp;totalOrders, &amp;avgOrderValue)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get total products for the seller
        <span class="cov0" title="0">productQuery := `
                SELECT
                        COUNT(*) as total_products,
                        COUNT(CASE WHEN status = 'active' THEN 1 END) as active_products
                FROM products
                WHERE seller_id = ?
        `

        var totalProducts, activeProducts int
        err = db.QueryRow(productQuery, userID).Scan(&amp;totalProducts, &amp;activeProducts)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get unique customers count
        <span class="cov0" title="0">customerQuery := `
                SELECT COUNT(DISTINCT buyer_id) as total_customers
                FROM orders
                WHERE seller_id = ? AND created_at &gt;= ? AND status != 'cancelled'
        `

        var totalCustomers int
        err = db.QueryRow(customerQuery, userID, startDate).Scan(&amp;totalCustomers)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update overview data
        <span class="cov0" title="0">overview := analytics["overview"].(map[string]interface{})
        overview["totalRevenue"] = totalRevenue
        overview["totalOrders"] = totalOrders
        overview["averageOrderValue"] = avgOrderValue
        overview["totalProducts"] = totalProducts
        overview["activeProducts"] = activeProducts
        overview["totalCustomers"] = totalCustomers

        // Get top products
        topProductsQuery := `
                SELECT
                        p.id,
                        p.name,
                        COUNT(oi.id) as sales,
                        COALESCE(SUM(oi.price * oi.quantity), 0) as revenue
                FROM products p
                LEFT JOIN order_items oi ON p.id = oi.product_id
                LEFT JOIN orders o ON oi.order_id = o.id
                WHERE p.seller_id = ? AND (o.created_at &gt;= ? OR o.created_at IS NULL) AND (o.status != 'cancelled' OR o.status IS NULL)
                GROUP BY p.id, p.name
                ORDER BY revenue DESC
                LIMIT 5
        `

        rows, err := db.Query(topProductsQuery, userID, startDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var topProducts []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var productID, productName string
                var sales int
                var revenue float64

                err := rows.Scan(&amp;productID, &amp;productName, &amp;sales, &amp;revenue)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">topProducts = append(topProducts, map[string]interface{}{
                        "id":      productID,
                        "name":    productName,
                        "sales":   sales,
                        "revenue": revenue,
                })</span>
        }
        <span class="cov0" title="0">analytics["topProducts"] = topProducts

        // Get orders by status
        statusQuery := `
                SELECT status, COUNT(*) as count
                FROM orders
                WHERE seller_id = ? AND created_at &gt;= ?
                GROUP BY status
        `

        rows, err = db.Query(statusQuery, userID, startDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var ordersByStatus []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var status string
                var count int

                err := rows.Scan(&amp;status, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ordersByStatus = append(ordersByStatus, map[string]interface{}{
                        "status": status,
                        "count":  count,
                })</span>
        }
        <span class="cov0" title="0">analytics["ordersByStatus"] = ordersByStatus

        return analytics, nil</span>
}

// GetUserProducts returns products for a specific user (for auto-seller detection)
func GetUserProducts(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("userId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "User ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">dbInterface, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>
        <span class="cov0" title="0">db := dbInterface.(*sql.DB)

        // Query user's products
        query := `
                SELECT id, name, description, price, category, status, created_at
                FROM products
                WHERE seller_id = ?
                ORDER BY created_at DESC
                LIMIT 50
        `

        rows, err := db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error querying user products: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve user products",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var products []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var id, name, description, category, status, createdAt string
                var price float64

                err := rows.Scan(&amp;id, &amp;name, &amp;description, &amp;price, &amp;category, &amp;status, &amp;createdAt)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">product := map[string]interface{}{
                        "id":          id,
                        "name":        name,
                        "description": description,
                        "price":       price,
                        "category":    category,
                        "status":      status,
                        "createdAt":   createdAt,
                }

                products = append(products, product)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    products,
                "count":   len(products),
        })</span>
}

// AutoRegisterAsSeller automatically registers a user as a seller
func AutoRegisterAsSeller(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                UserID string `json:"userId" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">dbInterface, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>
        <span class="cov0" title="0">db := dbInterface.(*sql.DB)

        // Check if user exists
        var userExists bool
        userQuery := `SELECT EXISTS(SELECT 1 FROM users WHERE id = ?)`
        err := db.QueryRow(userQuery, req.UserID).Scan(&amp;userExists)
        if err != nil || !userExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "User not found",
                })
                return
        }</span>

        // Check if user already has products (confirming they should be a seller)
        <span class="cov0" title="0">var productCount int
        productQuery := `SELECT COUNT(*) FROM products WHERE seller_id = ?`
        err = db.QueryRow(productQuery, req.UserID).Scan(&amp;productCount)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error checking user products: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify seller status",
                })
                return
        }</span>

        <span class="cov0" title="0">if productCount == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "User has no products listed, cannot auto-register as seller",
                })
                return
        }</span>

        // Create marketplace seller role entry (assuming there's a marketplace_roles table)
        // If the table doesn't exist, we'll create a simple log entry
        <span class="cov0" title="0">insertQuery := `
                INSERT OR IGNORE INTO marketplace_roles (user_id, role, auto_detected, created_at, updated_at)
                VALUES (?, 'seller', 1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `

        _, err = db.Exec(insertQuery, req.UserID)
        if err != nil </span><span class="cov0" title="0">{
                // If marketplace_roles table doesn't exist, just log and return success
                log.Printf("Could not insert into marketplace_roles (table may not exist): %v", err)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "User automatically registered as seller",
                "data": gin.H{
                        "userId":       req.UserID,
                        "role":         "seller",
                        "autoDetected": true,
                        "productCount": productCount,
                },
        })</span>
}

// AutoRegisterAsBuyer automatically registers a user as a buyer
func AutoRegisterAsBuyer(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                UserID string `json:"userId" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">dbInterface, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>
        <span class="cov0" title="0">db := dbInterface.(*sql.DB)

        // Check if user exists
        var userExists bool
        userQuery := `SELECT EXISTS(SELECT 1 FROM users WHERE id = ?)`
        err := db.QueryRow(userQuery, req.UserID).Scan(&amp;userExists)
        if err != nil || !userExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "User not found",
                })
                return
        }</span>

        // Check if user is already a buyer
        <span class="cov0" title="0">var isBuyer bool
        buyerQuery := `SELECT EXISTS(SELECT 1 FROM marketplace_roles WHERE user_id = ? AND role = 'buyer' AND is_active = TRUE)`
        err = db.QueryRow(buyerQuery, req.UserID).Scan(&amp;isBuyer)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error checking buyer status: %v", err)
        }</span>

        <span class="cov0" title="0">if isBuyer </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "User is already registered as buyer",
                        "data": gin.H{
                                "userId": req.UserID,
                                "role":   "buyer",
                                "status": "already_registered",
                        },
                })
                return
        }</span>

        // Create marketplace buyer role entry
        <span class="cov0" title="0">insertQuery := `
                INSERT OR IGNORE INTO marketplace_roles (user_id, role, auto_detected, registration_data, created_at, updated_at)
                VALUES (?, 'buyer', 1, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `

        registrationData := map[string]interface{}{
                "registration_type": "auto",
                "auto_detected":     true,
                "reason":            "purchase_intent",
                "registration_date": time.Now().Format(time.RFC3339),
        }

        registrationJSON, _ := json.Marshal(registrationData)

        _, err = db.Exec(insertQuery, req.UserID, string(registrationJSON))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error inserting buyer role: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to register user as buyer",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "User automatically registered as buyer",
                "data": gin.H{
                        "userId":       req.UserID,
                        "role":         "buyer",
                        "autoDetected": true,
                        "reason":       "purchase_intent",
                },
        })</span>
}

// GetProductWithOwnership returns product details with ownership and buyer eligibility info
func GetProductWithOwnership(c *gin.Context) <span class="cov0" title="0">{
        productID := c.Param("id")
        // Try to get userID from authentication, but don't require it
        userID, _ := c.Get("userID")
        userIDStr := ""
        if userID != nil </span><span class="cov0" title="0">{
                userIDStr = userID.(string)
        }</span>

        <span class="cov0" title="0">if productID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Product ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">dbInterface, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>
        <span class="cov0" title="0">db := dbInterface.(*sql.DB)

        // Query product with seller information (including all fields)
        query := `
                SELECT p.id, p.name, p.description, p.price, p.category, p.status,
                           p.images, p.stock, p.currency, p.county, p.town, p.address,
                           p.seller_id, p.created_at, p.updated_at,
                           u.first_name, u.last_name, u.email, u.avatar
                FROM products p
                LEFT JOIN users u ON p.seller_id = u.id
                WHERE p.id = ?
        `

        var product map[string]interface{} = make(map[string]interface{})
        var sellerFirstName, sellerLastName, sellerEmail, sellerAvatar sql.NullString
        var imagesJSON, currency, county, town, address sql.NullString
        var id, name, description, category, status, sellerID, createdAt, updatedAt string
        var price float64
        var stock int

        err := db.QueryRow(query, productID).Scan(
                &amp;id, &amp;name, &amp;description, &amp;price, &amp;category, &amp;status,
                &amp;imagesJSON, &amp;stock, &amp;currency, &amp;county, &amp;town, &amp;address,
                &amp;sellerID, &amp;createdAt, &amp;updatedAt,
                &amp;sellerFirstName, &amp;sellerLastName, &amp;sellerEmail, &amp;sellerAvatar,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Product not found",
                        })
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Error querying product: %v", err)
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to retrieve product",
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Parse images JSON
        <span class="cov0" title="0">var images []string
        if imagesJSON.Valid &amp;&amp; imagesJSON.String != "" </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(imagesJSON.String), &amp;images); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing images JSON: %v", err)
                        images = []string{} // Default to empty array
                }</span>
        }

        // Build product object with proper null handling
        <span class="cov0" title="0">product = map[string]interface{}{
                "id":          id,
                "name":        name,
                "description": description,
                "price":       price,
                "category":    category,
                "status":      status,
                "images":      images,
                "stock":       stock,
                "sellerId":    sellerID,
                "createdAt":   createdAt,
                "updatedAt":   updatedAt,
        }

        // Add nullable fields only if they have values
        if currency.Valid </span><span class="cov0" title="0">{
                product["currency"] = currency.String
        }</span>
        <span class="cov0" title="0">if county.Valid </span><span class="cov0" title="0">{
                product["county"] = county.String
        }</span>
        <span class="cov0" title="0">if town.Valid </span><span class="cov0" title="0">{
                product["town"] = town.String
        }</span>
        <span class="cov0" title="0">if address.Valid </span><span class="cov0" title="0">{
                product["address"] = address.String
        }</span>

        // Add seller information
        <span class="cov0" title="0">seller := map[string]interface{}{
                "id": sellerID,
        }
        if sellerFirstName.Valid &amp;&amp; sellerLastName.Valid </span><span class="cov0" title="0">{
                product["sellerName"] = sellerFirstName.String + " " + sellerLastName.String
                seller["firstName"] = sellerFirstName.String
                seller["lastName"] = sellerLastName.String
        }</span>
        <span class="cov0" title="0">if sellerEmail.Valid </span><span class="cov0" title="0">{
                product["sellerEmail"] = sellerEmail.String
                seller["email"] = sellerEmail.String
        }</span>
        <span class="cov0" title="0">if sellerAvatar.Valid </span><span class="cov0" title="0">{
                seller["avatar"] = sellerAvatar.String
        }</span>
        <span class="cov0" title="0">product["seller"] = seller

        // Determine ownership and buyer eligibility
        isOwner := userIDStr == sellerID
        buyerEligibility := map[string]interface{}{
                "canBuy":    false,
                "reason":    "",
                "isOwner":   isOwner,
                "needsAuth": userIDStr == "",
        }

        if userIDStr == "" </span><span class="cov0" title="0">{
                // User not authenticated - but this is fine, they just can't buy
                buyerEligibility["reason"] = "authentication_required"
        }</span> else<span class="cov0" title="0"> if isOwner </span><span class="cov0" title="0">{
                // User owns this product
                buyerEligibility["reason"] = "own_product"
        }</span> else<span class="cov0" title="0"> {
                // Check if user can buy (is a buyer or seller)
                var hasRole bool
                roleQuery := `
                        SELECT EXISTS(
                                SELECT 1 FROM marketplace_roles
                                WHERE user_id = ? AND role IN ('buyer', 'seller') AND is_active = TRUE
                        )
                `
                if err := db.QueryRow(roleQuery, userIDStr).Scan(&amp;hasRole); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error checking user roles: %v", err)
                }</span>

                // Also check if user is auto-detected seller (has products)
                <span class="cov0" title="0">var isAutoSeller bool
                if !hasRole </span><span class="cov0" title="0">{
                        var productCount int
                        autoSellerQuery := `SELECT COUNT(*) FROM products WHERE seller_id = ?`
                        if err := db.QueryRow(autoSellerQuery, userIDStr).Scan(&amp;productCount); err == nil </span><span class="cov0" title="0">{
                                isAutoSeller = productCount &gt; 0
                        }</span>
                }

                <span class="cov0" title="0">if hasRole || isAutoSeller </span><span class="cov0" title="0">{
                        buyerEligibility["canBuy"] = true
                        buyerEligibility["reason"] = "eligible"
                        if isAutoSeller </span><span class="cov0" title="0">{
                                buyerEligibility["autoDetectedSeller"] = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        buyerEligibility["reason"] = "buyer_registration_required"
                }</span>
        }

        <span class="cov0" title="0">product["buyerEligibility"] = buyerEligibility

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    product,
        })</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "strconv"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// SharesHandlers handles shares-related HTTP requests
type SharesHandlers struct {
        sharesService *services.SharesService
}

// NewSharesHandlers creates a new shares handlers instance
func NewSharesHandlers(db *sql.DB) *SharesHandlers <span class="cov0" title="0">{
        return &amp;SharesHandlers{
                sharesService: services.NewSharesService(db),
        }
}</span>

// CreateShares creates new shares for a member
func (h *SharesHandlers) CreateShares(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.SharesResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.SharesResponse{
                        Success: false,
                        Error:   "Chama ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateShareRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.SharesResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">share, err := h.sharesService.CreateShares(chamaID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.SharesResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, models.SharesResponse{
                Success: true,
                Data:    share,
                Message: "Shares created successfully",
        })</span>
}

// GetChamaShares retrieves all shares for a chama
func (h *SharesHandlers) GetChamaShares(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.SharesListResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.SharesListResponse{
                        Success: false,
                        Error:   "Chama ID is required",
                })
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">shares, err := h.sharesService.GetChamaShares(chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.SharesListResponse{
                        Success: false,
                        Error:   "Failed to retrieve shares",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.SharesListResponse{
                Success: true,
                Data:    convertToShareSlice(shares),
                Count:   len(shares),
        })</span>
}

// GetMemberShares retrieves shares for a specific member
func (h *SharesHandlers) GetMemberShares(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        memberID := c.Param("memberId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.SharesListResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" || memberID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.SharesListResponse{
                        Success: false,
                        Error:   "Chama ID and Member ID are required",
                })
                return
        }</span>

        <span class="cov0" title="0">shares, err := h.sharesService.GetMemberShares(chamaID, memberID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.SharesListResponse{
                        Success: false,
                        Error:   "Failed to retrieve member shares",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.SharesListResponse{
                Success: true,
                Data:    shares,
                Count:   len(shares),
        })</span>
}

// GetChamaSharesSummary retrieves aggregated share information for a chama
func (h *SharesHandlers) GetChamaSharesSummary(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.ChamaSharesSummaryResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.ChamaSharesSummaryResponse{
                        Success: false,
                        Error:   "Chama ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">summaries, err := h.sharesService.GetChamaSharesSummary(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.ChamaSharesSummaryResponse{
                        Success: false,
                        Error:   "Failed to retrieve shares summary",
                })
                return
        }</span>

        // Calculate totals
        <span class="cov0" title="0">totalShares := 0
        totalValue := 0.0
        for _, summary := range summaries </span><span class="cov0" title="0">{
                totalShares += summary.TotalShares
                totalValue += summary.TotalValue
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.ChamaSharesSummaryResponse{
                Success:      true,
                Data:         summaries,
                TotalShares:  totalShares,
                TotalValue:   totalValue,
                TotalMembers: len(summaries),
        })</span>
}

// UpdateShares updates existing shares
func (h *SharesHandlers) UpdateShares(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        shareID := c.Param("shareId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.SharesResponse{
                        Success: false,
                        Error:   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if shareID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.SharesResponse{
                        Success: false,
                        Error:   "Share ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateShareRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.SharesResponse{
                        Success: false,
                        Error:   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">share, err := h.sharesService.UpdateShares(shareID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "share not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, models.SharesResponse{
                                Success: false,
                                Error:   "Share not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, models.SharesResponse{
                        Success: false,
                        Error:   err.Error(),
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.SharesResponse{
                Success: true,
                Data:    share,
                Message: "Shares updated successfully",
        })</span>
}

// GetShareTransactions retrieves share transactions for a chama
func (h *SharesHandlers) GetShareTransactions(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">transactions, err := h.sharesService.GetShareTransactions(chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve share transactions",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    transactions,
                "count":   len(transactions),
        })</span>
}

// Helper function to convert ShareWithMemberInfo slice to Share slice
func convertToShareSlice(sharesWithInfo []models.ShareWithMemberInfo) []models.Share <span class="cov0" title="0">{
        shares := make([]models.Share, len(sharesWithInfo))
        for i, shareWithInfo := range sharesWithInfo </span><span class="cov0" title="0">{
                shares[i] = shareWithInfo.Share
        }</span>
        <span class="cov0" title="0">return shares</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
)

// SupportRequest represents a user support request
type SupportRequest struct {
        ID          string     `json:"id" db:"id"`
        UserID      string     `json:"userId" db:"user_id"`
        Category    string     `json:"category" db:"category"`
        Subject     string     `json:"subject" db:"subject"`
        Description string     `json:"description" db:"description"`
        Priority    string     `json:"priority" db:"priority"`
        Status      string     `json:"status" db:"status"`
        CreatedAt   time.Time  `json:"createdAt" db:"created_at"`
        UpdatedAt   time.Time  `json:"updatedAt" db:"updated_at"`
        ResolvedAt  *time.Time `json:"resolvedAt,omitempty" db:"resolved_at"`
        AdminNotes  *string    `json:"adminNotes,omitempty" db:"admin_notes"`

        // User information
        UserEmail     *string `json:"userEmail,omitempty" db:"user_email"`
        UserFirstName *string `json:"userFirstName,omitempty" db:"user_first_name"`
        UserLastName  *string `json:"userLastName,omitempty" db:"user_last_name"`
}

// CreateSupportRequest creates a new support request
func CreateSupportRequest(c *gin.Context) <span class="cov0" title="0">{
        // fmt.Printf("\n🎫 ===== CREATE SUPPORT REQUEST STARTED =====\n")
        // fmt.Printf("🎫 Request Method: %s\n", c.Request.Method)
        // fmt.Printf("🎫 Request URL: %s\n", c.Request.URL.String())
        // fmt.Printf("🎫 Content-Type: %s\n", c.GetHeader("Content-Type"))

        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                fmt.Printf("❌ CREATE SUPPORT REQUEST: User not authenticated\n")
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // fmt.Printf("🎫 CREATE SUPPORT REQUEST: UserID=%s\n", userID)

        <span class="cov0" title="0">var requestData struct {
                Category    string `json:"category" binding:"required"`
                Subject     string `json:"subject" binding:"required"`
                Description string `json:"description" binding:"required"`
                Priority    string `json:"priority"`
                UserInfo    struct {
                        UserID    string `json:"userId"`
                        Email     string `json:"email"`
                        FirstName string `json:"firstName"`
                        LastName  string `json:"lastName"`
                } `json:"userInfo"`
        }

        if err := c.ShouldBindJSON(&amp;requestData); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ CREATE SUPPORT REQUEST: Invalid JSON data: %v\n", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("🎫 CREATE SUPPORT REQUEST: Parsed data - Category=%s, Subject=%s, Priority=%s\n",
                requestData.Category, requestData.Subject, requestData.Priority)

        // Get database from context
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create support_requests table if it doesn't exist
        <span class="cov0" title="0">createTableQuery := `
                CREATE TABLE IF NOT EXISTS support_requests (
                        id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
                        user_id TEXT NOT NULL,
                        category TEXT NOT NULL,
                        subject TEXT NOT NULL,
                        description TEXT NOT NULL,
                        priority TEXT DEFAULT 'medium',
                        status TEXT DEFAULT 'open',
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        resolved_at DATETIME,
                        admin_notes TEXT,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )
        `

        _, err := db.(*sql.DB).Exec(createTableQuery)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create support_requests table: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to initialize support system",
                })
                return
        }</span>

        // Set default priority if not provided
        <span class="cov0" title="0">priority := requestData.Priority
        if priority == "" </span><span class="cov0" title="0">{
                priority = "medium"
        }</span>

        // Generate a unique ID for the support request
        <span class="cov0" title="0">requestID := fmt.Sprintf("sr_%d", time.Now().UnixNano())

        // Insert support request with explicit ID
        insertQuery := `
                INSERT INTO support_requests (id, user_id, category, subject, description, priority)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = db.(*sql.DB).Exec(insertQuery, requestID, userID, requestData.Category, requestData.Subject, requestData.Description, priority)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Failed to create support request: %v\n", err)
                fmt.Printf("   UserID: %s, Category: %s, Subject: %s\n", userID, requestData.Category, requestData.Subject)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create support request: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Support request created successfully: ID=%s, UserID=%s, Category=%s\n", requestID, userID, requestData.Category)

        // Create notification for admins about new support request
        go func() </span><span class="cov0" title="0">{
                // Get all admin users
                adminQuery := `SELECT id FROM users WHERE role = 'admin'`
                rows, err := db.(*sql.DB).Query(adminQuery)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to get admin users for notification: %v\n", err)
                        return
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                // Create notification for each admin
                for rows.Next() </span><span class="cov0" title="0">{
                        var adminID string
                        if err := rows.Scan(&amp;adminID); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">notificationQuery := `
                                INSERT INTO notifications (id, user_id, type, title, message, data, created_at)
                                VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
                        `

                        notificationID := fmt.Sprintf("notif_%d_%s", time.Now().UnixNano(), adminID)
                        notificationTitle := "New Support Request"
                        notificationMessage := fmt.Sprintf("New %s support request: %s", requestData.Category, requestData.Subject)
                        notificationData := fmt.Sprintf(`{"supportRequestId": "%s", "category": "%s", "type": "new_support_request"}`, requestID, requestData.Category)

                        _, err = db.(*sql.DB).Exec(notificationQuery, notificationID, adminID, "new_support_request", notificationTitle, notificationMessage, notificationData)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to create new support request notification for admin %s: %v\n", adminID, err)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("✅ Created new support request notification for admin %s\n", adminID)
                        }</span>
                }
        }()

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Support request created successfully",
                "data": gin.H{
                        "requestId": requestID,
                        "status":    "open",
                        "id":        requestID,
                },
        })</span>
}

// GetSupportRequests retrieves support requests (for admin)
func GetSupportRequests(c *gin.Context) <span class="cov0" title="0">{
        fmt.Printf("\n📋 ===== GET SUPPORT REQUESTS STARTED =====\n")

        userID := c.GetString("userID")
        userRole := c.GetString("userRole")

        fmt.Printf("📋 UserID: %s, UserRole: %s\n", userID, userRole)

        if userID == "" </span><span class="cov0" title="0">{
                fmt.Printf("❌ GET SUPPORT REQUESTS: User not authenticated\n")
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create support_requests table if it doesn't exist
        <span class="cov0" title="0">createTableQuery := `
                CREATE TABLE IF NOT EXISTS support_requests (
                        id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
                        user_id TEXT NOT NULL,
                        category TEXT NOT NULL,
                        subject TEXT NOT NULL,
                        description TEXT NOT NULL,
                        priority TEXT DEFAULT 'medium',
                        status TEXT DEFAULT 'open',
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        resolved_at DATETIME,
                        admin_notes TEXT,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )
        `

        _, err := db.(*sql.DB).Exec(createTableQuery)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create support_requests table: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to initialize support system",
                })
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")
        status := c.DefaultQuery("status", "")
        category := c.DefaultQuery("category", "")

        limit, _ := strconv.Atoi(limitStr)
        offset, _ := strconv.Atoi(offsetStr)

        var query string
        var args []interface{}

        if userRole == "admin" </span><span class="cov0" title="0">{
                // Admin can see all support requests
                query = `
                        SELECT 
                                sr.id, sr.user_id, sr.category, sr.subject, sr.description, 
                                sr.priority, sr.status, sr.created_at, sr.updated_at, 
                                sr.resolved_at, sr.admin_notes,
                                u.email as user_email, u.first_name as user_first_name, u.last_name as user_last_name
                        FROM support_requests sr
                        LEFT JOIN users u ON sr.user_id = u.id
                        WHERE 1=1
                `

                if status != "" </span><span class="cov0" title="0">{
                        query += " AND sr.status = ?"
                        args = append(args, status)
                }</span>

                <span class="cov0" title="0">if category != "" </span><span class="cov0" title="0">{
                        query += " AND sr.category = ?"
                        args = append(args, category)
                }</span>

                <span class="cov0" title="0">query += " ORDER BY sr.created_at DESC LIMIT ? OFFSET ?"
                args = append(args, limit, offset)</span>
        } else<span class="cov0" title="0"> {
                // Regular users can only see their own requests
                query = `
                        SELECT 
                                sr.id, sr.user_id, sr.category, sr.subject, sr.description, 
                                sr.priority, sr.status, sr.created_at, sr.updated_at, 
                                sr.resolved_at, sr.admin_notes,
                                u.email as user_email, u.first_name as user_first_name, u.last_name as user_last_name
                        FROM support_requests sr
                        LEFT JOIN users u ON sr.user_id = u.id
                        WHERE sr.user_id = ?
                `
                args = append(args, userID)

                if status != "" </span><span class="cov0" title="0">{
                        query += " AND sr.status = ?"
                        args = append(args, status)
                }</span>

                <span class="cov0" title="0">query += " ORDER BY sr.created_at DESC LIMIT ? OFFSET ?"
                args = append(args, limit, offset)</span>
        }

        <span class="cov0" title="0">fmt.Printf("📋 Executing query: %s\n", query)
        fmt.Printf("📋 Query args: %v\n", args)

        rows, err := db.(*sql.DB).Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Failed to get support requests: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve support requests",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var requests []SupportRequest
        requestCount := 0
        for rows.Next() </span><span class="cov0" title="0">{
                requestCount++
                var req SupportRequest
                err := rows.Scan(
                        &amp;req.ID, &amp;req.UserID, &amp;req.Category, &amp;req.Subject, &amp;req.Description,
                        &amp;req.Priority, &amp;req.Status, &amp;req.CreatedAt, &amp;req.UpdatedAt,
                        &amp;req.ResolvedAt, &amp;req.AdminNotes,
                        &amp;req.UserEmail, &amp;req.UserFirstName, &amp;req.UserLastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to scan support request: %v\n", err)
                        continue</span>
                }
                <span class="cov0" title="0">requests = append(requests, req)</span>
        }

        <span class="cov0" title="0">fmt.Printf("📋 Found %d support requests, returning %d requests\n", requestCount, len(requests))
        fmt.Printf("📋 ===== GET SUPPORT REQUESTS COMPLETED =====\n\n")

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    requests,
                "meta": gin.H{
                        "total":  len(requests),
                        "limit":  limit,
                        "offset": offset,
                },
        })</span>
}

// UpdateSupportRequest updates a support request (admin only)
func UpdateSupportRequest(c *gin.Context) <span class="cov0" title="0">{
        userRole := c.GetString("userRole")
        if userRole != "admin" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Admin access required",
                })
                return
        }</span>

        <span class="cov0" title="0">requestID := c.Param("id")
        if requestID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Request ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var updateData struct {
                Status     string `json:"status"`
                AdminNotes string `json:"adminNotes"`
        }

        if err := c.ShouldBindJSON(&amp;updateData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create support_requests table if it doesn't exist
        <span class="cov0" title="0">createTableQuery := `
                CREATE TABLE IF NOT EXISTS support_requests (
                        id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
                        user_id TEXT NOT NULL,
                        category TEXT NOT NULL,
                        subject TEXT NOT NULL,
                        description TEXT NOT NULL,
                        priority TEXT DEFAULT 'medium',
                        status TEXT DEFAULT 'open',
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        resolved_at DATETIME,
                        admin_notes TEXT,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )
        `

        _, err := db.(*sql.DB).Exec(createTableQuery)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create support_requests table: %v\n", err)
        }</span>

        // Update support request
        <span class="cov0" title="0">updateQuery := `
                UPDATE support_requests 
                SET status = ?, admin_notes = ?, updated_at = CURRENT_TIMESTAMP,
                    resolved_at = CASE WHEN ? = 'resolved' THEN CURRENT_TIMESTAMP ELSE resolved_at END
                WHERE id = ?
        `

        result, err := db.(*sql.DB).Exec(updateQuery, updateData.Status, updateData.AdminNotes, updateData.Status, requestID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update support request: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update support request",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Support request not found",
                })
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Support request updated: ID=%s, Status=%s\n", requestID, updateData.Status)

        // Create notification for the user when admin updates their support request
        go func() </span><span class="cov0" title="0">{
                // Get the support request details to find the user
                var supportUserID string
                var supportSubject string
                err := db.(*sql.DB).QueryRow("SELECT user_id, subject FROM support_requests WHERE id = ?", requestID).Scan(&amp;supportUserID, &amp;supportSubject)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to get support request details for notification: %v\n", err)
                        return
                }</span>

                // Create notification
                <span class="cov0" title="0">notificationQuery := `
                        INSERT INTO notifications (id, user_id, type, title, message, data, created_at)
                        VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
                `

                notificationID := fmt.Sprintf("notif_%d", time.Now().UnixNano())
                notificationTitle := "Support Request Updated"
                notificationMessage := fmt.Sprintf("Your support request '%s' has been updated to: %s", supportSubject, updateData.Status)
                notificationData := fmt.Sprintf(`{"supportRequestId": "%s", "status": "%s", "type": "support_update"}`, requestID, updateData.Status)

                _, err = db.(*sql.DB).Exec(notificationQuery, notificationID, supportUserID, "support_update", notificationTitle, notificationMessage, notificationData)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to create support update notification: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Created support update notification for user %s\n", supportUserID)
                }</span>
        }()

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Support request updated successfully",
        })</span>
}

// CreateTestSupportRequest creates a test support request for debugging
func CreateTestSupportRequest(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create support_requests table if it doesn't exist
        <span class="cov0" title="0">createTableQuery := `
                CREATE TABLE IF NOT EXISTS support_requests (
                        id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
                        user_id TEXT NOT NULL,
                        category TEXT NOT NULL,
                        subject TEXT NOT NULL,
                        description TEXT NOT NULL,
                        priority TEXT DEFAULT 'medium',
                        status TEXT DEFAULT 'open',
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        resolved_at DATETIME,
                        admin_notes TEXT,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )
        `

        _, err := db.(*sql.DB).Exec(createTableQuery)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create support_requests table: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to initialize support system",
                })
                return
        }</span>

        // Generate a unique ID for the test support request
        <span class="cov0" title="0">requestID := fmt.Sprintf("test_sr_%d", time.Now().UnixNano())

        // Insert test support request
        insertQuery := `
                INSERT INTO support_requests (id, user_id, category, subject, description, priority)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = db.(*sql.DB).Exec(insertQuery, requestID, userID, "technical", "Test Support Request", "This is a test support request to verify the system is working correctly.", "medium")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Failed to create test support request: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create test support request: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Test support request created successfully: ID=%s, UserID=%s\n", requestID, userID)

        c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Test support request created successfully",
                "data": gin.H{
                        "requestId": requestID,
                        "status":    "open",
                        "id":        requestID,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "log"
        "net/http"
        "strconv"
        "vaultke-backend/internal/models"
        "vaultke-backend/internal/services"
        "vaultke-backend/internal/utils"

        "github.com/gin-gonic/gin"
)

func GetUserTransactions(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limit := 50
        offset := 0
        if limitStr := c.Query("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 &amp;&amp; l &lt;= 100 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }
        <span class="cov0" title="0">if offsetStr := c.Query("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                        offset = o
                }</span>
        }

        // Create wallet service
        <span class="cov0" title="0">walletService := services.NewWalletService(db.(*sql.DB))

        // Get user's personal wallet
        wallet, err := walletService.GetWalletByOwnerAndType(userID.(string), models.WalletTypePersonal)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get user wallet: %v", err)
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Wallet not found",
                })
                return
        }</span>

        // Get wallet transactions
        <span class="cov0" title="0">transactions, err := walletService.GetWalletTransactions(wallet.ID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get wallet transactions: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve transactions",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    transactions,
                "meta": map[string]interface{}{
                        "limit":  limit,
                        "offset": offset,
                        "count":  len(transactions),
                },
        })</span>
}

// updateTransactionStatus updates transaction status
func updateTransactionStatus(db *sql.DB, transactionID string, status models.TransactionStatus) error <span class="cov0" title="0">{
        updateQuery := "UPDATE transactions SET status = ?, updated_at = ? WHERE id = ?"
        result, err := db.Exec(updateQuery, status, utils.NowEAT(), transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update transaction status: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction not found: %s", transactionID)
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully updated transaction %s status to %s", transactionID, status)
        return nil</span>
}

// updateTransactionCheckoutRequestID updates transaction with checkout request ID
func updateTransactionCheckoutRequestID(db *sql.DB, transactionID string, checkoutRequestID string) <span class="cov0" title="0">{
        updateQuery := "UPDATE transactions SET checkout_request_id = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?"
        _, err := db.Exec(updateQuery, checkoutRequestID, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update transaction checkout request ID: %v", err)
        }</span>
}

// updateTransactionReference updates transaction reference
func updateTransactionReference(db *sql.DB, transactionID, reference string) <span class="cov0" title="0">{
        updateQuery := "UPDATE transactions SET reference = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?"
        _, err := db.Exec(updateQuery, reference, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update transaction reference: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
)

// UserSearchHandlers handles user search API endpoints
type UserSearchHandlers struct {
        db *sql.DB
}

// NewUserSearchHandlers creates a new instance of UserSearchHandlers
func NewUserSearchHandlers(db *sql.DB) *UserSearchHandlers <span class="cov0" title="0">{
        return &amp;UserSearchHandlers{db: db}
}</span>

// SearchUsers searches for users by name, email, or phone number
func (h *UserSearchHandlers) SearchUsers(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get search parameters
        <span class="cov0" title="0">query := strings.TrimSpace(c.Query("query"))
        limitStr := c.DefaultQuery("limit", "20")
        offsetStr := c.DefaultQuery("offset", "0")
        excludeCurrentUser := c.DefaultQuery("excludeCurrentUser", "false")

        if query == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Search query is required",
                })
                return
        }</span>

        <span class="cov0" title="0">if len(query) &lt; 2 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Search query must be at least 2 characters",
                })
                return
        }</span>

        <span class="cov0" title="0">limit, err := strconv.Atoi(limitStr)
        if err != nil </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Build search query
        <span class="cov0" title="0">searchPattern := "%" + query + "%"

        var sqlQuery string
        var args []interface{}

        if excludeCurrentUser == "true" </span><span class="cov0" title="0">{
                sqlQuery = `
                        SELECT id, first_name, last_name, email, phone, created_at
                        FROM users
                        WHERE id != ? AND (
                                LOWER(first_name) LIKE LOWER(?) OR
                                LOWER(last_name) LIKE LOWER(?) OR
                                LOWER(email) LIKE LOWER(?) OR
                                phone LIKE ?
                        )
                        ORDER BY
                                CASE
                                        WHEN LOWER(first_name) LIKE LOWER(?) THEN 1
                                        WHEN LOWER(last_name) LIKE LOWER(?) THEN 2
                                        WHEN LOWER(email) LIKE LOWER(?) THEN 3
                                        ELSE 4
                                END,
                                first_name, last_name
                        LIMIT ? OFFSET ?
                `
                args = []interface{}{
                        userID, searchPattern, searchPattern, searchPattern, searchPattern,
                        searchPattern, searchPattern, searchPattern,
                        limit, offset,
                }
        }</span> else<span class="cov0" title="0"> {
                sqlQuery = `
                        SELECT id, first_name, last_name, email, phone, created_at
                        FROM users
                        WHERE
                                LOWER(first_name) LIKE LOWER(?) OR
                                LOWER(last_name) LIKE LOWER(?) OR
                                LOWER(email) LIKE LOWER(?) OR
                                phone LIKE ?
                        ORDER BY
                                CASE
                                        WHEN LOWER(first_name) LIKE LOWER(?) THEN 1
                                        WHEN LOWER(last_name) LIKE LOWER(?) THEN 2
                                        WHEN LOWER(email) LIKE LOWER(?) THEN 3
                                        ELSE 4
                                END,
                                first_name, last_name
                        LIMIT ? OFFSET ?
                `
                args = []interface{}{
                        searchPattern, searchPattern, searchPattern, searchPattern,
                        searchPattern, searchPattern, searchPattern,
                        limit, offset,
                }
        }</span>

        <span class="cov0" title="0">rows, err := h.db.Query(sqlQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to search users",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var id, firstName, lastName, email, createdAt string
                var phoneNumber sql.NullString

                err := rows.Scan(&amp;id, &amp;firstName, &amp;lastName, &amp;email, &amp;phoneNumber, &amp;createdAt)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">user := map[string]interface{}{
                        "id":        id,
                        "firstName": firstName,
                        "lastName":  lastName,
                        "email":     email,
                        "createdAt": createdAt,
                }

                if phoneNumber.Valid </span><span class="cov0" title="0">{
                        user["phoneNumber"] = phoneNumber.String
                }</span>

                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    users,
                "count":   len(users),
                "query":   query,
        })</span>
}

// GetUserProfile gets a user's public profile information
func (h *UserSearchHandlers) GetUserProfile(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        targetUserID := c.Param("userId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if targetUserID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "User ID is required",
                })
                return
        }</span>

        // Get user profile
        <span class="cov0" title="0">query := `
                SELECT id, first_name, last_name, email, phone, created_at
                FROM users
                WHERE id = ?
        `

        var id, firstName, lastName, email, createdAt string
        var phoneNumber sql.NullString

        err := h.db.QueryRow(query, targetUserID).Scan(&amp;id, &amp;firstName, &amp;lastName, &amp;email, &amp;phoneNumber, &amp;createdAt)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "User not found",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to get user profile",
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">user := map[string]interface{}{
                "id":        id,
                "firstName": firstName,
                "lastName":  lastName,
                "email":     email,
                "createdAt": createdAt,
        }

        if phoneNumber.Valid </span><span class="cov0" title="0">{
                user["phoneNumber"] = phoneNumber.String
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    user,
        })</span>
}

// SearchUsersAdvanced provides advanced search with filters
func (h *UserSearchHandlers) SearchUsersAdvanced(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get search parameters
        <span class="cov0" title="0">query := strings.TrimSpace(c.Query("query"))
        searchType := c.DefaultQuery("type", "all") // all, name, email, phone
        limitStr := c.DefaultQuery("limit", "20")
        offsetStr := c.DefaultQuery("offset", "0")
        excludeCurrentUser := c.DefaultQuery("excludeCurrentUser", "false")

        if query == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Search query is required",
                })
                return
        }</span>

        <span class="cov0" title="0">limit, err := strconv.Atoi(limitStr)
        if err != nil </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Build search conditions based on type
        <span class="cov0" title="0">var whereConditions []string
        var args []interface{}
        searchPattern := "%" + query + "%"

        switch searchType </span>{
        case "name":<span class="cov0" title="0">
                whereConditions = append(whereConditions, "(LOWER(first_name) LIKE LOWER(?) OR LOWER(last_name) LIKE LOWER(?))")
                args = append(args, searchPattern, searchPattern)</span>
        case "email":<span class="cov0" title="0">
                whereConditions = append(whereConditions, "LOWER(email) LIKE LOWER(?)")
                args = append(args, searchPattern)</span>
        case "phone":<span class="cov0" title="0">
                whereConditions = append(whereConditions, "phone LIKE ?")
                args = append(args, searchPattern)</span>
        default:<span class="cov0" title="0"> // "all"
                whereConditions = append(whereConditions, "(LOWER(first_name) LIKE LOWER(?) OR LOWER(last_name) LIKE LOWER(?) OR LOWER(email) LIKE LOWER(?) OR phone LIKE ?)")
                args = append(args, searchPattern, searchPattern, searchPattern, searchPattern)</span>
        }

        <span class="cov0" title="0">if excludeCurrentUser == "true" </span><span class="cov0" title="0">{
                whereConditions = append(whereConditions, "id != ?")
                args = append(args, userID)
        }</span>

        <span class="cov0" title="0">sqlQuery := `
                SELECT id, first_name, last_name, email, phone, created_at
                FROM users
                WHERE ` + strings.Join(whereConditions, " AND ") + `
                ORDER BY first_name, last_name
                LIMIT ? OFFSET ?
        `

        args = append(args, limit, offset)

        rows, err := h.db.Query(sqlQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to search users",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var id, firstName, lastName, email, createdAt string
                var phoneNumber sql.NullString

                err := rows.Scan(&amp;id, &amp;firstName, &amp;lastName, &amp;email, &amp;phoneNumber, &amp;createdAt)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">user := map[string]interface{}{
                        "id":        id,
                        "firstName": firstName,
                        "lastName":  lastName,
                        "email":     email,
                        "createdAt": createdAt,
                }

                if phoneNumber.Valid </span><span class="cov0" title="0">{
                        user["phoneNumber"] = phoneNumber.String
                }</span>

                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    users,
                "count":   len(users),
                "query":   query,
                "type":    searchType,
        })</span>
}

// CheckMarketplaceRoles checks what marketplace roles a user has
func (h *UserSearchHandlers) CheckMarketplaceRoles(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("userId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "User ID is required",
                })
                return
        }</span>

        // Query marketplace roles
        <span class="cov0" title="0">query := `
                SELECT role, auto_detected, is_active, created_at
                FROM marketplace_roles
                WHERE user_id = ? AND is_active = TRUE
        `

        rows, err := h.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to check marketplace roles",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        roles := map[string]bool{
                "buyer":           false,
                "seller":          false,
                "delivery_person": false,
        }

        roleDetails := make(map[string]interface{})

        for rows.Next() </span><span class="cov0" title="0">{
                var role, createdAt string
                var autoDetected, isActive bool

                err := rows.Scan(&amp;role, &amp;autoDetected, &amp;isActive, &amp;createdAt)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">roles[role] = true
                roleDetails[role] = map[string]interface{}{
                        "autoDetected": autoDetected,
                        "isActive":     isActive,
                        "createdAt":    createdAt,
                }</span>
        }

        // Auto-detect seller role based on products
        <span class="cov0" title="0">if !roles["seller"] </span><span class="cov0" title="0">{
                var productCount int
                productQuery := `SELECT COUNT(*) FROM products WHERE seller_id = ?`
                err := h.db.QueryRow(productQuery, userID).Scan(&amp;productCount)
                if err == nil &amp;&amp; productCount &gt; 0 </span><span class="cov0" title="0">{
                        roles["seller"] = true
                        roleDetails["seller"] = map[string]interface{}{
                                "autoDetected": true,
                                "isActive":     true,
                                "productCount": productCount,
                                "createdAt":    nil,
                        }
                }</span>
        }

        // Auto-detect buyer role for sellers (sellers can also be buyers)
        <span class="cov0" title="0">if roles["seller"] &amp;&amp; !roles["buyer"] </span><span class="cov0" title="0">{
                // Sellers are automatically buyers too (they can buy from other sellers)
                roles["buyer"] = true
                roleDetails["buyer"] = map[string]interface{}{
                        "autoDetected": true,
                        "isActive":     true,
                        "reason":       "seller_auto_buyer",
                        "createdAt":    nil,
                }
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    roles,
                "details": roleDetails,
        })</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

// User handlers
func GetUsers(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("userID")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")
        searchQuery := c.Query("q") // Get search query parameter

        limit, _ := strconv.Atoi(limitStr)
        offset, _ := strconv.Atoi(offsetStr)

        // Get database from context
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Build query with optional search functionality
        <span class="cov8" title="1">var query string
        var args []interface{}

        if searchQuery != "" </span><span class="cov0" title="0">{
                // Search by name, email, or phone number
                query = `
                        SELECT id, email, phone, first_name, last_name, avatar, role,
                                   county, town, business_type, rating, total_ratings, created_at
                        FROM users
                        WHERE id != ? AND status = 'active'
                        AND (
                                LOWER(first_name) LIKE LOWER(?) OR
                                LOWER(last_name) LIKE LOWER(?) OR
                                LOWER(email) LIKE LOWER(?) OR
                                phone LIKE ?
                        )
                        ORDER BY first_name, last_name
                        LIMIT ? OFFSET ?
                `
                searchPattern := "%" + searchQuery + "%"
                args = []interface{}{userID, searchPattern, searchPattern, searchPattern, searchPattern, limit, offset}
        }</span> else<span class="cov8" title="1"> {
                // Get all users (excluding current user)
                query = `
                        SELECT id, email, phone, first_name, last_name, avatar, role,
                                   county, town, business_type, rating, total_ratings, created_at
                        FROM users
                        WHERE id != ? AND status = 'active'
                        ORDER BY first_name, last_name
                        LIMIT ? OFFSET ?
                `
                args = []interface{}{userID, limit, offset}
        }</span>

        <span class="cov8" title="1">rows, err := db.(*sql.DB).Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve users",
                })
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var users []map[string]interface{}
        for rows.Next() </span><span class="cov8" title="1">{
                var user struct {
                        ID           string         `json:"id"`
                        Email        string         `json:"email"`
                        Phone        sql.NullString `json:"phone"`
                        FirstName    string         `json:"firstName"`
                        LastName     string         `json:"lastName"`
                        Avatar       sql.NullString `json:"avatar"`
                        Role         string         `json:"role"`
                        County       sql.NullString `json:"county"`
                        Town         sql.NullString `json:"town"`
                        BusinessType sql.NullString `json:"businessType"`
                        Rating       float64        `json:"rating"`
                        TotalRatings int            `json:"totalRatings"`
                        CreatedAt    string         `json:"createdAt"`
                }

                err := rows.Scan(
                        &amp;user.ID, &amp;user.Email, &amp;user.Phone, &amp;user.FirstName, &amp;user.LastName,
                        &amp;user.Avatar, &amp;user.Role, &amp;user.County, &amp;user.Town, &amp;user.BusinessType,
                        &amp;user.Rating, &amp;user.TotalRatings, &amp;user.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">userMap := map[string]interface{}{
                        "id":           user.ID,
                        "email":        user.Email,
                        "firstName":    user.FirstName,
                        "lastName":     user.LastName,
                        "role":         user.Role,
                        "rating":       user.Rating,
                        "totalRatings": user.TotalRatings,
                        "createdAt":    user.CreatedAt,
                }

                if user.Phone.Valid </span><span class="cov8" title="1">{
                        userMap["phone"] = user.Phone.String
                }</span>
                <span class="cov8" title="1">if user.Avatar.Valid </span><span class="cov0" title="0">{
                        userMap["avatar"] = user.Avatar.String
                }</span>
                <span class="cov8" title="1">if user.County.Valid </span><span class="cov0" title="0">{
                        userMap["county"] = user.County.String
                }</span>
                <span class="cov8" title="1">if user.Town.Valid </span><span class="cov0" title="0">{
                        userMap["town"] = user.Town.String
                }</span>
                <span class="cov8" title="1">if user.BusinessType.Valid </span><span class="cov0" title="0">{
                        userMap["businessType"] = user.BusinessType.String
                }</span>

                <span class="cov8" title="1">users = append(users, userMap)</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    users,
        })</span>
}

// GetAllUsersForAdmin - Admin endpoint to get all users (no exclusions)
func GetAllUsersForAdmin(c *gin.Context) <span class="cov8" title="1">{
        // Check if user is admin
        userRole := c.GetString("userRole")
        if userRole != "admin" </span><span class="cov8" title="1">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Only admins can access this endpoint",
                })
                return
        }</span>

        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "100")
        offsetStr := c.DefaultQuery("offset", "0")
        searchQuery := c.Query("q") // Get search query parameter

        limit, _ := strconv.Atoi(limitStr)
        offset, _ := strconv.Atoi(offsetStr)

        // Get database from context
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        <span class="cov0" title="0">var query string
        var args []interface{}

        if searchQuery != "" </span><span class="cov0" title="0">{
                // Search users by name, email, or phone
                query = `
                        SELECT id, email, phone, first_name, last_name, avatar, role,
                                   county, town, business_type, rating, total_ratings, created_at, status
                        FROM users
                        WHERE (first_name LIKE ? OR last_name LIKE ? OR email LIKE ? OR phone LIKE ?)
                        ORDER BY first_name, last_name
                        LIMIT ? OFFSET ?
                `
                searchPattern := "%" + searchQuery + "%"
                args = []interface{}{searchPattern, searchPattern, searchPattern, searchPattern, limit, offset}
        }</span> else<span class="cov0" title="0"> {
                // Get all users (including current user for admin view)
                query = `
                        SELECT id, email, phone, first_name, last_name, avatar, role,
                                   county, town, business_type, rating, total_ratings, created_at, status
                        FROM users
                        ORDER BY first_name, last_name
                        LIMIT ? OFFSET ?
                `
                args = []interface{}{limit, offset}
        }</span>

        <span class="cov0" title="0">rows, err := db.(*sql.DB).Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve users",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var user struct {
                        ID           string         `json:"id"`
                        Email        string         `json:"email"`
                        Phone        string         `json:"phone"`
                        FirstName    string         `json:"firstName"`
                        LastName     string         `json:"lastName"`
                        Avatar       sql.NullString `json:"avatar"`
                        Role         string         `json:"role"`
                        County       sql.NullString `json:"county"`
                        Town         sql.NullString `json:"town"`
                        BusinessType sql.NullString `json:"businessType"`
                        Rating       float64        `json:"rating"`
                        TotalRatings int            `json:"totalRatings"`
                        CreatedAt    string         `json:"createdAt"`
                        Status       string         `json:"status"`
                }

                err := rows.Scan(
                        &amp;user.ID, &amp;user.Email, &amp;user.Phone, &amp;user.FirstName, &amp;user.LastName,
                        &amp;user.Avatar, &amp;user.Role, &amp;user.County, &amp;user.Town, &amp;user.BusinessType,
                        &amp;user.Rating, &amp;user.TotalRatings, &amp;user.CreatedAt, &amp;user.Status,
                )
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to scan user data",
                        })
                        return
                }</span>

                <span class="cov0" title="0">userMap := map[string]interface{}{
                        "id":           user.ID,
                        "email":        user.Email,
                        "phone":        user.Phone,
                        "firstName":    user.FirstName,
                        "lastName":     user.LastName,
                        "role":         user.Role,
                        "rating":       user.Rating,
                        "totalRatings": user.TotalRatings,
                        "createdAt":    user.CreatedAt,
                        "status":       user.Status,
                }

                if user.Avatar.Valid </span><span class="cov0" title="0">{
                        userMap["avatar"] = user.Avatar.String
                }</span>
                <span class="cov0" title="0">if user.County.Valid </span><span class="cov0" title="0">{
                        userMap["county"] = user.County.String
                }</span>
                <span class="cov0" title="0">if user.Town.Valid </span><span class="cov0" title="0">{
                        userMap["town"] = user.Town.String
                }</span>
                <span class="cov0" title="0">if user.BusinessType.Valid </span><span class="cov0" title="0">{
                        userMap["businessType"] = user.BusinessType.String
                }</span>

                <span class="cov0" title="0">users = append(users, userMap)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    users,
                "count":   len(users),
        })</span>
}

func GetProfile(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Profile endpoint - coming soon",
        })
}</span>

func UpdateProfile(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Update profile endpoint - coming soon",
        })
}</span>

func UploadAvatar(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Upload avatar endpoint - coming soon",
        })
}</span>

// AdminUpdateUserRole - Admin endpoint to update user role (temporary for setup)
func AdminUpdateUserRole(c *gin.Context) <span class="cov8" title="1">{
        userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "User ID is required",
                })
                return
        }</span>

        <span class="cov8" title="1">var request struct {
                Role string `json:"role" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request body",
                })
                return
        }</span>

        // Validate role
        <span class="cov8" title="1">if request.Role != "user" &amp;&amp; request.Role != "admin" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Role must be either 'user' or 'admin'",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Update user role
        <span class="cov0" title="0">query := `UPDATE users SET role = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`
        result, err := db.(*sql.DB).Exec(query, request.Role, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update user role: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil || rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "User not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "User role updated successfully",
                "data": gin.H{
                        "userId": userID,
                        "role":   request.Role,
                },
        })</span>
}

// UpdateUserRole - Admin endpoint to update user role
func UpdateUserRole(c *gin.Context) <span class="cov0" title="0">{
        // Get current user role from context
        userRole := c.GetString("userRole")
        if userRole != "admin" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Only admins can update user roles",
                })
                return
        }</span>

        <span class="cov0" title="0">userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "User ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                Role string `json:"role" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request body",
                })
                return
        }</span>

        // Validate role
        <span class="cov0" title="0">if request.Role != "user" &amp;&amp; request.Role != "admin" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Role must be either 'user' or 'admin'",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Update user role
        <span class="cov0" title="0">query := `UPDATE users SET role = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`
        result, err := db.(*sql.DB).Exec(query, request.Role, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update user role",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil || rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "User not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "User role updated successfully",
                "data": gin.H{
                        "userId": userID,
                        "role":   request.Role,
                },
        })</span>
}

// UpdateUserStatus - Admin endpoint to update user status
func UpdateUserStatus(c *gin.Context) <span class="cov8" title="1">{
        // Check if user is admin
        userRole := c.GetString("userRole")
        if userRole != "admin" </span><span class="cov8" title="1">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Only admins can update user status",
                })
                return
        }</span>

        <span class="cov0" title="0">userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "User ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                Status string `json:"status" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request body",
                })
                return
        }</span>

        // Validate status
        <span class="cov0" title="0">if request.Status != "active" &amp;&amp; request.Status != "suspended" &amp;&amp; request.Status != "pending" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Status must be 'active', 'suspended', or 'pending'",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Update user status
        <span class="cov0" title="0">query := `UPDATE users SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`
        result, err := db.(*sql.DB).Exec(query, request.Status, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update user status",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to check update result",
                })
                return
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "User not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "User status updated successfully",
                "data": map[string]interface{}{
                        "id":     userID,
                        "status": request.Status,
                },
        })</span>
}

// DeleteUser - Admin endpoint to delete a user
func DeleteUser(c *gin.Context) <span class="cov8" title="1">{
        // Check if user is admin
        userRole := c.GetString("userRole")
        if userRole != "admin" </span><span class="cov8" title="1">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Only admins can delete users",
                })
                return
        }</span>

        <span class="cov0" title="0">userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "User ID is required",
                })
                return
        }</span>

        // Get current admin user ID to prevent self-deletion
        <span class="cov0" title="0">currentUserID := c.GetString("userID")
        if userID == currentUserID </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Cannot delete your own account",
                })
                return
        }</span>

        // Get database from context
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if user exists
        <span class="cov0" title="0">var existingUserID string
        checkQuery := `SELECT id FROM users WHERE id = ?`
        err := db.(*sql.DB).QueryRow(checkQuery, userID).Scan(&amp;existingUserID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "User not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to check user existence",
                })
                return</span>
        }

        // For safety, we'll soft delete by setting status to 'deleted' instead of hard delete
        // This preserves data integrity and allows for potential recovery
        <span class="cov0" title="0">deleteQuery := `UPDATE users SET status = 'deleted', updated_at = CURRENT_TIMESTAMP WHERE id = ?`
        result, err := db.(*sql.DB).Exec(deleteQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to delete user",
                })
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to check delete result",
                })
                return
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "User not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "User deleted successfully",
                "data": map[string]interface{}{
                        "id": userID,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
)

// CreateVote creates a new vote using the old vote system
func CreateVote(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Title       string `json:"title" binding:"required"`
                Description string `json:"description"`
                Type        string `json:"type"`
                EndsAt      string `json:"ends_at"`
                Options     []struct {
                        OptionText string `json:"option_text" binding:"required"`
                } `json:"options" binding:"required,min=2"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Parse end date
        <span class="cov0" title="0">var endsAt time.Time
        if req.EndsAt != "" </span><span class="cov0" title="0">{
                var err error
                endsAt, err = time.Parse(time.RFC3339, req.EndsAt)
                if err != nil </span><span class="cov0" title="0">{
                        // Default to 7 days from now if parsing fails
                        endsAt = time.Now().Add(7 * 24 * time.Hour)
                }</span>
        } else<span class="cov0" title="0"> {
                // Default to 7 days from now
                endsAt = time.Now().Add(7 * 24 * time.Hour)
        }</span>

        // Create vote
        <span class="cov0" title="0">voteID := fmt.Sprintf("vote-%d", time.Now().UnixNano())
        voteType := req.Type
        if voteType == "" </span><span class="cov0" title="0">{
                voteType = "general"
        }</span>

        <span class="cov0" title="0">_, err := db.(*sql.DB).Exec(`
                INSERT INTO votes (id, chama_id, title, description, type, status, ends_at, created_by, created_at)
                VALUES (?, ?, ?, ?, ?, 'active', ?, ?, CURRENT_TIMESTAMP)
        `, voteID, chamaID, req.Title, req.Description, voteType, endsAt, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create vote: " + err.Error(),
                })
                return
        }</span>

        // Create vote options
        <span class="cov0" title="0">for _, option := range req.Options </span><span class="cov0" title="0">{
                optionID := fmt.Sprintf("option-%d-%s", time.Now().UnixNano(), option.OptionText[:min(10, len(option.OptionText))])
                _, err = db.(*sql.DB).Exec(`
                        INSERT INTO vote_options (id, vote_id, option_text, vote_count)
                        VALUES (?, ?, ?, 0)
                `, optionID, voteID, option.OptionText)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to create vote option: " + err.Error(),
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Vote created successfully",
                "data": map[string]interface{}{
                        "id":          voteID,
                        "chamaId":     chamaID,
                        "title":       req.Title,
                        "description": req.Description,
                        "type":        voteType,
                        "status":      "active",
                        "endsAt":      endsAt.Format(time.RFC3339),
                        "createdBy":   userID,
                        "createdAt":   time.Now().Format(time.RFC3339),
                },
        })</span>
}

// GetChamaVotes retrieves votes for a chama
func GetChamaVotes(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "50")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get votes with options and user vote status
        <span class="cov0" title="0">rows, err := db.(*sql.DB).Query(`
                SELECT v.id, v.title, v.description, v.type, v.status, v.starts_at, v.ends_at, v.created_by, v.created_at,
                       u.first_name, u.last_name,
                       CASE WHEN uv.id IS NOT NULL THEN 1 ELSE 0 END as user_voted
                FROM votes v
                LEFT JOIN users u ON v.created_by = u.id
                LEFT JOIN user_votes uv ON v.id = uv.vote_id AND uv.user_id = ?
                WHERE v.chama_id = ?
                ORDER BY v.created_at DESC
                LIMIT ? OFFSET ?
        `, userID, chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve votes: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var votes []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var vote struct {
                        ID          string
                        Title       string
                        Description sql.NullString
                        Type        string
                        Status      string
                        StartsAt    string
                        EndsAt      string
                        CreatedBy   string
                        CreatedAt   string
                        FirstName   sql.NullString
                        LastName    sql.NullString
                        UserVoted   int
                }

                err := rows.Scan(&amp;vote.ID, &amp;vote.Title, &amp;vote.Description, &amp;vote.Type, &amp;vote.Status,
                        &amp;vote.StartsAt, &amp;vote.EndsAt, &amp;vote.CreatedBy, &amp;vote.CreatedAt,
                        &amp;vote.FirstName, &amp;vote.LastName, &amp;vote.UserVoted)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get vote options
                <span class="cov0" title="0">optionRows, err := db.(*sql.DB).Query(`
                        SELECT id, option_text, vote_count
                        FROM vote_options
                        WHERE vote_id = ?
                        ORDER BY id
                `, vote.ID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var options []map[string]interface{}
                totalVotes := 0
                for optionRows.Next() </span><span class="cov0" title="0">{
                        var option struct {
                                ID        string
                                Text      string
                                VoteCount int
                        }
                        if err := optionRows.Scan(&amp;option.ID, &amp;option.Text, &amp;option.VoteCount); err == nil </span><span class="cov0" title="0">{
                                options = append(options, map[string]interface{}{
                                        "id":        option.ID,
                                        "text":      option.Text,
                                        "voteCount": option.VoteCount,
                                })
                                totalVotes += option.VoteCount
                        }</span>
                }
                <span class="cov0" title="0">optionRows.Close()

                createdByName := "Unknown"
                if vote.FirstName.Valid &amp;&amp; vote.LastName.Valid </span><span class="cov0" title="0">{
                        createdByName = vote.FirstName.String + " " + vote.LastName.String
                }</span>

                <span class="cov0" title="0">votes = append(votes, map[string]interface{}{
                        "id":          vote.ID,
                        "title":       vote.Title,
                        "description": vote.Description.String,
                        "type":        vote.Type,
                        "status":      vote.Status,
                        "startsAt":    vote.StartsAt,
                        "endsAt":      vote.EndsAt,
                        "createdBy":   createdByName,
                        "createdAt":   vote.CreatedAt,
                        "options":     options,
                        "totalVotes":  totalVotes,
                        "userVoted":   vote.UserVoted == 1,
                })</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    votes,
                "count":   len(votes),
        })</span>
}

// GetActiveVotes retrieves active votes for a chama
func GetActiveVotes(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get active votes (status = 'active' and ends_at &gt; now)
        <span class="cov0" title="0">rows, err := db.(*sql.DB).Query(`
                SELECT v.id, v.title, v.description, v.type, v.status, v.starts_at, v.ends_at, v.created_by, v.created_at,
                       u.first_name, u.last_name,
                       CASE WHEN uv.id IS NOT NULL THEN 1 ELSE 0 END as user_voted
                FROM votes v
                LEFT JOIN users u ON v.created_by = u.id
                LEFT JOIN user_votes uv ON v.id = uv.vote_id AND uv.user_id = ?
                WHERE v.chama_id = ? AND v.status = 'active' AND v.ends_at &gt; datetime('now')
                ORDER BY v.created_at DESC
        `, userID, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve active votes: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var votes []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var vote struct {
                        ID          string
                        Title       string
                        Description sql.NullString
                        Type        string
                        Status      string
                        StartsAt    string
                        EndsAt      string
                        CreatedBy   string
                        CreatedAt   string
                        FirstName   sql.NullString
                        LastName    sql.NullString
                        UserVoted   int
                }

                err := rows.Scan(&amp;vote.ID, &amp;vote.Title, &amp;vote.Description, &amp;vote.Type, &amp;vote.Status,
                        &amp;vote.StartsAt, &amp;vote.EndsAt, &amp;vote.CreatedBy, &amp;vote.CreatedAt,
                        &amp;vote.FirstName, &amp;vote.LastName, &amp;vote.UserVoted)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get vote options
                <span class="cov0" title="0">optionRows, err := db.(*sql.DB).Query(`
                        SELECT id, option_text, vote_count
                        FROM vote_options
                        WHERE vote_id = ?
                        ORDER BY id
                `, vote.ID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var options []map[string]interface{}
                totalVotes := 0
                for optionRows.Next() </span><span class="cov0" title="0">{
                        var option struct {
                                ID        string
                                Text      string
                                VoteCount int
                        }
                        if err := optionRows.Scan(&amp;option.ID, &amp;option.Text, &amp;option.VoteCount); err == nil </span><span class="cov0" title="0">{
                                options = append(options, map[string]interface{}{
                                        "id":        option.ID,
                                        "text":      option.Text,
                                        "voteCount": option.VoteCount,
                                })
                                totalVotes += option.VoteCount
                        }</span>
                }
                <span class="cov0" title="0">optionRows.Close()

                createdByName := "Unknown"
                if vote.FirstName.Valid &amp;&amp; vote.LastName.Valid </span><span class="cov0" title="0">{
                        createdByName = vote.FirstName.String + " " + vote.LastName.String
                }</span>

                <span class="cov0" title="0">votes = append(votes, map[string]interface{}{
                        "id":          vote.ID,
                        "title":       vote.Title,
                        "description": vote.Description.String,
                        "type":        vote.Type,
                        "status":      vote.Status,
                        "startsAt":    vote.StartsAt,
                        "endsAt":      vote.EndsAt,
                        "createdBy":   createdByName,
                        "createdAt":   vote.CreatedAt,
                        "options":     options,
                        "totalVotes":  totalVotes,
                        "userVoted":   vote.UserVoted == 1,
                })</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    votes,
                "count":   len(votes),
        })</span>
}

// GetVoteResults retrieves completed votes for a chama
func GetVoteResults(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get completed votes (status = 'completed' or ends_at &lt; now)
        <span class="cov0" title="0">rows, err := db.(*sql.DB).Query(`
                SELECT v.id, v.title, v.description, v.type, v.status, v.starts_at, v.ends_at, v.created_by, v.created_at,
                       u.first_name, u.last_name,
                       CASE WHEN uv.id IS NOT NULL THEN 1 ELSE 0 END as user_voted
                FROM votes v
                LEFT JOIN users u ON v.created_by = u.id
                LEFT JOIN user_votes uv ON v.id = uv.vote_id AND uv.user_id = ?
                WHERE v.chama_id = ? AND (v.status = 'completed' OR v.ends_at &lt;= datetime('now'))
                ORDER BY v.created_at DESC
        `, userID, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve vote results: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var votes []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var vote struct {
                        ID          string
                        Title       string
                        Description sql.NullString
                        Type        string
                        Status      string
                        StartsAt    string
                        EndsAt      string
                        CreatedBy   string
                        CreatedAt   string
                        FirstName   sql.NullString
                        LastName    sql.NullString
                        UserVoted   int
                }

                err := rows.Scan(&amp;vote.ID, &amp;vote.Title, &amp;vote.Description, &amp;vote.Type, &amp;vote.Status,
                        &amp;vote.StartsAt, &amp;vote.EndsAt, &amp;vote.CreatedBy, &amp;vote.CreatedAt,
                        &amp;vote.FirstName, &amp;vote.LastName, &amp;vote.UserVoted)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get vote options with results
                <span class="cov0" title="0">optionRows, err := db.(*sql.DB).Query(`
                        SELECT id, option_text, vote_count
                        FROM vote_options
                        WHERE vote_id = ?
                        ORDER BY vote_count DESC, id
                `, vote.ID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var options []map[string]interface{}
                totalVotes := 0
                for optionRows.Next() </span><span class="cov0" title="0">{
                        var option struct {
                                ID        string
                                Text      string
                                VoteCount int
                        }
                        if err := optionRows.Scan(&amp;option.ID, &amp;option.Text, &amp;option.VoteCount); err == nil </span><span class="cov0" title="0">{
                                options = append(options, map[string]interface{}{
                                        "id":        option.ID,
                                        "text":      option.Text,
                                        "voteCount": option.VoteCount,
                                })
                                totalVotes += option.VoteCount
                        }</span>
                }
                <span class="cov0" title="0">optionRows.Close()

                createdByName := "Unknown"
                if vote.FirstName.Valid &amp;&amp; vote.LastName.Valid </span><span class="cov0" title="0">{
                        createdByName = vote.FirstName.String + " " + vote.LastName.String
                }</span>

                // Determine result
                <span class="cov0" title="0">result := "pending"
                if len(options) &gt; 0 &amp;&amp; totalVotes &gt; 0 </span><span class="cov0" title="0">{
                        // Simple majority wins - options[0] is already map[string]interface{}
                        firstOption := options[0]
                        if firstOptionVotes, ok := firstOption["voteCount"].(int); ok &amp;&amp; firstOptionVotes &gt; totalVotes/2 </span><span class="cov0" title="0">{
                                result = "passed"
                        }</span> else<span class="cov0" title="0"> {
                                result = "failed"
                        }</span>
                }

                <span class="cov0" title="0">votes = append(votes, map[string]interface{}{
                        "id":          vote.ID,
                        "title":       vote.Title,
                        "description": vote.Description.String,
                        "type":        vote.Type,
                        "status":      vote.Status,
                        "startsAt":    vote.StartsAt,
                        "endsAt":      vote.EndsAt,
                        "createdBy":   createdByName,
                        "createdAt":   vote.CreatedAt,
                        "options":     options,
                        "totalVotes":  totalVotes,
                        "userVoted":   vote.UserVoted == 1,
                        "result":      result,
                })</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    votes,
                "count":   len(votes),
        })</span>
}

// CastVoteOnItem allows a user to cast a vote on a specific vote item
func CastVoteOnItem(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        voteID := c.Param("voteId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" || voteID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID and Vote ID are required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                OptionID string `json:"optionId" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if vote exists and is active
        <span class="cov0" title="0">var voteStatus string
        var voteEndsAt string
        err := db.(*sql.DB).QueryRow(`
                SELECT status, ends_at FROM votes
                WHERE id = ? AND chama_id = ?
        `, voteID, chamaID).Scan(&amp;voteStatus, &amp;voteEndsAt)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Vote not found",
                })
                return
        }</span>

        <span class="cov0" title="0">if voteStatus != "active" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Vote is not active",
                })
                return
        }</span>

        // Check if vote has ended
        <span class="cov0" title="0">endsAt, err := time.Parse("2006-01-02 15:04:05", voteEndsAt)
        if err == nil &amp;&amp; time.Now().After(endsAt) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Vote has ended",
                })
                return
        }</span>

        // Check if user has already voted
        <span class="cov0" title="0">var existingVote string
        err = db.(*sql.DB).QueryRow(`
                SELECT id FROM user_votes
                WHERE vote_id = ? AND user_id = ?
        `, voteID, userID).Scan(&amp;existingVote)
        if existingVote != "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "You have already voted on this item",
                })
                return
        }</span>

        // Verify option exists for this vote
        <span class="cov0" title="0">var optionExists string
        err = db.(*sql.DB).QueryRow(`
                SELECT id FROM vote_options
                WHERE id = ? AND vote_id = ?
        `, req.OptionID, voteID).Scan(&amp;optionExists)
        if optionExists == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid vote option",
                })
                return
        }</span>

        // Cast the vote
        <span class="cov0" title="0">userVoteID := fmt.Sprintf("uv-%d", time.Now().UnixNano())
        _, err = db.(*sql.DB).Exec(`
                INSERT INTO user_votes (id, vote_id, user_id, option_id, created_at)
                VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
        `, userVoteID, voteID, userID, req.OptionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to cast vote: " + err.Error(),
                })
                return
        }</span>

        // Update vote count
        <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(`
                UPDATE vote_options
                SET vote_count = vote_count + 1
                WHERE id = ?
        `, req.OptionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update vote count: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Vote cast successfully",
                "data": map[string]interface{}{
                        "voteId":     voteID,
                        "optionId":   req.OptionID,
                        "userVoteId": userVoteID,
                },
        })</span>
}

// CreateRoleEscalationVote creates a role escalation vote
func CreateRoleEscalationVote(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                CandidateID   string `json:"candidateId" binding:"required"`
                RequestedRole string `json:"requestedRole" binding:"required"`
                Justification string `json:"justification"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get candidate name
        <span class="cov0" title="0">var candidateName string
        err := db.(*sql.DB).QueryRow(`
                SELECT first_name || ' ' || last_name FROM users WHERE id = ?
        `, req.CandidateID).Scan(&amp;candidateName)
        if err != nil </span><span class="cov0" title="0">{
                candidateName = "Unknown Candidate"
        }</span>

        // Create role escalation vote
        <span class="cov0" title="0">voteID := fmt.Sprintf("vote-%d", time.Now().UnixNano())
        title := fmt.Sprintf("Role Escalation: %s for %s", candidateName, req.RequestedRole)
        description := fmt.Sprintf("Vote to change %s's role to %s. Justification: %s", candidateName, req.RequestedRole, req.Justification)
        endsAt := time.Now().Add(7 * 24 * time.Hour) // 7 days

        _, err = db.(*sql.DB).Exec(`
                INSERT INTO votes (id, chama_id, title, description, type, status, ends_at, created_by, created_at)
                VALUES (?, ?, ?, ?, 'Election / Voting', 'active', ?, ?, CURRENT_TIMESTAMP)
        `, voteID, chamaID, title, description, endsAt, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create role escalation vote: " + err.Error(),
                })
                return
        }</span>

        // Create vote options (Yes/No)
        <span class="cov0" title="0">yesOptionID := fmt.Sprintf("option-%d-yes", time.Now().UnixNano())
        noOptionID := fmt.Sprintf("option-%d-no", time.Now().UnixNano())

        _, err = db.(*sql.DB).Exec(`
                INSERT INTO vote_options (id, vote_id, option_text, vote_count) VALUES
                (?, ?, 'Yes - Approve role change', 0),
                (?, ?, 'No - Reject role change', 0)
        `, yesOptionID, voteID, noOptionID, voteID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create vote options: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Role escalation vote created successfully",
                "data": map[string]interface{}{
                        "id":            voteID,
                        "chamaId":       chamaID,
                        "candidateId":   req.CandidateID,
                        "candidateName": candidateName,
                        "requestedRole": req.RequestedRole,
                        "title":         title,
                        "description":   description,
                        "endsAt":        endsAt.Format(time.RFC3339),
                        "createdBy":     userID,
                },
        })</span>
}

// GetVoteDetails retrieves details for a specific vote
func GetVoteDetails(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("userID")
        chamaID := c.Param("id")
        voteID := c.Param("voteId")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">if chamaID == "" || voteID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Chama ID and Vote ID are required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Get vote details
        <span class="cov0" title="0">var vote struct {
                ID          string
                Title       string
                Description sql.NullString
                Type        string
                Status      string
                StartsAt    string
                EndsAt      string
                CreatedBy   string
                CreatedAt   string
                FirstName   sql.NullString
                LastName    sql.NullString
                UserVoted   int
        }

        err := db.(*sql.DB).QueryRow(`
                SELECT v.id, v.title, v.description, v.type, v.status, v.starts_at, v.ends_at, v.created_by, v.created_at,
                       u.first_name, u.last_name,
                       CASE WHEN uv.id IS NOT NULL THEN 1 ELSE 0 END as user_voted
                FROM votes v
                LEFT JOIN users u ON v.created_by = u.id
                LEFT JOIN user_votes uv ON v.id = uv.vote_id AND uv.user_id = ?
                WHERE v.id = ? AND v.chama_id = ?
        `, userID, voteID, chamaID).Scan(&amp;vote.ID, &amp;vote.Title, &amp;vote.Description, &amp;vote.Type, &amp;vote.Status,
                &amp;vote.StartsAt, &amp;vote.EndsAt, &amp;vote.CreatedBy, &amp;vote.CreatedAt,
                &amp;vote.FirstName, &amp;vote.LastName, &amp;vote.UserVoted)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Vote not found",
                })
                return
        }</span>

        // Get vote options
        <span class="cov0" title="0">optionRows, err := db.(*sql.DB).Query(`
                SELECT id, option_text, vote_count
                FROM vote_options
                WHERE vote_id = ?
                ORDER BY id
        `, vote.ID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve vote options",
                })
                return
        }</span>
        <span class="cov0" title="0">defer optionRows.Close()

        var options []map[string]interface{}
        totalVotes := 0
        for optionRows.Next() </span><span class="cov0" title="0">{
                var option struct {
                        ID        string
                        Text      string
                        VoteCount int
                }
                if err := optionRows.Scan(&amp;option.ID, &amp;option.Text, &amp;option.VoteCount); err == nil </span><span class="cov0" title="0">{
                        options = append(options, map[string]interface{}{
                                "id":        option.ID,
                                "text":      option.Text,
                                "voteCount": option.VoteCount,
                        })
                        totalVotes += option.VoteCount
                }</span>
        }

        <span class="cov0" title="0">createdByName := "Unknown"
        if vote.FirstName.Valid &amp;&amp; vote.LastName.Valid </span><span class="cov0" title="0">{
                createdByName = vote.FirstName.String + " " + vote.LastName.String
        }</span>

        // Check if vote is still active
        <span class="cov0" title="0">endsAt, _ := time.Parse("2006-01-02 15:04:05", vote.EndsAt)
        isActive := vote.Status == "active" &amp;&amp; time.Now().Before(endsAt)

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": map[string]interface{}{
                        "id":          vote.ID,
                        "title":       vote.Title,
                        "description": vote.Description.String,
                        "type":        vote.Type,
                        "status":      vote.Status,
                        "startsAt":    vote.StartsAt,
                        "endsAt":      vote.EndsAt,
                        "createdBy":   createdByName,
                        "createdAt":   vote.CreatedAt,
                        "options":     options,
                        "totalVotes":  totalVotes,
                        "userVoted":   vote.UserVoted == 1,
                        "isActive":    isActive,
                },
        })</span>
}

// Helper function for min
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "log"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"
        "vaultke-backend/internal/config"
        "vaultke-backend/internal/models"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// Wallet handlers
func GetWallets(c *gin.Context) <span class="cov8" title="1">{
        // Get user ID from context
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov8" title="1">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create wallet service
        <span class="cov8" title="1">walletService := services.NewWalletService(db.(*sql.DB))

        // Get user's wallets
        wallets, err := walletService.GetWalletsByOwner(userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get wallets: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve wallets",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    wallets,
        })</span>
}

func GetWalletBalance(c *gin.Context) <span class="cov8" title="1">{
        // Get user ID from context
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov8" title="1">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create wallet service
        <span class="cov8" title="1">walletService := services.NewWalletService(db.(*sql.DB))

        // Get user's personal wallet
        wallet, err := walletService.GetWalletByOwnerAndType(userID.(string), models.WalletTypePersonal)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get user wallet: %v", err)
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Wallet not found",
                })
                return
        }</span>

        // Recalculate balance from transactions to ensure accuracy
        <span class="cov8" title="1">var calculatedBalance float64
        balanceQuery := `
                SELECT COALESCE(SUM(
                        CASE
                                WHEN type = 'deposit' THEN amount
                                WHEN type = 'withdrawal' THEN -amount
                                WHEN type = 'transfer' AND to_wallet_id = ? THEN amount
                                WHEN type = 'transfer' AND from_wallet_id = ? THEN -amount
                                ELSE 0
                        END
                ), 0) as balance
                FROM transactions
                WHERE (to_wallet_id = ? OR from_wallet_id = ?)
                AND status = 'completed'
        `

        err = db.(*sql.DB).QueryRow(balanceQuery, wallet.ID, wallet.ID, wallet.ID, wallet.ID).Scan(&amp;calculatedBalance)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to calculate balance from transactions: %v", err)
                // Fall back to stored balance
                calculatedBalance = wallet.Balance
        }</span>

        // Update stored balance if different
        <span class="cov8" title="1">if calculatedBalance != wallet.Balance </span><span class="cov8" title="1">{
                log.Printf("Updating wallet balance from %.2f to %.2f", wallet.Balance, calculatedBalance)
                _, err = db.(*sql.DB).Exec("UPDATE wallets SET balance = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?", calculatedBalance, wallet.ID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to update wallet balance: %v", err)
                }</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data": gin.H{
                        "balance":  calculatedBalance,
                        "currency": wallet.Currency,
                        "walletId": wallet.ID,
                },
        })</span>
}

func GetWallet(c *gin.Context) <span class="cov8" title="1">{
        walletID := c.Param("id")
        if walletID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Wallet ID is required",
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov8" title="1">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov8" title="1">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create wallet service
        <span class="cov8" title="1">walletService := services.NewWalletService(db.(*sql.DB))

        // Get wallet
        wallet, err := walletService.GetWalletByID(walletID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to get wallet: %v", err)
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Wallet not found",
                })
                return
        }</span>

        // Check if user owns this wallet
        <span class="cov8" title="1">if wallet.OwnerID != userID.(string) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Access denied",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    wallet,
        })</span>
}

func GetWalletTransactions(c *gin.Context) <span class="cov8" title="1">{
        walletID := c.Param("id")
        if walletID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Wallet ID is required",
                })
                return
        }</span>

        // Get user ID from context
        <span class="cov8" title="1">userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov8" title="1">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Parse pagination parameters
        <span class="cov8" title="1">limit := 50
        offset := 0
        if limitStr := c.Query("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 &amp;&amp; l &lt;= 100 </span><span class="cov8" title="1">{
                        limit = l
                }</span>
        }
        <span class="cov8" title="1">if offsetStr := c.Query("offset"); offsetStr != "" </span><span class="cov8" title="1">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov8" title="1">{
                        offset = o
                }</span>
        }

        // Create wallet service
        <span class="cov8" title="1">walletService := services.NewWalletService(db.(*sql.DB))

        // Verify wallet ownership
        wallet, err := walletService.GetWalletByID(walletID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to get wallet: %v", err)
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Wallet not found",
                })
                return
        }</span>

        <span class="cov8" title="1">if wallet.OwnerID != userID.(string) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Access denied",
                })
                return
        }</span>

        // Get wallet transactions
        <span class="cov8" title="1">transactions, err := walletService.GetWalletTransactions(walletID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get wallet transactions: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve transactions",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    transactions,
                "meta": map[string]interface{}{
                        "limit":  limit,
                        "offset": offset,
                        "count":  len(transactions),
                },
        })</span>
}

func TransferMoney(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Transfer money endpoint - coming soon",
        })
}</span>

func DepositMoney(c *gin.Context) <span class="cov8" title="1">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Parse request body with enhanced validation
        <span class="cov8" title="1">var req struct {
                Amount        float64 `json:"amount" binding:"required" validate:"required,amount"`
                PaymentMethod string  `json:"paymentMethod" validate:"alphanumeric,max=50"`
                Reference     string  `json:"reference" validate:"max=100,no_sql_injection,no_xss"`
                Description   string  `json:"description" validate:"max=200,safe_text,no_sql_injection,no_xss"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Enhanced validation
        <span class="cov8" title="1">if req.Amount &lt;= 0 || req.Amount &gt; 10000000 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Amount must be between 1 and 10,000,000 KES",
                })
                return
        }</span>

        // For M-Pesa deposits, use real M-Pesa STK push
        <span class="cov8" title="1">if req.PaymentMethod == "mpesa" </span><span class="cov0" title="0">{
                // Get user's phone number
                db, exists := c.Get("db")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Database connection not available",
                        })
                        return
                }</span>

                <span class="cov0" title="0">var userPhone string
                err := db.(*sql.DB).QueryRow("SELECT phone FROM users WHERE id = ?", userID).Scan(&amp;userPhone)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "User phone number not found",
                        })
                        return
                }</span>

                // Convert phone number to M-Pesa format
                <span class="cov0" title="0">phoneNumber := userPhone
                if strings.HasPrefix(phoneNumber, "07") </span><span class="cov0" title="0">{
                        phoneNumber = "254" + phoneNumber[1:]
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(phoneNumber, "+254") </span><span class="cov0" title="0">{
                        phoneNumber = phoneNumber[1:]
                }</span>

                // Generate unique reference if not provided
                <span class="cov0" title="0">reference := req.Reference
                if reference == "" </span><span class="cov0" title="0">{
                        reference = fmt.Sprintf("DEP_%d_%s", time.Now().UnixNano(), userID.(string)[:8])
                }</span>

                // Create M-Pesa transaction request
                <span class="cov0" title="0">mpesaReq := models.MpesaTransaction{
                        PhoneNumber:      phoneNumber,
                        Amount:           req.Amount,
                        AccountReference: reference,
                        TransactionDesc:  req.Description,
                }

                if mpesaReq.TransactionDesc == "" </span><span class="cov0" title="0">{
                        mpesaReq.TransactionDesc = "Wallet Deposit"
                }</span>

                // Get configuration
                <span class="cov0" title="0">cfg, exists := c.Get("config")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Configuration not available",
                        })
                        return
                }</span>

                // Create M-Pesa service
                <span class="cov0" title="0">mpesaService := services.NewMpesaService(db.(*sql.DB), cfg.(*config.Config))

                // Create pending transaction record with proper reference
                transactionID, err := createPendingMpesaTransaction(db.(*sql.DB), &amp;mpesaReq, userID.(string), reference)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to create pending transaction: %v", err)
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to create transaction record",
                        })
                        return
                }</span>

                // Initiate STK push
                <span class="cov0" title="0">stkResponse, err := mpesaService.InitiateSTKPush(&amp;mpesaReq)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("STK Push failed: %v", err)

                        // Check if development mode is enabled for mock success
                        developmentMode := os.Getenv("DEVELOPMENT_MODE") == "true"
                        mockSuccess := c.Query("mock_success") == "true" // Allow override via query param

                        if developmentMode || mockSuccess </span><span class="cov0" title="0">{
                                log.Printf("Development mode enabled - creating mock successful transaction...")

                                // Simulate successful transaction for development
                                mockTransactionID := fmt.Sprintf("DEV_MOCK_%d", time.Now().UnixNano())

                                // Update the pending transaction to completed
                                _, err = db.(*sql.DB).Exec(`
                                        UPDATE transactions
                                        SET status = 'completed', reference = ?, updated_at = CURRENT_TIMESTAMP
                                        WHERE id = ?
                                `, mockTransactionID, transactionID)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Failed to update mock transaction: %v", err)
                                }</span>

                                // Update wallet balance
                                <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(`
                                        UPDATE wallets
                                        SET balance = balance + ?, updated_at = CURRENT_TIMESTAMP
                                        WHERE id = ?
                                `, req.Amount, "wallet-personal-"+userID.(string))
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Failed to update wallet balance: %v", err)
                                }</span>

                                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                                        "success": true,
                                        "message": "Deposit completed successfully (Development Mock)",
                                        "data": map[string]interface{}{
                                                "id":            transactionID,
                                                "amount":        req.Amount,
                                                "paymentMethod": req.PaymentMethod,
                                                "reference":     mockTransactionID,
                                                "status":        "completed",
                                                "mock":          true,
                                                "development":   true,
                                        },
                                })
                                return</span>
                        }

                        // Production mode: Mark transaction as failed with proper error details
                        <span class="cov0" title="0">failureReason := fmt.Sprintf("M-Pesa STK Push failed: %v", err)

                        // Update transaction status to failed
                        updateErr := updateTransactionStatus(db.(*sql.DB), transactionID, models.TransactionStatusFailed)
                        if updateErr != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to update transaction status to failed: %v", updateErr)
                        }</span>

                        // Update additional failure details
                        <span class="cov0" title="0">_, updateErr = db.(*sql.DB).Exec(`
                                UPDATE transactions
                                SET reference = ?,
                                    description = CONCAT(description, ' - ', ?),
                                    updated_at = CURRENT_TIMESTAMP
                                WHERE id = ?
                        `, fmt.Sprintf("FAILED_%d", time.Now().UnixNano()), failureReason, transactionID)

                        if updateErr != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to update transaction failure details: %v", updateErr)
                        }</span>

                        // Return proper error response
                        <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to initiate M-Pesa payment: STK push failed",
                                "details": err.Error(),
                                "data": map[string]interface{}{
                                        "transactionId": transactionID,
                                        "status":        "failed",
                                        "reason":        failureReason,
                                },
                        })
                        return</span>
                }

                // Update transaction with checkout request ID
                <span class="cov0" title="0">updateTransactionCheckoutRequestID(db.(*sql.DB), transactionID, stkResponse.CheckoutRequestID)

                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "message": "M-Pesa STK push initiated successfully",
                        "data": gin.H{
                                "id":                  transactionID,
                                "checkoutRequestId":   stkResponse.CheckoutRequestID,
                                "customerMessage":     stkResponse.CustomerMessage,
                                "merchantRequestId":   stkResponse.MerchantRequestID,
                                "responseDescription": stkResponse.ResponseDescription,
                                "phoneNumber":         phoneNumber,
                                "amount":              req.Amount,
                        },
                })
                return</span>
        }

        // Validate and sanitize string inputs
        <span class="cov8" title="1">if len(req.PaymentMethod) &gt; 50 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Payment method too long",
                })
                return
        }</span>

        <span class="cov8" title="1">if len(req.Reference) &gt; 100 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Reference too long",
                })
                return
        }</span>

        <span class="cov8" title="1">if len(req.Description) &gt; 200 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Description too long",
                })
                return
        }</span>

        // Sanitize inputs
        <span class="cov8" title="1">req.PaymentMethod = sanitizeInput(req.PaymentMethod)
        req.Reference = sanitizeInput(req.Reference)
        req.Description = sanitizeInput(req.Description)

        // Get database connection
        db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Start transaction
        <span class="cov8" title="1">tx, err := db.(*sql.DB).Begin()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to start transaction",
                })
                return
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Add to personal wallet
        _, err = tx.Exec(`
                UPDATE wallets
                SET balance = balance + ?, updated_at = CURRENT_TIMESTAMP
                WHERE owner_id = ? AND type = 'personal'
        `, req.Amount, userID)
        if err != nil </span><span class="cov0" title="0">{
                // If personal wallet doesn't exist, create it
                _, err = tx.Exec(`
                        INSERT INTO wallets (id, owner_id, type, balance, created_at, updated_at)
                        VALUES (?, ?, 'personal', ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                `, "wallet-personal-"+userID.(string), userID, req.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to update personal wallet",
                        })
                        return
                }</span>
        }

        // Record the transaction
        <span class="cov8" title="1">transactionID := fmt.Sprintf("txn-%d", time.Now().UnixNano())
        paymentMethod := req.PaymentMethod
        if paymentMethod == "" </span><span class="cov0" title="0">{
                paymentMethod = "simulation"
        }</span>

        <span class="cov8" title="1">description := req.Description
        if description == "" </span><span class="cov0" title="0">{
                description = fmt.Sprintf("Deposit via %s", paymentMethod)
        }</span>

        <span class="cov8" title="1">_, err = tx.Exec(`
                INSERT INTO transactions (
                        id, to_wallet_id, type, amount, currency, description,
                        reference, payment_method, status, initiated_by,
                        created_at, updated_at
                ) VALUES (?, ?, 'deposit', ?, 'KES', ?, ?, ?, 'completed', ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `, transactionID, "wallet-personal-"+userID.(string), req.Amount, description, req.Reference, paymentMethod, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to record transaction",
                })
                return
        }</span>

        // Commit transaction
        <span class="cov8" title="1">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to commit transaction",
                })
                return
        }</span>

        // Return success response
        <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Deposit completed successfully",
                "data": map[string]interface{}{
                        "id":            transactionID,
                        "amount":        req.Amount,
                        "paymentMethod": paymentMethod,
                        "reference":     req.Reference,
                        "description":   description,
                        "status":        "completed",
                        "depositedBy":   userID,
                        "createdAt":     time.Now().Format(time.RFC3339),
                },
        })</span>
}

func WithdrawMoney(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Withdraw money endpoint - coming soon",
        })
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package api

import (
        "database/sql"
        "fmt"
        "math"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

// Welfare handlers
func GetWelfareRequests(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">chamaID := c.Query("chamaId")
        if chamaID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "chamaId parameter is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if user is a member of the chama
        <span class="cov0" title="0">var membershipExists bool
        err := db.(*sql.DB).QueryRow(`
                SELECT EXISTS(
                        SELECT 1 FROM chama_members
                        WHERE chama_id = ? AND user_id = ? AND is_active = TRUE
                )
        `, chamaID, userID).Scan(&amp;membershipExists)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify chama membership",
                })
                return
        }</span>

        <span class="cov0" title="0">if !membershipExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Access denied. You are not a member of this chama.",
                })
                return
        }</span>

        // Check and close any completed welfare votes before loading data
        <span class="cov0" title="0">CheckAndCloseCompletedWelfareVotes(chamaID, db.(*sql.DB))

        // Get user ID from context for checking user votes
        currentUserID, _ := c.Get("userID")

        // Query welfare requests for the chama with vote information and beneficiary details
        rows, err := db.(*sql.DB).Query(`
                SELECT
                        wr.id, wr.chama_id, wr.requester_id, COALESCE(wr.beneficiary_id, wr.requester_id) as beneficiary_id,
                        wr.title, wr.description, wr.amount, wr.category, wr.urgency, wr.status,
                        wr.votes_for, wr.votes_against, wr.created_at, wr.updated_at,
                        u.first_name as requester_first_name, u.last_name as requester_last_name, u.email as requester_email,
                        b.first_name as beneficiary_first_name, b.last_name as beneficiary_last_name, b.email as beneficiary_email,
                        COALESCE(yes_votes.vote_count, 0) as actual_yes_votes,
                        COALESCE(no_votes.vote_count, 0) as actual_no_votes,
                        user_vote.option_text as user_vote_option
                FROM welfare_requests wr
                JOIN users u ON wr.requester_id = u.id
                LEFT JOIN users b ON COALESCE(wr.beneficiary_id, wr.requester_id) = b.id
                LEFT JOIN votes v ON v.chama_id = wr.chama_id AND v.title = 'Welfare Request: ' || wr.id AND v.type = 'welfare'
                LEFT JOIN vote_options yes_votes ON yes_votes.vote_id = v.id AND yes_votes.option_text = 'yes'
                LEFT JOIN vote_options no_votes ON no_votes.vote_id = v.id AND no_votes.option_text = 'no'
                LEFT JOIN user_votes uv ON uv.vote_id = v.id AND uv.user_id = ?
                LEFT JOIN vote_options user_vote ON user_vote.id = uv.option_id
                WHERE wr.chama_id = ?
                ORDER BY wr.created_at DESC
        `, currentUserID, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch welfare requests: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var welfareRequests []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var wr struct {
                        ID                   string    `json:"id"`
                        ChamaID              string    `json:"chamaId"`
                        RequesterID          string    `json:"requesterId"`
                        BeneficiaryID        string    `json:"beneficiaryId"`
                        Title                string    `json:"title"`
                        Description          string    `json:"description"`
                        Amount               float64   `json:"amount"`
                        Category             string    `json:"category"`
                        Urgency              string    `json:"urgency"`
                        Status               string    `json:"status"`
                        VotesFor             int       `json:"votesFor"`
                        VotesAgainst         int       `json:"votesAgainst"`
                        CreatedAt            time.Time `json:"createdAt"`
                        UpdatedAt            time.Time `json:"updatedAt"`
                        RequesterFirstName   string    `json:"requesterFirstName"`
                        RequesterLastName    string    `json:"requesterLastName"`
                        RequesterEmail       string    `json:"requesterEmail"`
                        BeneficiaryFirstName string    `json:"beneficiaryFirstName"`
                        BeneficiaryLastName  string    `json:"beneficiaryLastName"`
                        BeneficiaryEmail     string    `json:"beneficiaryEmail"`
                        ActualYesVotes       int       `json:"actualYesVotes"`
                        ActualNoVotes        int       `json:"actualNoVotes"`
                        UserVoteOption       *string   `json:"userVoteOption"` // nullable
                }

                err := rows.Scan(
                        &amp;wr.ID, &amp;wr.ChamaID, &amp;wr.RequesterID, &amp;wr.BeneficiaryID, &amp;wr.Title, &amp;wr.Description,
                        &amp;wr.Amount, &amp;wr.Category, &amp;wr.Urgency, &amp;wr.Status, &amp;wr.VotesFor,
                        &amp;wr.VotesAgainst, &amp;wr.CreatedAt, &amp;wr.UpdatedAt,
                        &amp;wr.RequesterFirstName, &amp;wr.RequesterLastName, &amp;wr.RequesterEmail,
                        &amp;wr.BeneficiaryFirstName, &amp;wr.BeneficiaryLastName, &amp;wr.BeneficiaryEmail,
                        &amp;wr.ActualYesVotes, &amp;wr.ActualNoVotes, &amp;wr.UserVoteOption,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid rows
                }

                // Use actual vote counts from voting tables, fallback to welfare_requests table
                <span class="cov0" title="0">actualYesVotes := wr.ActualYesVotes
                actualNoVotes := wr.ActualNoVotes
                if actualYesVotes == 0 &amp;&amp; actualNoVotes == 0 </span><span class="cov0" title="0">{
                        // Fallback to welfare_requests table if no votes exist yet
                        actualYesVotes = wr.VotesFor
                        actualNoVotes = wr.VotesAgainst
                }</span>

                // Determine user vote status
                <span class="cov0" title="0">var userVote interface{} = nil
                if wr.UserVoteOption != nil </span><span class="cov0" title="0">{
                        userVote = *wr.UserVoteOption // "yes" or "no"
                }</span>

                <span class="cov0" title="0">welfareMap := map[string]interface{}{
                        "id":            wr.ID,
                        "chamaId":       wr.ChamaID,
                        "requesterId":   wr.RequesterID,
                        "beneficiaryId": wr.BeneficiaryID,
                        "title":         wr.Title,
                        "description":   wr.Description,
                        "amount":        wr.Amount,
                        "category":      wr.Category,
                        "urgency":       wr.Urgency,
                        "status":        wr.Status,
                        "votesFor":      actualYesVotes,
                        "votesAgainst":  actualNoVotes,
                        "votes_for":     actualYesVotes, // Alternative field name for frontend compatibility
                        "votes_against": actualNoVotes,  // Alternative field name for frontend compatibility
                        "total_votes":   actualYesVotes + actualNoVotes,
                        "userVote":      userVote,
                        "votes": map[string]interface{}{
                                "yes":   actualYesVotes,
                                "no":    actualNoVotes,
                                "total": actualYesVotes + actualNoVotes,
                        },
                        "createdAt": wr.CreatedAt.Format(time.RFC3339),
                        "updatedAt": wr.UpdatedAt.Format(time.RFC3339),
                        "requester": map[string]interface{}{
                                "id":         wr.RequesterID,
                                "firstName":  wr.RequesterFirstName,
                                "lastName":   wr.RequesterLastName,
                                "email":      wr.RequesterEmail,
                                "fullName":   wr.RequesterFirstName + " " + wr.RequesterLastName,
                                "first_name": wr.RequesterFirstName, // Alternative field name
                                "last_name":  wr.RequesterLastName,  // Alternative field name
                        },
                        "beneficiary": map[string]interface{}{
                                "id":         wr.BeneficiaryID,
                                "firstName":  wr.BeneficiaryFirstName,
                                "lastName":   wr.BeneficiaryLastName,
                                "email":      wr.BeneficiaryEmail,
                                "fullName":   wr.BeneficiaryFirstName + " " + wr.BeneficiaryLastName,
                                "first_name": wr.BeneficiaryFirstName, // Alternative field name
                                "last_name":  wr.BeneficiaryLastName,  // Alternative field name
                        },
                }

                // Add contribution calculations for real-time progress
                welfareRequestFundID := fmt.Sprintf("fund-%s", wr.ID)
                var totalContributions float64
                var contributionCount int

                err = db.(*sql.DB).QueryRow(`
                        SELECT COALESCE(SUM(amount), 0), COUNT(*)
                        FROM welfare_contributions
                        WHERE welfare_fund_id = ?
                `, welfareRequestFundID).Scan(&amp;totalContributions, &amp;contributionCount)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with zero values
                        fmt.Printf("Error getting contributions for request %s: %v\n", wr.ID, err)
                        totalContributions = 0
                        contributionCount = 0
                }</span>

                // Add contribution data to the welfare map
                <span class="cov0" title="0">welfareMap["totalContributions"] = totalContributions
                welfareMap["contributionCount"] = contributionCount
                welfareMap["remainingAmount"] = math.Max(0, wr.Amount-totalContributions)
                welfareMap["progressPercentage"] = math.Min(100, (totalContributions/wr.Amount)*100)

                welfareRequests = append(welfareRequests, welfareMap)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    welfareRequests,
                "message": fmt.Sprintf("Found %d welfare requests", len(welfareRequests)),
                "meta": map[string]interface{}{
                        "total":   len(welfareRequests),
                        "chamaId": chamaID,
                },
        })</span>
}

func CreateWelfareRequest(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ChamaID       string  `json:"chamaId" binding:"required"`
                Title         string  `json:"title" binding:"required"`
                Description   string  `json:"description" binding:"required"`
                Amount        float64 `json:"amount" binding:"required"`
                Category      string  `json:"category" binding:"required"`
                Urgency       string  `json:"urgency" binding:"required"`
                BeneficiaryID *string `json:"beneficiaryId"` // Optional - defaults to requester if not provided
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Validate amount
        <span class="cov0" title="0">if req.Amount &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Amount must be greater than 0",
                })
                return
        }</span>

        // Validate urgency
        <span class="cov0" title="0">validUrgencies := map[string]bool{"low": true, "medium": true, "high": true, "emergency": true}
        if !validUrgencies[req.Urgency] </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Urgency must be one of: low, medium, high, emergency",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if user is a member of the chama
        <span class="cov0" title="0">var membershipExists bool
        err := db.(*sql.DB).QueryRow(`
                SELECT EXISTS(
                        SELECT 1 FROM chama_members
                        WHERE chama_id = ? AND user_id = ? AND is_active = TRUE
                )
        `, req.ChamaID, userID).Scan(&amp;membershipExists)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify chama membership",
                })
                return
        }</span>

        <span class="cov0" title="0">if !membershipExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Access denied. You are not a member of this chama.",
                })
                return
        }</span>

        // Determine beneficiary - defaults to requester if not specified
        <span class="cov0" title="0">beneficiaryID := userID
        if req.BeneficiaryID != nil &amp;&amp; *req.BeneficiaryID != "" </span><span class="cov0" title="0">{
                beneficiaryID = *req.BeneficiaryID
        }</span>

        // Generate welfare request ID
        <span class="cov0" title="0">welfareID := fmt.Sprintf("welfare-%d", time.Now().UnixNano())

        // Insert welfare request into database
        _, err = db.(*sql.DB).Exec(`
                INSERT INTO welfare_requests (
                        id, chama_id, requester_id, beneficiary_id, title, description, amount,
                        category, urgency, status, votes_for, votes_against,
                        created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', 0, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `, welfareID, req.ChamaID, userID, beneficiaryID, req.Title, req.Description, req.Amount, req.Category, req.Urgency)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create welfare request: " + err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Welfare request created successfully! Members will be notified to vote.",
                "data": map[string]interface{}{
                        "id":            welfareID,
                        "chamaId":       req.ChamaID,
                        "requesterId":   userID,
                        "beneficiaryId": beneficiaryID,
                        "title":         req.Title,
                        "description":   req.Description,
                        "amount":        req.Amount,
                        "category":      req.Category,
                        "urgency":       req.Urgency,
                        "status":        "pending",
                        "votesFor":      0,
                        "votesAgainst":  0,
                        "createdAt":     time.Now().Format(time.RFC3339),
                },
        })</span>
}

func GetWelfareRequest(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Get welfare request endpoint - coming soon",
        })
}</span>

func UpdateWelfareRequest(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Update welfare request endpoint - coming soon",
        })
}</span>

func DeleteWelfareRequest(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Delete welfare request endpoint - coming soon",
        })
}</span>

func VoteOnWelfareRequest(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get welfare request ID from URL parameter
        <span class="cov0" title="0">welfareID := c.Param("id")
        if welfareID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Welfare request ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Vote string `json:"vote" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Validate vote value
        <span class="cov0" title="0">if req.Vote != "yes" &amp;&amp; req.Vote != "no" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Vote must be 'yes' or 'no'",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if welfare request exists
        <span class="cov0" title="0">var welfareRequest struct {
                ID           string
                ChamaID      string
                RequesterID  string
                Status       string
                VotesFor     int
                VotesAgainst int
        }

        err := db.(*sql.DB).QueryRow(`
                SELECT id, chama_id, requester_id, status, votes_for, votes_against
                FROM welfare_requests
                WHERE id = ?
        `, welfareID).Scan(&amp;welfareRequest.ID, &amp;welfareRequest.ChamaID, &amp;welfareRequest.RequesterID, &amp;welfareRequest.Status, &amp;welfareRequest.VotesFor, &amp;welfareRequest.VotesAgainst)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Welfare request not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch welfare request: " + err.Error(),
                })
                return</span>
        }

        // Check if welfare request is still pending (can only vote on pending requests)
        <span class="cov0" title="0">if welfareRequest.Status != "pending" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Cannot vote on this welfare request. Status: " + welfareRequest.Status,
                })
                return
        }</span>

        // Check if there's already a vote for this welfare request
        <span class="cov0" title="0">var voteID string
        err = db.(*sql.DB).QueryRow(`
                SELECT id FROM votes
                WHERE chama_id = ? AND title = ? AND type = 'welfare'
        `, welfareRequest.ChamaID, "Welfare Request: "+welfareID).Scan(&amp;voteID)

        // If no vote exists, create one
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                voteID = fmt.Sprintf("vote-%d", time.Now().UnixNano())
                _, err = db.(*sql.DB).Exec(`
                        INSERT INTO votes (id, chama_id, title, description, type, status, ends_at, created_by, created_at)
                        VALUES (?, ?, ?, ?, 'welfare', 'active', datetime('now', '+7 days'), ?, CURRENT_TIMESTAMP)
                `, voteID, welfareRequest.ChamaID, "Welfare Request: "+welfareID, "Vote on welfare request", userID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to create vote: " + err.Error(),
                        })
                        return
                }</span>

                // Create vote options (Yes/No)
                <span class="cov0" title="0">yesOptionID := fmt.Sprintf("option-%d-yes", time.Now().UnixNano())
                noOptionID := fmt.Sprintf("option-%d-no", time.Now().UnixNano())

                _, err = db.(*sql.DB).Exec(`
                        INSERT INTO vote_options (id, vote_id, option_text, vote_count) VALUES
                        (?, ?, 'yes', 0),
                        (?, ?, 'no', 0)
                `, yesOptionID, voteID, noOptionID, voteID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to create vote options: " + err.Error(),
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to check existing vote: " + err.Error(),
                })
                return
        }</span>

        // Get the appropriate option ID
        <span class="cov0" title="0">var optionID string
        err = db.(*sql.DB).QueryRow(`
                SELECT id FROM vote_options
                WHERE vote_id = ? AND option_text = ?
        `, voteID, req.Vote).Scan(&amp;optionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to find vote option: " + err.Error(),
                })
                return
        }</span>

        // Check if user has already voted
        <span class="cov0" title="0">var existingUserVote string
        err = db.(*sql.DB).QueryRow(`
                SELECT id FROM user_votes
                WHERE vote_id = ? AND user_id = ?
        `, voteID, userID).Scan(&amp;existingUserVote)

        if existingUserVote != "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "You have already voted on this welfare request",
                })
                return
        }</span>

        // Insert the user vote
        <span class="cov0" title="0">userVoteID := fmt.Sprintf("uv-%d", time.Now().UnixNano())
        _, err = db.(*sql.DB).Exec(`
                INSERT INTO user_votes (id, vote_id, user_id, option_id, created_at)
                VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
        `, userVoteID, voteID, userID, optionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to record vote: " + err.Error(),
                })
                return
        }</span>

        // Update vote count in vote_options
        <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(`
                UPDATE vote_options
                SET vote_count = vote_count + 1
                WHERE id = ?
        `, optionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update vote count: " + err.Error(),
                })
                return
        }</span>

        // Get updated vote counts from vote_options
        <span class="cov0" title="0">var yesVotes, noVotes int
        err = db.(*sql.DB).QueryRow(`
                SELECT
                        COALESCE(SUM(CASE WHEN option_text = 'yes' THEN vote_count ELSE 0 END), 0) as yes_votes,
                        COALESCE(SUM(CASE WHEN option_text = 'no' THEN vote_count ELSE 0 END), 0) as no_votes
                FROM vote_options
                WHERE vote_id = ?
        `, voteID).Scan(&amp;yesVotes, &amp;noVotes)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get vote counts: " + err.Error(),
                })
                return
        }</span>

        // Update vote counts in welfare_requests table for consistency
        <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(`
                UPDATE welfare_requests
                SET votes_for = ?, votes_against = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
        `, yesVotes, noVotes, welfareID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to update welfare request vote counts: " + err.Error(),
                })
                return
        }</span>

        // Check if all members have voted and close voting if necessary
        <span class="cov0" title="0">var totalMembers int
        err = db.(*sql.DB).QueryRow(`
                SELECT COUNT(*) FROM chama_members
                WHERE chama_id = ? AND is_active = TRUE
        `, welfareRequest.ChamaID).Scan(&amp;totalMembers)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the response
                fmt.Printf("Failed to get total chama members: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                totalVotes := yesVotes + noVotes

                // Check if all members have voted
                if totalVotes &gt;= totalMembers </span><span class="cov0" title="0">{
                        // All members have voted, determine the result
                        var newStatus string
                        var statusMessage string

                        // Simple majority rule: more than 50% yes votes = approved
                        if yesVotes &gt; noVotes </span><span class="cov0" title="0">{
                                newStatus = "approved"
                                statusMessage = fmt.Sprintf("Approved by majority vote (%d yes, %d no)", yesVotes, noVotes)
                        }</span> else<span class="cov0" title="0"> {
                                newStatus = "rejected"
                                statusMessage = fmt.Sprintf("Rejected by majority vote (%d yes, %d no)", yesVotes, noVotes)
                        }</span>

                        // Update welfare request status
                        <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(`
                                UPDATE welfare_requests
                                SET status = ?, updated_at = CURRENT_TIMESTAMP
                                WHERE id = ?
                        `, newStatus, welfareID)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to update welfare request status: %v\n", err)
                        }</span>

                        // Close the vote
                        <span class="cov0" title="0">_, err = db.(*sql.DB).Exec(`
                                UPDATE votes
                                SET status = 'completed', ends_at = CURRENT_TIMESTAMP
                                WHERE id = ?
                        `, voteID)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to close vote: %v\n", err)
                        }</span>

                        // Create notification for requester about the result
                        <span class="cov0" title="0">notificationID := fmt.Sprintf("notif-%d", time.Now().UnixNano())
                        _, err = db.(*sql.DB).Exec(`
                                INSERT INTO notifications (
                                        id, user_id, type, title, message, data,
                                        is_read, created_at, updated_at
                                ) VALUES (?, ?, 'welfare_vote_result', ?, ?, ?, false, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                        `, notificationID, welfareRequest.RequesterID,
                                "Welfare Vote Complete",
                                statusMessage,
                                fmt.Sprintf(`{"welfare_request_id": "%s", "status": "%s", "yes_votes": %d, "no_votes": %d}`,
                                        welfareID, newStatus, yesVotes, noVotes))
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to create vote result notification: %v\n", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Vote recorded successfully",
                "data": map[string]interface{}{
                        "voteId":       voteID,
                        "userVoteId":   userVoteID,
                        "vote":         req.Vote,
                        "votesFor":     yesVotes,
                        "votesAgainst": noVotes,
                        "totalVotes":   yesVotes + noVotes,
                        "status":       "recorded",
                },
        })</span>
}

// ContributeToWelfare handles welfare contributions
func ContributeToWelfare(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                WelfareRequestID string  `json:"welfareRequestId" binding:"required"`
                Amount           float64 `json:"amount" binding:"required"`
                Message          string  `json:"message"`
                ChamaID          string  `json:"chamaId" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Validate amount
        <span class="cov0" title="0">if req.Amount &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Contribution amount must be greater than 0",
                })
                return
        }</span>

        <span class="cov0" title="0">if req.Amount &lt; 10 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Minimum contribution amount is KES 10",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Check if user is a member of the chama
        <span class="cov0" title="0">var membershipExists bool
        err := db.(*sql.DB).QueryRow(`
                SELECT EXISTS(
                        SELECT 1 FROM chama_members
                        WHERE chama_id = ? AND user_id = ? AND is_active = TRUE
                )
        `, req.ChamaID, userID).Scan(&amp;membershipExists)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to verify chama membership",
                })
                return
        }</span>

        <span class="cov0" title="0">if !membershipExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{
                        "success": false,
                        "error":   "Access denied. You are not a member of this chama.",
                })
                return
        }</span>

        // Check if welfare request exists and is approved
        <span class="cov0" title="0">var welfareRequest struct {
                ID            string
                ChamaID       string
                Status        string
                Amount        float64
                Title         string
                BeneficiaryID string
        }

        err = db.(*sql.DB).QueryRow(`
                SELECT id, chama_id, status, amount, title, COALESCE(beneficiary_id, requester_id) as beneficiary_id
                FROM welfare_requests
                WHERE id = ? AND chama_id = ?
        `, req.WelfareRequestID, req.ChamaID).Scan(
                &amp;welfareRequest.ID, &amp;welfareRequest.ChamaID, &amp;welfareRequest.Status, &amp;welfareRequest.Amount,
                &amp;welfareRequest.Title, &amp;welfareRequest.BeneficiaryID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Welfare request not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch welfare request: " + err.Error(),
                })
                return</span>
        }

        // Only allow contributions to approved welfare requests
        <span class="cov0" title="0">if welfareRequest.Status != "approved" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Can only contribute to approved welfare requests. Current status: " + welfareRequest.Status,
                })
                return
        }</span>

        // Allow self-contributions - users can contribute to their own welfare requests
        // This enables users to partially fund their own requests or show commitment

        // Create or get welfare fund for this request
        <span class="cov0" title="0">welfareRequestFundID := fmt.Sprintf("fund-%s", req.WelfareRequestID)

        // Check if welfare fund exists for this request
        var existingFundID string
        err = db.(*sql.DB).QueryRow(`
                SELECT id FROM welfare_funds WHERE id = ?
        `, welfareRequestFundID).Scan(&amp;existingFundID)

        // Create welfare fund if it doesn't exist
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                _, err = db.(*sql.DB).Exec(`
                        INSERT INTO welfare_funds (
                                id, chama_id, name, description, purpose, status, beneficiary_id, created_by, created_at, updated_at
                        ) VALUES (?, ?, ?, ?, ?, 'active', ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                `, welfareRequestFundID, welfareRequest.ChamaID,
                        "Fund for: "+welfareRequest.Title,
                        "Welfare fund for welfare request: "+req.WelfareRequestID,
                        "emergency", welfareRequest.BeneficiaryID, userID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to create welfare fund: " + err.Error(),
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to check welfare fund: " + err.Error(),
                })
                return
        }</span>

        // Generate contribution ID
        <span class="cov0" title="0">contributionID := fmt.Sprintf("contrib-%d", time.Now().UnixNano())

        // Insert contribution into database
        _, err = db.(*sql.DB).Exec(`
                INSERT INTO welfare_contributions (
                        id, welfare_fund_id, user_id, amount, payment_method, contributed_at
                ) VALUES (?, ?, ?, ?, 'mobile_money', CURRENT_TIMESTAMP)
        `, contributionID, welfareRequestFundID, userID, req.Amount)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to record contribution: " + err.Error(),
                })
                return
        }</span>

        // Get total contributions for this welfare request
        <span class="cov0" title="0">var totalContributions float64
        err = db.(*sql.DB).QueryRow(`
                SELECT COALESCE(SUM(amount), 0)
                FROM welfare_contributions
                WHERE welfare_fund_id = ?
        `, welfareRequestFundID).Scan(&amp;totalContributions)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the response
                fmt.Printf("Failed to calculate total contributions: %v\n", err)
                totalContributions = req.Amount // fallback
        }</span>

        // Create notification for beneficiary
        <span class="cov0" title="0">notificationID := fmt.Sprintf("notif-%d", time.Now().UnixNano())
        _, err = db.(*sql.DB).Exec(`
                INSERT INTO notifications (
                        id, user_id, type, title, message, data,
                        is_read, created_at, updated_at
                ) VALUES (?, ?, 'welfare_contribution', ?, ?, ?, false, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `, notificationID, welfareRequest.BeneficiaryID,
                "New Welfare Contribution",
                fmt.Sprintf("You received a contribution of KES %.2f for your welfare request", req.Amount),
                fmt.Sprintf(`{"welfare_request_id": "%s", "contribution_id": "%s", "amount": %.2f}`,
                        req.WelfareRequestID, contributionID, req.Amount))
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the response
                fmt.Printf("Failed to create contribution notification: %v\n", err)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "success": true,
                "message": "Contribution recorded successfully",
                "data": map[string]interface{}{
                        "contributionId":     contributionID,
                        "welfareRequestId":   req.WelfareRequestID,
                        "amount":             req.Amount,
                        "message":            req.Message,
                        "totalContributions": totalContributions,
                        "status":             "completed",
                        "createdAt":          time.Now().Format(time.RFC3339),
                },
        })</span>
}

// GetWelfareContributions gets all contributions for a specific welfare request
func GetWelfareContributions(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        _, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">welfareRequestID := c.Param("id")
        if welfareRequestID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Welfare request ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Query contributions for the welfare request
        // Get welfare fund ID for this request
        <span class="cov0" title="0">welfareRequestFundID := fmt.Sprintf("fund-%s", welfareRequestID)

        rows, err := db.(*sql.DB).Query(`
                SELECT
                        wc.id, wc.amount, COALESCE(wc.message, '') as message, 'completed' as status, wc.contributed_at,
                        u.first_name, u.last_name, u.email
                FROM welfare_contributions wc
                JOIN users u ON wc.user_id = u.id
                WHERE wc.welfare_fund_id = ?
                ORDER BY wc.contributed_at DESC
        `, welfareRequestFundID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to fetch contributions: " + err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var contributions []map[string]interface{}
        var totalAmount float64

        for rows.Next() </span><span class="cov0" title="0">{
                var contrib struct {
                        ID                   string    `json:"id"`
                        Amount               float64   `json:"amount"`
                        Message              string    `json:"message"`
                        Status               string    `json:"status"`
                        CreatedAt            time.Time `json:"createdAt"`
                        ContributorFirstName string    `json:"contributorFirstName"`
                        ContributorLastName  string    `json:"contributorLastName"`
                        ContributorEmail     string    `json:"contributorEmail"`
                }

                err := rows.Scan(
                        &amp;contrib.ID, &amp;contrib.Amount, &amp;contrib.Message, &amp;contrib.Status, &amp;contrib.CreatedAt,
                        &amp;contrib.ContributorFirstName, &amp;contrib.ContributorLastName, &amp;contrib.ContributorEmail,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid rows
                }

                <span class="cov0" title="0">totalAmount += contrib.Amount

                contribution := map[string]interface{}{
                        "id":        contrib.ID,
                        "amount":    contrib.Amount,
                        "message":   contrib.Message,
                        "status":    contrib.Status,
                        "createdAt": contrib.CreatedAt.Format(time.RFC3339),
                        "contributor": map[string]interface{}{
                                "firstName": contrib.ContributorFirstName,
                                "lastName":  contrib.ContributorLastName,
                                "email":     contrib.ContributorEmail,
                                "fullName":  contrib.ContributorFirstName + " " + contrib.ContributorLastName,
                        },
                }

                contributions = append(contributions, contribution)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    contributions,
                "meta": map[string]interface{}{
                        "totalContributions": totalAmount,
                        "contributionCount":  len(contributions),
                        "welfareRequestId":   welfareRequestID,
                },
        })</span>
}

// CheckAndCloseCompletedWelfareVotes checks for welfare votes where all members have voted
// and automatically closes them with the appropriate status
func CheckAndCloseCompletedWelfareVotes(chamaID string, db *sql.DB) <span class="cov0" title="0">{
        // Get all pending welfare requests for this chama
        rows, err := db.Query(`
                SELECT wr.id, wr.chama_id, wr.requester_id, wr.status, v.id as vote_id
                FROM welfare_requests wr
                LEFT JOIN votes v ON v.chama_id = wr.chama_id AND v.title = 'Welfare Request: ' || wr.id AND v.type = 'welfare'
                WHERE wr.chama_id = ? AND wr.status = 'pending' AND v.status = 'active'
        `, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get pending welfare requests: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Get total number of active members in this chama
        var totalMembers int
        err = db.QueryRow(`
                SELECT COUNT(*) FROM chama_members
                WHERE chama_id = ? AND is_active = TRUE
        `, chamaID).Scan(&amp;totalMembers)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get total chama members: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var welfareID, welfareRequestChamaID, requesterID, status, voteID string
                err := rows.Scan(&amp;welfareID, &amp;welfareRequestChamaID, &amp;requesterID, &amp;status, &amp;voteID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get current vote counts for this welfare request
                <span class="cov0" title="0">var yesVotes, noVotes int
                err = db.QueryRow(`
                        SELECT
                                COALESCE(SUM(CASE WHEN option_text = 'yes' THEN vote_count ELSE 0 END), 0) as yes_votes,
                                COALESCE(SUM(CASE WHEN option_text = 'no' THEN vote_count ELSE 0 END), 0) as no_votes
                        FROM vote_options
                        WHERE vote_id = ?
                `, voteID).Scan(&amp;yesVotes, &amp;noVotes)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">totalVotes := yesVotes + noVotes

                // Check if all members have voted
                if totalVotes &gt;= totalMembers </span><span class="cov0" title="0">{
                        // Determine the result
                        var newStatus string
                        var statusMessage string

                        if yesVotes &gt; noVotes </span><span class="cov0" title="0">{
                                newStatus = "approved"
                                statusMessage = fmt.Sprintf("Approved by majority vote (%d yes, %d no)", yesVotes, noVotes)
                        }</span> else<span class="cov0" title="0"> {
                                newStatus = "rejected"
                                statusMessage = fmt.Sprintf("Rejected by majority vote (%d yes, %d no)", yesVotes, noVotes)
                        }</span>

                        // Update welfare request status
                        <span class="cov0" title="0">_, err = db.Exec(`
                                UPDATE welfare_requests
                                SET status = ?, votes_for = ?, votes_against = ?, updated_at = CURRENT_TIMESTAMP
                                WHERE id = ?
                        `, newStatus, yesVotes, noVotes, welfareID)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to update welfare request status for %s: %v\n", welfareID, err)
                                continue</span>
                        }

                        // Close the vote
                        <span class="cov0" title="0">_, err = db.Exec(`
                                UPDATE votes
                                SET status = 'completed', ends_at = CURRENT_TIMESTAMP
                                WHERE id = ?
                        `, voteID)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to close vote %s: %v\n", voteID, err)
                        }</span>

                        // Create notification for requester
                        <span class="cov0" title="0">notificationID := fmt.Sprintf("notif-%d", time.Now().UnixNano())
                        _, err = db.Exec(`
                                INSERT INTO notifications (
                                        id, user_id, type, title, message, data,
                                        is_read, created_at, updated_at
                                ) VALUES (?, ?, 'welfare_vote_result', ?, ?, ?, false, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                        `, notificationID, requesterID,
                                "Welfare Vote Complete",
                                statusMessage,
                                fmt.Sprintf(`{"welfare_request_id": "%s", "status": "%s", "yes_votes": %d, "no_votes": %d}`,
                                        welfareID, newStatus, yesVotes, noVotes))
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to create vote result notification for %s: %v\n", welfareID, err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Auto-closed welfare vote for request %s with status: %s\n", welfareID, newStatus)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package api

import (
        "database/sql"
        "net/http"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// GetWishlist retrieves user's wishlist
func GetWishlist(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Get wishlist
        wishlistItems, err := marketplaceService.GetWishlist(userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to get wishlist: " + err.Error(),
                })
                return
        }</span>

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    wishlistItems,
        })</span>
}

// AddToWishlist adds a product to user's wishlist
func AddToWishlist(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var req struct {
                ProductID string `json:"productId" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request data: " + err.Error(),
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Add to wishlist
        err := marketplaceService.AddToWishlist(userID.(string), req.ProductID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Failed to add to wishlist: " + err.Error(),
                })
                return
        }</span>

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Product added to wishlist successfully",
        })</span>
}

// RemoveFromWishlist removes a product from user's wishlist
func RemoveFromWishlist(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from context (set by auth middleware)
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "success": false,
                        "error":   "User not authenticated",
                })
                return
        }</span>

        // Get product ID from URL parameter
        <span class="cov0" title="0">productID := c.Param("productId")
        if productID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Product ID is required",
                })
                return
        }</span>

        // Get database connection
        <span class="cov0" title="0">db, exists := c.Get("db")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Database connection not available",
                })
                return
        }</span>

        // Create marketplace service
        <span class="cov0" title="0">marketplaceService := services.NewMarketplaceService(db.(*sql.DB))

        // Remove from wishlist
        err := marketplaceService.RemoveFromWishlist(userID.(string), productID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "item not found in wishlist" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{
                                "success": false,
                                "error":   "Item not found in wishlist",
                        })
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success": false,
                                "error":   "Failed to remove from wishlist: " + err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Return success response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "Item removed from wishlist successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
)

// Config holds all configuration for the application
type Config struct {
        Environment   string
        Port          string
        DatabaseURL   string
        JWTSecret     string
        JWTExpiration int

        // M-Pesa Configuration
        MpesaConsumerKey    string
        MpesaConsumerSecret string
        MpesaPasskey        string
        MpesaShortcode      string
        MpesaCallbackURL    string

        // Firebase Configuration
        FirebaseProjectID    string
        FirebasePrivateKeyID string
        FirebasePrivateKey   string
        FirebaseClientEmail  string
        FirebaseClientID     string
        FirebaseAuthURI      string
        FirebaseTokenURI     string
        FirebaseServerKey    string

        // Google Drive Configuration
        GoogleDriveClientID     string
        GoogleDriveClientSecret string
        GoogleDriveRedirectURL  string

        // Email Configuration
        SMTPHost     string
        SMTPPort     int
        SMTPUsername string
        SMTPPassword string

        // SMS Configuration (Africa's Talking)
        ATUsername string
        ATAPIKey   string
        ATSender   string

        // File Upload Configuration
        MaxFileSize      int64
        AllowedFileTypes []string
        UploadPath       string

        // LiveKit Configuration
        LiveKitAPIKey    string
        LiveKitSecretKey string
        LiveKitURL       string

        // Google OAuth Configuration
        GoogleClientID     string
        GoogleClientSecret string
        GoogleRedirectURL  string

        // Redis Configuration
        RedisURL      string
        RedisPassword string

        // Rate Limiting Configuration
        RateLimitRequests int
        RateLimitWindow   int

        // Logging Configuration
        LogLevel string
        LogFile  string

        // Metrics and Monitoring Configuration
        EnableMetrics bool
        MetricsPort   string
        EnableTracing bool

        // Backup Configuration
        BackupEnabled  bool
        BackupInterval int
        BackupPath     string
}

// Load loads configuration from environment variables
func Load() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Environment:   getEnv("ENVIRONMENT", "development"),
                Port:          getEnv("PORT", "8080"),
                DatabaseURL:   getEnv("DATABASE_URL", "vaultke.db"),
                JWTSecret:     getEnv("JWT_SECRET", "your-super-secret-jwt-key-change-in-production"),
                JWTExpiration: getEnvAsInt("JWT_EXPIRATION", 24*60*60), // 24 hours in seconds

                // M-Pesa Configuration
                MpesaConsumerKey:    getEnv("MPESA_CONSUMER_KEY", ""),
                MpesaConsumerSecret: getEnv("MPESA_CONSUMER_SECRET", ""),
                MpesaPasskey:        getEnv("MPESA_PASSKEY", ""),
                MpesaShortcode:      getEnv("MPESA_SHORTCODE", ""),
                MpesaCallbackURL:    getEnv("MPESA_CALLBACK_URL", ""),

                // Firebase Configuration
                FirebaseProjectID:    getEnv("FIREBASE_PROJECT_ID", ""),
                FirebasePrivateKeyID: getEnv("FIREBASE_PRIVATE_KEY_ID", ""),
                FirebasePrivateKey:   getEnv("FIREBASE_PRIVATE_KEY", ""),
                FirebaseClientEmail:  getEnv("FIREBASE_CLIENT_EMAIL", ""),
                FirebaseClientID:     getEnv("FIREBASE_CLIENT_ID", ""),
                FirebaseAuthURI:      getEnv("FIREBASE_AUTH_URI", ""),
                FirebaseTokenURI:     getEnv("FIREBASE_TOKEN_URI", ""),
                FirebaseServerKey:    getEnv("FIREBASE_SERVER_KEY", ""),

                // Google Drive Configuration
                GoogleDriveClientID:     getEnv("GOOGLE_DRIVE_CLIENT_ID", ""),
                GoogleDriveClientSecret: getEnv("GOOGLE_DRIVE_CLIENT_SECRET", ""),
                GoogleDriveRedirectURL:  getEnv("GOOGLE_DRIVE_REDIRECT_URL", ""),

                // Email Configuration
                SMTPHost:     getEnv("SMTP_HOST", "smtp.gmail.com"),
                SMTPPort:     getEnvAsInt("SMTP_PORT", 587),
                SMTPUsername: getEnv("SMTP_USERNAME", ""),
                SMTPPassword: getEnv("SMTP_PASSWORD", ""),

                // SMS Configuration
                ATUsername: getEnv("AT_USERNAME", ""),
                ATAPIKey:   getEnv("AT_API_KEY", ""),
                ATSender:   getEnv("AT_SENDER", "VaultKe"),

                // File Upload Configuration
                MaxFileSize:      getEnvAsInt64("MAX_FILE_SIZE", 5*1024*1024), // 5MB
                AllowedFileTypes: []string{"image/jpeg", "image/png", "image/webp"},
                UploadPath:       getEnv("UPLOAD_PATH", "./uploads"),

                // LiveKit Configuration
                LiveKitAPIKey:    getEnv("LIVEKIT_API_KEY", ""),
                LiveKitSecretKey: getEnv("LIVEKIT_SECRET_KEY", ""),
                LiveKitURL:       getEnv("LIVEKIT_URL", "ws://localhost:7880"),

                // Google OAuth Configuration
                GoogleClientID:     getEnv("GOOGLE_CLIENT_ID", ""),
                GoogleClientSecret: getEnv("GOOGLE_CLIENT_SECRET", ""),
                GoogleRedirectURL:  getEnv("GOOGLE_REDIRECT_URL", ""),

                // Redis Configuration
                RedisURL:      getEnv("REDIS_URL", "redis://localhost:6379"),
                RedisPassword: getEnv("REDIS_PASSWORD", ""),

                // Rate Limiting Configuration
                RateLimitRequests: getEnvAsInt("RATE_LIMIT_REQUESTS", 100),
                RateLimitWindow:   getEnvAsInt("RATE_LIMIT_WINDOW", 60),

                // Logging Configuration
                LogLevel: getEnv("LOG_LEVEL", "info"),
                LogFile:  getEnv("LOG_FILE", ""),

                // Metrics and Monitoring Configuration
                EnableMetrics: getEnvAsBool("ENABLE_METRICS", false),
                MetricsPort:   getEnv("METRICS_PORT", "9090"),
                EnableTracing: getEnvAsBool("ENABLE_TRACING", false),

                // Backup Configuration
                BackupEnabled:  getEnvAsBool("BACKUP_ENABLED", false),
                BackupInterval: getEnvAsInt("BACKUP_INTERVAL", 24),
                BackupPath:     getEnv("BACKUP_PATH", "./backups"),
        }
}</span>

// Helper functions
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt64(key string, defaultValue int64) int64 <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// ServerPort returns the server port (alias for Port for test compatibility)
func (c *Config) ServerPort() string <span class="cov0" title="0">{
        return c.Port
}</span>

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.JWTSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("JWT secret is required")
        }</span>
        <span class="cov0" title="0">if c.DatabaseURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database URL is required")
        }</span>
        <span class="cov0" title="0">if c.Environment == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("environment is required")
        }</span>

        // Validate environment values
        <span class="cov0" title="0">validEnvs := map[string]bool{
                "development": true,
                "production":  true,
                "test":        true,
        }
        if !validEnvs[c.Environment] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid environment: %s", c.Environment)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateRequired validates only required fields
func (c *Config) ValidateRequired() error <span class="cov0" title="0">{
        if c.JWTSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("JWT secret is required")
        }</span>
        <span class="cov0" title="0">if c.DatabaseURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Database URL is required")
        }</span>
        <span class="cov0" title="0">if c.Environment == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Environment is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetDefaults sets default values for configuration
func (c *Config) SetDefaults() <span class="cov0" title="0">{
        if c.JWTSecret == "" </span><span class="cov0" title="0">{
                c.JWTSecret = "your-super-secret-jwt-key-change-in-production"
        }</span>
        <span class="cov0" title="0">if c.DatabaseURL == "" </span><span class="cov0" title="0">{
                c.DatabaseURL = "vaultke.db"
        }</span>
        <span class="cov0" title="0">if c.Environment == "" </span><span class="cov0" title="0">{
                c.Environment = "development"
        }</span>
        <span class="cov0" title="0">if c.Port == "" </span><span class="cov0" title="0">{
                c.Port = "8080"
        }</span>
}

// String returns a string representation of the configuration
func (c *Config) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Config{Environment: %s, Port: %s, DatabaseURL: %s}", c.Environment, c.Port, c.DatabaseURL)
}</span>

// Clone creates a deep copy of the configuration
func (c *Config) Clone() *Config <span class="cov0" title="0">{
        clone := *c
        // Deep copy slices
        if c.AllowedFileTypes != nil </span><span class="cov0" title="0">{
                clone.AllowedFileTypes = make([]string, len(c.AllowedFileTypes))
                copy(clone.AllowedFileTypes, c.AllowedFileTypes)
        }</span>
        <span class="cov0" title="0">return &amp;clone</span>
}

// Reload reloads the configuration from environment variables
func (c *Config) Reload() <span class="cov0" title="0">{
        newConfig := Load()
        *c = *newConfig
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"

        _ "github.com/mattn/go-sqlite3"
)

// Initialize creates and returns a database connection
func Initialize(databaseURL string) (*sql.DB, error) <span class="cov0" title="0">{
        // Add SQLite-specific parameters for better concurrent access
        if databaseURL == "vaultke.db" </span><span class="cov0" title="0">{
                databaseURL = "vaultke.db?_busy_timeout=30000&amp;_journal_mode=WAL&amp;_synchronous=NORMAL&amp;_cache_size=1000&amp;_foreign_keys=1"
        }</span>

        <span class="cov0" title="0">db, err := sql.Open("sqlite3", databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Configure connection pool for better performance
        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(25)
        db.SetConnMaxLifetime(0) // No limit

        // Test the connection
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        // Set SQLite pragmas for better concurrent access
        <span class="cov0" title="0">pragmas := []string{
                "PRAGMA busy_timeout = 30000",
                "PRAGMA journal_mode = WAL",
                "PRAGMA synchronous = NORMAL",
                "PRAGMA cache_size = 1000",
                "PRAGMA foreign_keys = ON",
                "PRAGMA temp_store = memory",
        }

        for _, pragma := range pragmas </span><span class="cov0" title="0">{
                if _, err := db.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to set pragma %s: %v", pragma, err)
                }</span>
        }

        <span class="cov0" title="0">log.Println("Database connection established successfully")
        return db, nil</span>
}

// Migrate runs database migrations
func Migrate(db *sql.DB) error <span class="cov8" title="1">{
        migrations := []string{
                createUsersTable,
                createChamasTable,
                createChamaMembersTable,
                createWalletsTable,
                createTransactionsTable,
                createProductsTable,
                createCartItemsTable,
                createOrdersTable,
                createOrderItemsTable,
                createProductReviewsTable,
                createWishlistTable,
                createNotificationsTable,
                createChatRoomsTable,
                createChatMessagesTable,
                createChatRoomMembersTable,
                createLoansTable,
                createGuarantorsTable,
                createLoanPaymentsTable,
                createMeetingsTable,
                createMeetingAttendanceTable,
                createMeetingDocumentsTable,
                createMeetingMinutesTable,
                createVotesTable,
                createVoteOptionsTable,
                createUserVotesTable,
                createMerryGoRoundTable,
                createMerryGoRoundParticipantsTable,
                createWelfareTable,
                createWelfareContributionsTable,
                createWelfareRequestsTable,
                addWelfareRequestBeneficiaryField,
                addUserProfileFields,
                addChatMessageFields,
                addWelfareContributionFields,
                addMeetingDocumentFileUrl,
                createChamaInvitationsTable,
                addChamaPermissionsColumn,
                addInvitationRoleColumns,
                createLearningTables,
                createRemindersTable,
                createSharesAndDividendsTables,
                // createPollsAndVotingTables, // DISABLED: Conflicts with existing vote system
                createDisbursementTables,
                createDeliveryContactsTable,
                addOrderItemDeliveryPersonField,
                createMarketplaceRolesTable,
                populateExistingSellers,
                addEnhancedLearningContentFields,
                createQuizResultsTable,
        }

        for i, migration := range migrations </span><span class="cov8" title="1">{
                // Handle special migrations that need custom logic
                if i == len(migrations)-10 </span><span class="cov8" title="1">{ // Tenth to last migration is addOrderItemDeliveryPersonField
                        if err := addMissingOrderItemDeliveryPersonField(db); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add order item delivery person field: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if i == len(migrations)-9 </span><span class="cov8" title="1">{ // Ninth to last migration is addWelfareRequestBeneficiaryField
                        if err := addMissingWelfareRequestBeneficiaryField(db); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add welfare request beneficiary field: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if i == len(migrations)-8 </span><span class="cov8" title="1">{ // Eighth to last migration is addUserProfileFields
                        if err := addMissingUserProfileFields(db); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add user profile fields: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if i == len(migrations)-7 </span><span class="cov8" title="1">{ // Seventh to last migration is addChatMessageFields
                        if err := addMissingChatMessageFields(db); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add chat message fields: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if i == len(migrations)-6 </span><span class="cov8" title="1">{ // Sixth to last migration is addWelfareContributionFields
                        if err := addMissingWelfareContributionFields(db); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add welfare contribution fields: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if i == len(migrations)-5 </span><span class="cov8" title="1">{ // Fifth to last migration is addMeetingDocumentFileUrl
                        if err := addMissingMeetingDocumentFileUrl(db); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add meeting document file_url field: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if i == len(migrations)-4 </span><span class="cov8" title="1">{ // Fourth to last migration is addChamaPermissionsColumn
                        if err := addMissingChamaPermissionsColumn(db); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add chama permissions column: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if i == len(migrations)-3 </span><span class="cov8" title="1">{ // Third to last migration is addInvitationRoleColumns
                        if err := addMissingInvitationRoleColumns(db); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add invitation role columns: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if i == len(migrations)-2 </span><span class="cov8" title="1">{ // Second to last migration is addEnhancedLearningContentFields
                        if err := addMissingEnhancedLearningContentFields(db); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add enhanced learning content fields: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if i == len(migrations)-1 </span><span class="cov8" title="1">{ // Last migration is createQuizResultsTable
                        if _, err := db.Exec(migration); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create quiz results table: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Regular migrations
                        if _, err := db.Exec(migration); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to run migration %d: %w", i+1, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">log.Println("Database migrations completed successfully")
        return nil</span>
}

// SQL migration statements
const createUsersTable = `
CREATE TABLE IF NOT EXISTS users (
    id TEXT PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    phone TEXT UNIQUE NOT NULL,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    password_hash TEXT NOT NULL,
    avatar TEXT,
    role TEXT NOT NULL DEFAULT 'user',
    status TEXT NOT NULL DEFAULT 'pending',
    is_email_verified BOOLEAN DEFAULT FALSE,
    is_phone_verified BOOLEAN DEFAULT FALSE,
    language TEXT DEFAULT 'en',
    theme TEXT DEFAULT 'dark',
    county TEXT,
    town TEXT,
    latitude REAL,
    longitude REAL,
    business_type TEXT,
    business_description TEXT,
    rating REAL DEFAULT 0,
    total_ratings INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);`

const createChamasTable = `
CREATE TABLE IF NOT EXISTS chamas (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'active',
    avatar TEXT,
    county TEXT NOT NULL,
    town TEXT NOT NULL,
    latitude REAL,
    longitude REAL,
    contribution_amount REAL NOT NULL,
    contribution_frequency TEXT NOT NULL,
    max_members INTEGER,
    current_members INTEGER DEFAULT 0,
    total_funds REAL DEFAULT 0,
    is_public BOOLEAN DEFAULT FALSE,
    requires_approval BOOLEAN DEFAULT TRUE,
    rules TEXT, -- JSON array of rules
    meeting_frequency TEXT,
    meeting_day_of_week INTEGER,
    meeting_day_of_month INTEGER,
    meeting_time TEXT,
    created_by TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (created_by) REFERENCES users(id)
);`

const createChamaMembersTable = `
CREATE TABLE IF NOT EXISTS chama_members (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    role TEXT NOT NULL DEFAULT 'member',
    joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE,
    total_contributions REAL DEFAULT 0,
    last_contribution DATETIME,
    rating REAL DEFAULT 0,
    total_ratings INTEGER DEFAULT 0,
    FOREIGN KEY (chama_id) REFERENCES chamas(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE(chama_id, user_id)
);`

const createWalletsTable = `
CREATE TABLE IF NOT EXISTS wallets (
    id TEXT PRIMARY KEY,
    type TEXT NOT NULL,
    owner_id TEXT NOT NULL,
    balance REAL DEFAULT 0,
    currency TEXT DEFAULT 'KES',
    is_active BOOLEAN DEFAULT TRUE,
    is_locked BOOLEAN DEFAULT FALSE,
    daily_limit REAL,
    monthly_limit REAL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);`

const createTransactionsTable = `
CREATE TABLE IF NOT EXISTS transactions (
    id TEXT PRIMARY KEY,
    from_wallet_id TEXT,
    to_wallet_id TEXT,
    type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending',
    amount REAL NOT NULL,
    currency TEXT DEFAULT 'KES',
    description TEXT,
    reference TEXT,
    payment_method TEXT NOT NULL,
    metadata TEXT, -- JSON metadata
    fees REAL DEFAULT 0,
    initiated_by TEXT NOT NULL,
    approved_by TEXT,
    requires_approval BOOLEAN DEFAULT FALSE,
    approval_deadline DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (from_wallet_id) REFERENCES wallets(id),
    FOREIGN KEY (to_wallet_id) REFERENCES wallets(id),
    FOREIGN KEY (initiated_by) REFERENCES users(id),
    FOREIGN KEY (approved_by) REFERENCES users(id)
);`

const createProductsTable = `
CREATE TABLE IF NOT EXISTS products (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT NOT NULL,
    category TEXT NOT NULL,
    price REAL NOT NULL,
    currency TEXT DEFAULT 'KES',
    images TEXT, -- JSON array of image URLs
    status TEXT NOT NULL DEFAULT 'active',
    stock INTEGER DEFAULT 0,
    min_order INTEGER DEFAULT 1,
    max_order INTEGER,
    seller_id TEXT NOT NULL,
    chama_id TEXT,
    county TEXT NOT NULL,
    town TEXT NOT NULL,
    address TEXT,
    tags TEXT, -- JSON array of tags
    rating REAL DEFAULT 0,
    total_ratings INTEGER DEFAULT 0,
    total_sales INTEGER DEFAULT 0,
    is_promoted BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (seller_id) REFERENCES users(id),
    FOREIGN KEY (chama_id) REFERENCES chamas(id)
);`

const createCartItemsTable = `
CREATE TABLE IF NOT EXISTS cart_items (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    product_id TEXT NOT NULL,
    quantity INTEGER NOT NULL,
    price REAL NOT NULL,
    added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (product_id) REFERENCES products(id),
    UNIQUE(user_id, product_id)
);`

const createOrdersTable = `
CREATE TABLE IF NOT EXISTS orders (
    id TEXT PRIMARY KEY,
    buyer_id TEXT NOT NULL,
    seller_id TEXT NOT NULL,
    chama_id TEXT,
    total_amount REAL NOT NULL,
    currency TEXT DEFAULT 'KES',
    status TEXT NOT NULL DEFAULT 'pending',
    payment_method TEXT NOT NULL,
    payment_status TEXT NOT NULL DEFAULT 'pending',
    delivery_county TEXT NOT NULL,
    delivery_town TEXT NOT NULL,
    delivery_address TEXT NOT NULL,
    delivery_phone TEXT NOT NULL,
    delivery_fee REAL DEFAULT 0,
    delivery_person_id TEXT,
    delivery_status TEXT NOT NULL DEFAULT 'pending',
    estimated_delivery DATETIME,
    actual_delivery DATETIME,
    notes TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (buyer_id) REFERENCES users(id),
    FOREIGN KEY (seller_id) REFERENCES users(id),
    FOREIGN KEY (chama_id) REFERENCES chamas(id),
    FOREIGN KEY (delivery_person_id) REFERENCES users(id)
);`

const createOrderItemsTable = `
CREATE TABLE IF NOT EXISTS order_items (
    id TEXT PRIMARY KEY,
    order_id TEXT NOT NULL,
    product_id TEXT NOT NULL,
    quantity INTEGER NOT NULL,
    price REAL NOT NULL,
    name TEXT NOT NULL,
    FOREIGN KEY (order_id) REFERENCES orders(id),
    FOREIGN KEY (product_id) REFERENCES products(id)
);`

const createProductReviewsTable = `
CREATE TABLE IF NOT EXISTS product_reviews (
    id TEXT PRIMARY KEY,
    product_id TEXT NOT NULL,
    order_id TEXT NOT NULL,
    reviewer_id TEXT NOT NULL,
    rating INTEGER NOT NULL CHECK (rating &gt;= 1 AND rating &lt;= 5),
    comment TEXT,
    images TEXT, -- JSON array of image URLs
    is_verified_purchase BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (product_id) REFERENCES products(id),
    FOREIGN KEY (order_id) REFERENCES orders(id),
    FOREIGN KEY (reviewer_id) REFERENCES users(id),
    UNIQUE(order_id, product_id, reviewer_id)
);`

const createWishlistTable = `
CREATE TABLE IF NOT EXISTS wishlist (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    product_id TEXT NOT NULL,
    added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (product_id) REFERENCES products(id),
    UNIQUE(user_id, product_id)
);`

const createNotificationsTable = `
CREATE TABLE IF NOT EXISTS notifications (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    title TEXT NOT NULL,
    message TEXT NOT NULL,
    type TEXT NOT NULL,
    data TEXT, -- JSON data
    is_read BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);`

const createChatRoomsTable = `
CREATE TABLE IF NOT EXISTS chat_rooms (
    id TEXT PRIMARY KEY,
    name TEXT,
    type TEXT NOT NULL, -- 'private', 'group', 'chama'
    chama_id TEXT,
    created_by TEXT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    last_message TEXT,
    last_message_at DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id),
    FOREIGN KEY (created_by) REFERENCES users(id)
);`

const createChatMessagesTable = `
CREATE TABLE IF NOT EXISTS chat_messages (
    id TEXT PRIMARY KEY,
    room_id TEXT NOT NULL,
    sender_id TEXT NOT NULL,
    message TEXT NOT NULL,
    content TEXT NOT NULL,
    type TEXT DEFAULT 'text',
    message_type TEXT DEFAULT 'text', -- 'text', 'image', 'file', 'voice'
    metadata TEXT DEFAULT '{}',
    file_url TEXT,
    is_edited BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    reply_to TEXT,
    reply_to_id TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (room_id) REFERENCES chat_rooms(id),
    FOREIGN KEY (sender_id) REFERENCES users(id),
    FOREIGN KEY (reply_to) REFERENCES chat_messages(id),
    FOREIGN KEY (reply_to_id) REFERENCES chat_messages(id)
);`

const createMeetingsTable = `
CREATE TABLE IF NOT EXISTS meetings (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    scheduled_at DATETIME NOT NULL,
    duration INTEGER, -- in minutes
    location TEXT,
    meeting_url TEXT,
    meeting_type TEXT NOT NULL DEFAULT 'physical', -- 'physical', 'virtual', 'hybrid'
    livekit_room_name TEXT, -- LiveKit room identifier
    livekit_room_id TEXT, -- LiveKit room ID
    status TEXT NOT NULL DEFAULT 'scheduled', -- 'scheduled', 'active', 'ended', 'cancelled'
    started_at DATETIME,
    ended_at DATETIME,
    recording_enabled BOOLEAN DEFAULT FALSE,
    recording_url TEXT,
    transcript_url TEXT,
    created_by TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id),
    FOREIGN KEY (created_by) REFERENCES users(id)
);`

const createMeetingAttendanceTable = `
CREATE TABLE IF NOT EXISTS meeting_attendance (
    id TEXT PRIMARY KEY,
    meeting_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    attendance_type TEXT NOT NULL, -- 'physical', 'virtual'
    joined_at DATETIME,
    left_at DATETIME,
    duration_minutes INTEGER DEFAULT 0,
    is_present BOOLEAN DEFAULT FALSE,
    notes TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (meeting_id) REFERENCES meetings(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE(meeting_id, user_id)
);`

const createMeetingDocumentsTable = `
CREATE TABLE IF NOT EXISTS meeting_documents (
    id TEXT PRIMARY KEY,
    meeting_id TEXT NOT NULL,
    uploaded_by TEXT NOT NULL,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL,
    file_url TEXT NOT NULL,
    file_size INTEGER,
    file_type TEXT,
    document_type TEXT, -- 'agenda', 'minutes', 'attachment', 'recording'
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (meeting_id) REFERENCES meetings(id),
    FOREIGN KEY (uploaded_by) REFERENCES users(id)
);`

const createMeetingMinutesTable = `
CREATE TABLE IF NOT EXISTS meeting_minutes (
    id TEXT PRIMARY KEY,
    meeting_id TEXT NOT NULL,
    content TEXT NOT NULL,
    taken_by TEXT NOT NULL, -- Secretary or authorized user
    status TEXT NOT NULL DEFAULT 'draft', -- 'draft', 'approved', 'published'
    approved_by TEXT,
    approved_at DATETIME,
    version INTEGER DEFAULT 1,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (meeting_id) REFERENCES meetings(id),
    FOREIGN KEY (taken_by) REFERENCES users(id),
    FOREIGN KEY (approved_by) REFERENCES users(id)
);`

const createVotesTable = `
CREATE TABLE IF NOT EXISTS votes (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    type TEXT NOT NULL DEFAULT 'single', -- 'single', 'multiple'
    status TEXT NOT NULL DEFAULT 'active',
    starts_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    ends_at DATETIME NOT NULL,
    created_by TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id),
    FOREIGN KEY (created_by) REFERENCES users(id)
);`

const createVoteOptionsTable = `
CREATE TABLE IF NOT EXISTS vote_options (
    id TEXT PRIMARY KEY,
    vote_id TEXT NOT NULL,
    option_text TEXT NOT NULL,
    vote_count INTEGER DEFAULT 0,
    FOREIGN KEY (vote_id) REFERENCES votes(id)
);`

const createUserVotesTable = `
CREATE TABLE IF NOT EXISTS user_votes (
    id TEXT PRIMARY KEY,
    vote_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    option_id TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (vote_id) REFERENCES votes(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (option_id) REFERENCES vote_options(id),
    UNIQUE(vote_id, user_id, option_id)
);`

const createChatRoomMembersTable = `
CREATE TABLE IF NOT EXISTS chat_room_members (
    id TEXT PRIMARY KEY,
    room_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    role TEXT NOT NULL DEFAULT 'member',
    joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_read_at DATETIME,
    is_active BOOLEAN DEFAULT TRUE,
    is_muted BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (room_id) REFERENCES chat_rooms(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE(room_id, user_id)
);`

const createLoansTable = `
CREATE TABLE IF NOT EXISTS loans (
    id TEXT PRIMARY KEY,
    borrower_id TEXT NOT NULL,
    chama_id TEXT NOT NULL,
    type TEXT NOT NULL,
    amount REAL NOT NULL,
    interest_rate REAL DEFAULT 0,
    duration INTEGER NOT NULL,
    purpose TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending',
    approved_by TEXT,
    approved_at DATETIME,
    disbursed_at DATETIME,
    due_date DATETIME,
    total_amount REAL DEFAULT 0,
    paid_amount REAL DEFAULT 0,
    remaining_amount REAL DEFAULT 0,
    required_guarantors INTEGER NOT NULL,
    approved_guarantors INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (borrower_id) REFERENCES users(id),
    FOREIGN KEY (chama_id) REFERENCES chamas(id),
    FOREIGN KEY (approved_by) REFERENCES users(id)
);`

const createGuarantorsTable = `
CREATE TABLE IF NOT EXISTS guarantors (
    id TEXT PRIMARY KEY,
    loan_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    amount REAL NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending',
    message TEXT,
    responded_at DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (loan_id) REFERENCES loans(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE(loan_id, user_id)
);`

const createLoanPaymentsTable = `
CREATE TABLE IF NOT EXISTS loan_payments (
    id TEXT PRIMARY KEY,
    loan_id TEXT NOT NULL,
    amount REAL NOT NULL,
    principal_amount REAL NOT NULL,
    interest_amount REAL NOT NULL,
    payment_method TEXT NOT NULL,
    reference TEXT,
    paid_at DATETIME NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (loan_id) REFERENCES loans(id)
);`

const createMerryGoRoundTable = `
CREATE TABLE IF NOT EXISTS merry_go_rounds (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    amount_per_round REAL NOT NULL,
    frequency TEXT NOT NULL, -- 'weekly', 'monthly'
    total_participants INTEGER NOT NULL,
    current_round INTEGER DEFAULT 1,
    status TEXT NOT NULL DEFAULT 'active',
    start_date DATE NOT NULL,
    next_payout_date DATE,
    created_by TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id),
    FOREIGN KEY (created_by) REFERENCES users(id)
);`

const createMerryGoRoundParticipantsTable = `
CREATE TABLE IF NOT EXISTS merry_go_round_participants (
    id TEXT PRIMARY KEY,
    merry_go_round_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    position INTEGER NOT NULL,
    has_received BOOLEAN DEFAULT FALSE,
    received_at DATETIME,
    total_contributed REAL DEFAULT 0,
    joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (merry_go_round_id) REFERENCES merry_go_rounds(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE(merry_go_round_id, user_id),
    UNIQUE(merry_go_round_id, position)
);`

const createWelfareTable = `
CREATE TABLE IF NOT EXISTS welfare_funds (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    target_amount REAL,
    current_amount REAL DEFAULT 0,
    contribution_per_member REAL,
    purpose TEXT NOT NULL, -- 'emergency', 'medical', 'funeral', 'education'
    status TEXT NOT NULL DEFAULT 'active',
    beneficiary_id TEXT,
    created_by TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id),
    FOREIGN KEY (beneficiary_id) REFERENCES users(id),
    FOREIGN KEY (created_by) REFERENCES users(id)
);`

const createWelfareContributionsTable = `
CREATE TABLE IF NOT EXISTS welfare_contributions (
    id TEXT PRIMARY KEY,
    welfare_fund_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    amount REAL NOT NULL,
    payment_method TEXT NOT NULL,
    reference TEXT,
    contributed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (welfare_fund_id) REFERENCES welfare_funds(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);`

const createWelfareRequestsTable = `
CREATE TABLE IF NOT EXISTS welfare_requests (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    requester_id TEXT NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    amount REAL NOT NULL,
    category TEXT NOT NULL,
    urgency TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending',
    votes_for INTEGER DEFAULT 0,
    votes_against INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id),
    FOREIGN KEY (requester_id) REFERENCES users(id)
);`

// addWelfareRequestBeneficiaryField adds beneficiary_id field to welfare_requests table
const addWelfareRequestBeneficiaryField = "SELECT 1" // Placeholder - actual logic in migration function

// addUserProfileFields adds missing profile fields if they don't exist
const addUserProfileFields = "SELECT 1" // Placeholder - actual logic in migration function

// addChatMessageFields adds missing chat message fields if they don't exist
const addChatMessageFields = "SELECT 1" // Placeholder - actual logic in migration function

// addChatRoomFields adds missing chat room fields if they don't exist
const addChatRoomFields = "SELECT 1" // Placeholder - actual logic in migration function

// addMissingUserProfileFields safely adds missing profile fields to users table
func addMissingUserProfileFields(db *sql.DB) error <span class="cov8" title="1">{
        // Check if columns exist and add them if they don't
        columns := []struct {
                name     string
                dataType string
        }{
                {"bio", "TEXT"},
                {"occupation", "TEXT"},
                {"date_of_birth", "DATE"},
        }

        for _, col := range columns </span><span class="cov8" title="1">{
                // Check if column exists
                var exists bool
                query := `SELECT COUNT(*) FROM pragma_table_info('users') WHERE name = ?`
                err := db.QueryRow(query, col.name).Scan(&amp;exists)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check if column %s exists: %w", col.name, err)
                }</span>

                // Add column if it doesn't exist
                <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                        alterQuery := fmt.Sprintf("ALTER TABLE users ADD COLUMN %s %s", col.name, col.dataType)
                        if _, err := db.Exec(alterQuery); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add column %s: %w", col.name, err)
                        }</span>
                        <span class="cov8" title="1">log.Printf("Added column %s to users table", col.name)</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("Column %s already exists in users table", col.name)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// addMissingWelfareRequestBeneficiaryField safely adds beneficiary_id field to welfare_requests table
func addMissingWelfareRequestBeneficiaryField(db *sql.DB) error <span class="cov8" title="1">{
        // Check if beneficiary_id column exists
        var exists bool
        query := `SELECT COUNT(*) FROM pragma_table_info('welfare_requests') WHERE name = 'beneficiary_id'`
        err := db.QueryRow(query).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if beneficiary_id column exists: %w", err)
        }</span>

        // Add column if it doesn't exist
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                alterQuery := `ALTER TABLE welfare_requests ADD COLUMN beneficiary_id TEXT`
                if _, err := db.Exec(alterQuery); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add beneficiary_id column: %w", err)
                }</span>
                <span class="cov8" title="1">log.Printf("Added beneficiary_id column to welfare_requests table")

                // Set beneficiary_id to requester_id for existing records (self-requests)
                updateQuery := `UPDATE welfare_requests SET beneficiary_id = requester_id WHERE beneficiary_id IS NULL`
                if _, err := db.Exec(updateQuery); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to update existing records with beneficiary_id: %v", err)
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("Updated existing welfare requests to set beneficiary_id = requester_id")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("Column beneficiary_id already exists in welfare_requests table")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// addMissingChatMessageFields safely adds missing chat message fields to chat_messages table
func addMissingChatMessageFields(db *sql.DB) error <span class="cov8" title="1">{
        // Check if columns exist and add them if they don't
        columns := []struct {
                name         string
                dataType     string
                defaultValue string
        }{
                {"content", "TEXT", "''"},
                {"type", "TEXT", "'text'"},
                {"metadata", "TEXT", "'{}'"},
                {"is_deleted", "BOOLEAN", "FALSE"},
                {"reply_to_id", "TEXT", "NULL"},
        }

        for _, col := range columns </span><span class="cov8" title="1">{
                // Check if column exists
                var exists bool
                query := `SELECT COUNT(*) FROM pragma_table_info('chat_messages') WHERE name = ?`
                err := db.QueryRow(query, col.name).Scan(&amp;exists)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check if column %s exists: %w", col.name, err)
                }</span>

                // Add column if it doesn't exist
                <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                        alterQuery := fmt.Sprintf("ALTER TABLE chat_messages ADD COLUMN %s %s DEFAULT %s", col.name, col.dataType, col.defaultValue)
                        if _, err := db.Exec(alterQuery); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add column %s: %w", col.name, err)
                        }</span>
                        <span class="cov0" title="0">log.Printf("Added column %s to chat_messages table", col.name)</span>
                } else<span class="cov8" title="1"> {
                        log.Printf("Column %s already exists in chat_messages table", col.name)
                }</span>
        }

        // Update existing records to populate content from message if content is empty
        <span class="cov8" title="1">updateQuery := `UPDATE chat_messages SET content = message WHERE content = '' OR content IS NULL`
        if _, err := db.Exec(updateQuery); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to update content from message: %v", err)
        }</span> else<span class="cov8" title="1"> {
                log.Printf("Updated content field from message field for existing records")
        }</span>

        // Update new records to populate message from content to maintain compatibility
        <span class="cov8" title="1">updateQuery2 := `UPDATE chat_messages SET message = content WHERE message = '' OR message IS NULL`
        if _, err := db.Exec(updateQuery2); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to update message from content: %v", err)
        }</span> else<span class="cov8" title="1"> {
                log.Printf("Updated message field from content field for compatibility")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// addMissingChatRoomFields safely adds missing chat room fields to chat_rooms table
func addMissingChatRoomFields(db *sql.DB) error <span class="cov0" title="0">{
        // Check if columns exist and add them if they don't
        columns := []struct {
                name         string
                dataType     string
                defaultValue string
        }{
                {"is_active", "BOOLEAN", "TRUE"},
                {"last_message", "TEXT", "NULL"},
                {"last_message_at", "DATETIME", "NULL"},
                {"updated_at", "DATETIME", "CURRENT_TIMESTAMP"},
        }

        for _, col := range columns </span><span class="cov0" title="0">{
                // Check if column exists
                var exists bool
                query := `SELECT COUNT(*) FROM pragma_table_info('chat_rooms') WHERE name = ?`
                err := db.QueryRow(query, col.name).Scan(&amp;exists)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check if column %s exists: %w", col.name, err)
                }</span>

                // Add column if it doesn't exist
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        alterQuery := fmt.Sprintf("ALTER TABLE chat_rooms ADD COLUMN %s %s DEFAULT %s", col.name, col.dataType, col.defaultValue)
                        if _, err := db.Exec(alterQuery); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add column %s: %w", col.name, err)
                        }</span>
                        <span class="cov0" title="0">log.Printf("Added column %s to chat_rooms table", col.name)</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("Column %s already exists in chat_rooms table", col.name)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// addMissingTransactionFields adds missing columns to the transactions table
func addMissingTransactionFields(db *sql.DB) error <span class="cov0" title="0">{
        columns := []struct {
                name         string
                dataType     string
                defaultValue string
        }{
                {"checkout_request_id", "TEXT", "NULL"},
        }

        for _, col := range columns </span><span class="cov0" title="0">{
                // Check if column exists
                var exists bool
                query := `SELECT COUNT(*) FROM pragma_table_info('transactions') WHERE name = ?`
                err := db.QueryRow(query, col.name).Scan(&amp;exists)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check if column %s exists: %w", col.name, err)
                }</span>

                // Add column if it doesn't exist
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        alterQuery := fmt.Sprintf("ALTER TABLE transactions ADD COLUMN %s %s DEFAULT %s", col.name, col.dataType, col.defaultValue)
                        if _, err := db.Exec(alterQuery); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add column %s: %w", col.name, err)
                        }</span>
                        <span class="cov0" title="0">log.Printf("Added column %s to transactions table", col.name)</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("Column %s already exists in transactions table", col.name)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// addTransactionFields is a placeholder for the migration system
const addTransactionFields = ""

// addWelfareContributionFields is a placeholder for the migration system
const addWelfareContributionFields = ""

// addMissingWelfareContributionFields adds missing columns to the welfare_contributions table
func addMissingWelfareContributionFields(db *sql.DB) error <span class="cov8" title="1">{
        columns := []struct {
                name         string
                dataType     string
                defaultValue string
        }{
                {"welfare_request_id", "TEXT", "NULL"},
                {"contributor_id", "TEXT", "NULL"},
                {"message", "TEXT", "NULL"},
                {"status", "TEXT", "'completed'"},
                {"created_at", "DATETIME", "CURRENT_TIMESTAMP"},
                {"updated_at", "DATETIME", "CURRENT_TIMESTAMP"},
        }

        for _, col := range columns </span><span class="cov8" title="1">{
                // Check if column exists
                var exists bool
                query := `SELECT COUNT(*) FROM pragma_table_info('welfare_contributions') WHERE name = ?`
                err := db.QueryRow(query, col.name).Scan(&amp;exists)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check if column %s exists: %w", col.name, err)
                }</span>

                // Add column if it doesn't exist
                <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                        alterQuery := fmt.Sprintf("ALTER TABLE welfare_contributions ADD COLUMN %s %s DEFAULT %s", col.name, col.dataType, col.defaultValue)
                        if _, err := db.Exec(alterQuery); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add column %s: %w", col.name, err)
                        }</span>
                        <span class="cov8" title="1">log.Printf("Added column %s to welfare_contributions table", col.name)</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("Column %s already exists in welfare_contributions table", col.name)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Migration constant for adding file_url to meeting_documents
const addMeetingDocumentFileUrl = `-- This is handled by addMissingMeetingDocumentFileUrl function`

// addMissingMeetingDocumentFileUrl adds the file_url column to meeting_documents table if it doesn't exist
func addMissingMeetingDocumentFileUrl(db *sql.DB) error <span class="cov8" title="1">{
        // Check if file_url column exists
        rows, err := db.Query("PRAGMA table_info(meeting_documents)")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get table info: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        hasFileUrl := false
        for rows.Next() </span><span class="cov8" title="1">{
                var cid int
                var name, dataType string
                var notNull, pk int
                var defaultValue sql.NullString

                err := rows.Scan(&amp;cid, &amp;name, &amp;dataType, &amp;notNull, &amp;defaultValue, &amp;pk)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if name == "file_url" </span><span class="cov8" title="1">{
                        hasFileUrl = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !hasFileUrl </span><span class="cov0" title="0">{
                log.Println("Adding file_url column to meeting_documents table...")
                _, err = db.Exec("ALTER TABLE meeting_documents ADD COLUMN file_url TEXT")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add file_url column: %w", err)
                }</span>
                <span class="cov0" title="0">log.Println("Successfully added file_url column to meeting_documents table")</span>
        } else<span class="cov8" title="1"> {
                log.Println("file_url column already exists in meeting_documents table")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// createChamaInvitationsTable creates the chama invitations table
const createChamaInvitationsTable = `
CREATE TABLE IF NOT EXISTS chama_invitations (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    inviter_id TEXT NOT NULL,
    email TEXT NOT NULL,
    phone_number TEXT,
    message TEXT,
    invitation_token TEXT NOT NULL UNIQUE,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected', 'expired')),
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expires_at DATETIME NOT NULL,
    responded_at DATETIME,
    responded_by TEXT,
    FOREIGN KEY (chama_id) REFERENCES chamas(id) ON DELETE CASCADE,
    FOREIGN KEY (inviter_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (responded_by) REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_chama_invitations_email ON chama_invitations(email);
CREATE INDEX IF NOT EXISTS idx_chama_invitations_chama_id ON chama_invitations(chama_id);
CREATE INDEX IF NOT EXISTS idx_chama_invitations_status ON chama_invitations(status);
CREATE INDEX IF NOT EXISTS idx_chama_invitations_token ON chama_invitations(invitation_token);
`

// addChamaPermissionsColumn adds permissions column to chamas table
const addChamaPermissionsColumn = `
-- This will be handled by addMissingChamaPermissionsColumn function
SELECT 1;
`

// addInvitationRoleColumns adds role-related columns to chama_invitations table
const addInvitationRoleColumns = `
-- This will be handled by addMissingInvitationRoleColumns function
SELECT 1;
`

// addMissingChamaPermissionsColumn adds permissions column to chamas table if it doesn't exist
func addMissingChamaPermissionsColumn(db *sql.DB) error <span class="cov8" title="1">{
        // Check if permissions column exists
        var columnExists bool
        checkQuery := `
                SELECT COUNT(*) &gt; 0
                FROM pragma_table_info('chamas')
                WHERE name = 'permissions'
        `

        err := db.QueryRow(checkQuery).Scan(&amp;columnExists)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if permissions column exists: %w", err)
        }</span>

        <span class="cov8" title="1">if !columnExists </span><span class="cov8" title="1">{
                log.Println("Adding permissions column to chamas table")
                addColumnQuery := `
                        ALTER TABLE chamas ADD COLUMN permissions TEXT DEFAULT '{"allowMerryGoRound": true, "allowWelfare": true, "allowMarketplace": true}'
                `
                _, err = db.Exec(addColumnQuery)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add permissions column: %w", err)
                }</span>
                <span class="cov8" title="1">log.Println("Successfully added permissions column to chamas table")</span>
        } else<span class="cov0" title="0"> {
                log.Println("Column permissions already exists in chamas table")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// addMissingInvitationRoleColumns safely adds role-related columns to chama_invitations table
func addMissingInvitationRoleColumns(db *sql.DB) error <span class="cov8" title="1">{
        columns := []struct {
                name         string
                dataType     string
                defaultValue string
        }{
                {"role", "TEXT", ""},
                {"role_name", "TEXT", ""},
                {"role_description", "TEXT", ""},
        }

        for _, col := range columns </span><span class="cov8" title="1">{
                // Check if column exists
                var count int
                err := db.QueryRow(`
                        SELECT COUNT(*) FROM pragma_table_info('chama_invitations')
                        WHERE name = ?
                `, col.name).Scan(&amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error checking for column %s: %v", col.name, err)
                        continue</span>
                }

                // Add column if it doesn't exist
                <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                        query := fmt.Sprintf("ALTER TABLE chama_invitations ADD COLUMN %s %s", col.name, col.dataType)
                        if col.defaultValue != "" </span><span class="cov0" title="0">{
                                query += fmt.Sprintf(" DEFAULT '%s'", col.defaultValue)
                        }</span>

                        <span class="cov8" title="1">_, err = db.Exec(query)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error adding column %s: %v", col.name, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">log.Printf("Added column %s to chama_invitations table", col.name)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// createLearningTables creates all learning management system tables
const createLearningTables = `
-- Learning categories table
CREATE TABLE IF NOT EXISTS learning_categories (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    icon TEXT,
    color TEXT,
    sort_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Learning courses table
CREATE TABLE IF NOT EXISTS learning_courses (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    category_id TEXT NOT NULL,
    level TEXT NOT NULL CHECK (level IN ('beginner', 'intermediate', 'advanced')),
    type TEXT NOT NULL CHECK (type IN ('article', 'video', 'course', 'quiz')),
    content TEXT, -- Main content (markdown for articles, video URL for videos)
    thumbnail_url TEXT,
    duration_minutes INTEGER,
    estimated_read_time TEXT,
    tags TEXT, -- JSON array of tags
    prerequisites TEXT, -- JSON array of prerequisite course IDs
    learning_objectives TEXT, -- JSON array of learning objectives
    status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
    is_featured BOOLEAN DEFAULT false,
    -- Enhanced content fields for new system
    video_url TEXT, -- Direct video URL for video courses
    quiz_questions TEXT, -- JSON array of quiz questions with answers
    article_content TEXT, -- JSON object with headline_image and sections
    course_structure TEXT, -- JSON object with topics, subtopics, and outline
    view_count INTEGER DEFAULT 0,
    rating REAL DEFAULT 0,
    total_ratings INTEGER DEFAULT 0,
    created_by TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES learning_categories(id),
    FOREIGN KEY (created_by) REFERENCES users(id)
);

-- Learning course lessons table (for multi-lesson courses)
CREATE TABLE IF NOT EXISTS learning_lessons (
    id TEXT PRIMARY KEY,
    course_id TEXT NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    content TEXT NOT NULL,
    lesson_order INTEGER NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('text', 'video', 'quiz', 'assignment')),
    duration_minutes INTEGER,
    video_url TEXT,
    attachments TEXT, -- JSON array of attachment URLs
    is_required BOOLEAN DEFAULT true,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (course_id) REFERENCES learning_courses(id) ON DELETE CASCADE,
    UNIQUE(course_id, lesson_order)
);

-- User course progress table
CREATE TABLE IF NOT EXISTS user_course_progress (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    course_id TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'not_started' CHECK (status IN ('not_started', 'in_progress', 'completed')),
    progress_percentage REAL DEFAULT 0,
    current_lesson_id TEXT,
    started_at DATETIME,
    completed_at DATETIME,
    last_accessed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    time_spent_minutes INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (course_id) REFERENCES learning_courses(id) ON DELETE CASCADE,
    FOREIGN KEY (current_lesson_id) REFERENCES learning_lessons(id),
    UNIQUE(user_id, course_id)
);

-- User lesson progress table
CREATE TABLE IF NOT EXISTS user_lesson_progress (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    lesson_id TEXT NOT NULL,
    course_id TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'not_started' CHECK (status IN ('not_started', 'in_progress', 'completed')),
    started_at DATETIME,
    completed_at DATETIME,
    time_spent_minutes INTEGER DEFAULT 0,
    notes TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (lesson_id) REFERENCES learning_lessons(id) ON DELETE CASCADE,
    FOREIGN KEY (course_id) REFERENCES learning_courses(id) ON DELETE CASCADE,
    UNIQUE(user_id, lesson_id)
);

-- Course ratings and reviews table
CREATE TABLE IF NOT EXISTS learning_course_reviews (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    course_id TEXT NOT NULL,
    rating INTEGER NOT NULL CHECK (rating &gt;= 1 AND rating &lt;= 5),
    review TEXT,
    is_verified BOOLEAN DEFAULT false, -- true if user completed the course
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (course_id) REFERENCES learning_courses(id) ON DELETE CASCADE,
    UNIQUE(user_id, course_id)
);

-- Learning achievements/certificates table
CREATE TABLE IF NOT EXISTS learning_achievements (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    course_id TEXT NOT NULL,
    achievement_type TEXT NOT NULL CHECK (achievement_type IN ('completion', 'excellence', 'speed', 'consistency')),
    title TEXT NOT NULL,
    description TEXT,
    badge_url TEXT,
    certificate_url TEXT,
    earned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (course_id) REFERENCES learning_courses(id) ON DELETE CASCADE
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_learning_courses_category ON learning_courses(category_id);
CREATE INDEX IF NOT EXISTS idx_learning_courses_status ON learning_courses(status);
CREATE INDEX IF NOT EXISTS idx_learning_courses_level ON learning_courses(level);
CREATE INDEX IF NOT EXISTS idx_learning_courses_type ON learning_courses(type);
CREATE INDEX IF NOT EXISTS idx_learning_courses_featured ON learning_courses(is_featured);
CREATE INDEX IF NOT EXISTS idx_learning_lessons_course ON learning_lessons(course_id);
CREATE INDEX IF NOT EXISTS idx_user_course_progress_user ON user_course_progress(user_id);
CREATE INDEX IF NOT EXISTS idx_user_course_progress_course ON user_course_progress(course_id);
CREATE INDEX IF NOT EXISTS idx_user_lesson_progress_user ON user_lesson_progress(user_id);
CREATE INDEX IF NOT EXISTS idx_user_lesson_progress_lesson ON user_lesson_progress(lesson_id);
CREATE INDEX IF NOT EXISTS idx_learning_course_reviews_course ON learning_course_reviews(course_id);
CREATE INDEX IF NOT EXISTS idx_learning_achievements_user ON learning_achievements(user_id);
`

const createRemindersTable = `
CREATE TABLE IF NOT EXISTS reminders (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    reminder_type TEXT NOT NULL DEFAULT 'once', -- 'once', 'daily', 'weekly', 'monthly'
    scheduled_at DATETIME NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    is_completed BOOLEAN DEFAULT FALSE,
    notification_sent BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_reminders_user_id ON reminders(user_id);
CREATE INDEX IF NOT EXISTS idx_reminders_scheduled_at ON reminders(scheduled_at);
CREATE INDEX IF NOT EXISTS idx_reminders_type ON reminders(reminder_type);
CREATE INDEX IF NOT EXISTS idx_reminders_enabled ON reminders(is_enabled);
CREATE INDEX IF NOT EXISTS idx_reminders_completed ON reminders(is_completed);
`

const createSharesAndDividendsTables = `
-- Shares ownership table
CREATE TABLE IF NOT EXISTS shares (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    member_id TEXT NOT NULL,
    share_type TEXT NOT NULL DEFAULT 'ordinary', -- 'ordinary', 'preferred'
    shares_owned INTEGER NOT NULL DEFAULT 0,
    share_value REAL NOT NULL DEFAULT 0,
    total_value REAL NOT NULL DEFAULT 0,
    purchase_date DATETIME NOT NULL,
    certificate_number TEXT,
    status TEXT NOT NULL DEFAULT 'active', -- 'active', 'transferred', 'redeemed'
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id) ON DELETE CASCADE,
    FOREIGN KEY (member_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Dividend declarations table
CREATE TABLE IF NOT EXISTS dividend_declarations (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    declaration_date DATETIME NOT NULL,
    dividend_per_share REAL NOT NULL,
    total_dividend_amount REAL NOT NULL,
    payment_date DATETIME,
    status TEXT NOT NULL DEFAULT 'declared', -- 'declared', 'approved', 'paid', 'cancelled'
    declared_by TEXT NOT NULL,
    approved_by TEXT,
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id) ON DELETE CASCADE,
    FOREIGN KEY (declared_by) REFERENCES users(id),
    FOREIGN KEY (approved_by) REFERENCES users(id)
);

-- Individual dividend payments table
CREATE TABLE IF NOT EXISTS dividend_payments (
    id TEXT PRIMARY KEY,
    dividend_declaration_id TEXT NOT NULL,
    member_id TEXT NOT NULL,
    shares_eligible INTEGER NOT NULL,
    dividend_amount REAL NOT NULL,
    payment_status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'paid', 'failed'
    payment_date DATETIME,
    payment_method TEXT,
    transaction_reference TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (dividend_declaration_id) REFERENCES dividend_declarations(id) ON DELETE CASCADE,
    FOREIGN KEY (member_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Share transactions table (for transfers, purchases, redemptions)
CREATE TABLE IF NOT EXISTS share_transactions (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    from_member_id TEXT,
    to_member_id TEXT,
    transaction_type TEXT NOT NULL, -- 'purchase', 'transfer', 'redemption', 'split'
    shares_count INTEGER NOT NULL,
    share_value REAL NOT NULL,
    total_amount REAL NOT NULL,
    transaction_date DATETIME NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'completed', 'cancelled'
    approved_by TEXT,
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id) ON DELETE CASCADE,
    FOREIGN KEY (from_member_id) REFERENCES users(id),
    FOREIGN KEY (to_member_id) REFERENCES users(id),
    FOREIGN KEY (approved_by) REFERENCES users(id)
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_shares_chama_member ON shares(chama_id, member_id);
CREATE INDEX IF NOT EXISTS idx_shares_status ON shares(status);
CREATE INDEX IF NOT EXISTS idx_dividend_declarations_chama ON dividend_declarations(chama_id);
CREATE INDEX IF NOT EXISTS idx_dividend_declarations_status ON dividend_declarations(status);
CREATE INDEX IF NOT EXISTS idx_dividend_payments_declaration ON dividend_payments(dividend_declaration_id);
CREATE INDEX IF NOT EXISTS idx_dividend_payments_member ON dividend_payments(member_id);
CREATE INDEX IF NOT EXISTS idx_dividend_payments_status ON dividend_payments(payment_status);
CREATE INDEX IF NOT EXISTS idx_share_transactions_chama ON share_transactions(chama_id);
CREATE INDEX IF NOT EXISTS idx_share_transactions_type ON share_transactions(transaction_type);
CREATE INDEX IF NOT EXISTS idx_share_transactions_status ON share_transactions(status);
`

const createPollsAndVotingTables = `
-- Polls table for voting and role escalation
CREATE TABLE IF NOT EXISTS polls (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    poll_type TEXT NOT NULL, -- 'general', 'Election / Voting', 'financial_decision'
    created_by TEXT NOT NULL,
    start_date DATETIME NOT NULL,
    end_date DATETIME NOT NULL,
    status TEXT NOT NULL DEFAULT 'active', -- 'active', 'completed', 'cancelled'
    is_anonymous BOOLEAN DEFAULT TRUE,
    requires_majority BOOLEAN DEFAULT TRUE,
    majority_percentage REAL DEFAULT 50.0,
    total_eligible_voters INTEGER DEFAULT 0,
    total_votes_cast INTEGER DEFAULT 0,
    result TEXT, -- 'passed', 'failed', 'pending'
    result_declared_at DATETIME,
    metadata TEXT, -- JSON for additional poll-specific data
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id) ON DELETE CASCADE,
    FOREIGN KEY (created_by) REFERENCES users(id)
);

-- Poll options table
CREATE TABLE IF NOT EXISTS poll_options (
    id TEXT PRIMARY KEY,
    poll_id TEXT NOT NULL,
    option_text TEXT NOT NULL,
    option_order INTEGER NOT NULL DEFAULT 0,
    vote_count INTEGER DEFAULT 0,
    metadata TEXT, -- JSON for option-specific data (e.g., candidate info for role escalation)
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (poll_id) REFERENCES polls(id) ON DELETE CASCADE
);

-- Votes table (anonymous voting)
CREATE TABLE IF NOT EXISTS votes (
    id TEXT PRIMARY KEY,
    poll_id TEXT NOT NULL,
    option_id TEXT NOT NULL,
    voter_hash TEXT NOT NULL, -- Hashed voter ID for anonymity
    vote_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    is_valid BOOLEAN DEFAULT TRUE,
    FOREIGN KEY (poll_id) REFERENCES polls(id) ON DELETE CASCADE,
    FOREIGN KEY (option_id) REFERENCES poll_options(id) ON DELETE CASCADE,
    UNIQUE(poll_id, voter_hash) -- One vote per voter per poll
);

-- Role escalation requests table
CREATE TABLE IF NOT EXISTS Election / Voting_requests (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    candidate_id TEXT NOT NULL,
    current_role TEXT NOT NULL,
    requested_role TEXT NOT NULL,
    requested_by TEXT NOT NULL,
    poll_id TEXT,
    status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'approved', 'rejected', 'voting'
    justification TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id) ON DELETE CASCADE,
    FOREIGN KEY (candidate_id) REFERENCES users(id),
    FOREIGN KEY (requested_by) REFERENCES users(id),
    FOREIGN KEY (poll_id) REFERENCES polls(id)
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_polls_chama ON polls(chama_id);
CREATE INDEX IF NOT EXISTS idx_polls_status ON polls(status);
CREATE INDEX IF NOT EXISTS idx_polls_type ON polls(poll_type);
CREATE INDEX IF NOT EXISTS idx_polls_dates ON polls(start_date, end_date);
CREATE INDEX IF NOT EXISTS idx_poll_options_poll ON poll_options(poll_id);
CREATE INDEX IF NOT EXISTS idx_votes_poll ON votes(poll_id);
CREATE INDEX IF NOT EXISTS idx_votes_option ON votes(option_id);
CREATE INDEX IF NOT EXISTS idx_votes_hash ON votes(voter_hash);
CREATE INDEX IF NOT EXISTS idx_Election / Voting_chama ON Election / Voting_requests(chama_id);
CREATE INDEX IF NOT EXISTS idx_Election / Voting_candidate ON Election / Voting_requests(candidate_id);
CREATE INDEX IF NOT EXISTS idx_Election / Voting_status ON Election / Voting_requests(status);
`

const createDisbursementTables = `
-- Disbursement batches table (for mass distributions)
CREATE TABLE IF NOT EXISTS disbursement_batches (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    batch_type TEXT NOT NULL, -- 'dividend', 'shares', 'savings', 'loan'
    title TEXT NOT NULL,
    description TEXT,
    total_amount REAL NOT NULL,
    total_recipients INTEGER NOT NULL,
    initiated_by TEXT NOT NULL,
    approved_by TEXT,
    status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'approved', 'processing', 'completed', 'failed'
    approval_required BOOLEAN DEFAULT TRUE,
    scheduled_date DATETIME,
    processed_date DATETIME,
    metadata TEXT, -- JSON for batch-specific data
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id) ON DELETE CASCADE,
    FOREIGN KEY (initiated_by) REFERENCES users(id),
    FOREIGN KEY (approved_by) REFERENCES users(id)
);

-- Individual disbursements table
CREATE TABLE IF NOT EXISTS disbursements (
    id TEXT PRIMARY KEY,
    batch_id TEXT NOT NULL,
    recipient_id TEXT NOT NULL,
    disbursement_type TEXT NOT NULL, -- 'dividend', 'share_redemption', 'savings_withdrawal', 'loan_disbursement'
    amount REAL NOT NULL,
    currency TEXT DEFAULT 'KES',
    payment_method TEXT NOT NULL, -- 'bank_transfer', 'mobile_money', 'cash'
    account_details TEXT, -- JSON with payment details
    status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'processing', 'completed', 'failed'
    transaction_reference TEXT,
    processed_date DATETIME,
    failure_reason TEXT,
    retry_count INTEGER DEFAULT 0,
    metadata TEXT, -- JSON for disbursement-specific data
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (batch_id) REFERENCES disbursement_batches(id) ON DELETE CASCADE,
    FOREIGN KEY (recipient_id) REFERENCES users(id)
);

-- Financial transparency log table
CREATE TABLE IF NOT EXISTS financial_transparency_log (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    activity_type TEXT NOT NULL, -- 'disbursement', 'revenue', 'expense', 'contribution'
    title TEXT NOT NULL,
    description TEXT,
    amount REAL NOT NULL,
    currency TEXT DEFAULT 'KES',
    transaction_type TEXT NOT NULL, -- 'debit', 'credit'
    reference_id TEXT, -- Reference to related transaction/disbursement
    reference_type TEXT, -- 'disbursement_batch', 'transaction', 'contribution'
    performed_by TEXT NOT NULL,
    affected_members TEXT, -- JSON array of affected member IDs
    visibility TEXT NOT NULL DEFAULT 'all_members', -- 'all_members', 'officials_only'
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id) ON DELETE CASCADE,
    FOREIGN KEY (performed_by) REFERENCES users(id)
);

-- Reports and invoices table
CREATE TABLE IF NOT EXISTS financial_reports (
    id TEXT PRIMARY KEY,
    chama_id TEXT NOT NULL,
    report_type TEXT NOT NULL, -- 'monthly_statement', 'dividend_report', 'disbursement_report', 'transparency_report'
    title TEXT NOT NULL,
    description TEXT,
    report_period_start DATETIME,
    report_period_end DATETIME,
    generated_by TEXT NOT NULL,
    file_path TEXT, -- Path to generated PDF/document
    file_size INTEGER,
    status TEXT NOT NULL DEFAULT 'generating', -- 'generating', 'ready', 'failed'
    download_count INTEGER DEFAULT 0,
    is_public BOOLEAN DEFAULT FALSE,
    metadata TEXT, -- JSON for report-specific data
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chama_id) REFERENCES chamas(id) ON DELETE CASCADE,
    FOREIGN KEY (generated_by) REFERENCES users(id)
);`

const createDeliveryContactsTable = `
-- Delivery contacts table (for marketplace delivery management)
CREATE TABLE IF NOT EXISTS delivery_contacts (
    id TEXT PRIMARY KEY,
    seller_id TEXT NOT NULL,
    user_id TEXT,
    name TEXT NOT NULL,
    phone TEXT,
    email TEXT,
    address TEXT,
    notes TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (seller_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
);

-- Create indexes for delivery contacts
CREATE INDEX IF NOT EXISTS idx_delivery_contacts_seller ON delivery_contacts(seller_id);
CREATE INDEX IF NOT EXISTS idx_delivery_contacts_user ON delivery_contacts(user_id);
CREATE INDEX IF NOT EXISTS idx_delivery_contacts_active ON delivery_contacts(is_active);
`

const createMarketplaceRolesTable = `
-- Marketplace roles table (for tracking user roles in marketplace)
CREATE TABLE IF NOT EXISTS marketplace_roles (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    user_id TEXT NOT NULL,
    role TEXT NOT NULL CHECK (role IN ('buyer', 'seller', 'delivery_person')),
    auto_detected BOOLEAN DEFAULT FALSE,
    registration_data TEXT, -- JSON data from registration
    is_active BOOLEAN DEFAULT TRUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE(user_id, role)
);

-- Create indexes for marketplace roles
CREATE INDEX IF NOT EXISTS idx_marketplace_roles_user ON marketplace_roles(user_id);
CREATE INDEX IF NOT EXISTS idx_marketplace_roles_role ON marketplace_roles(role);
CREATE INDEX IF NOT EXISTS idx_marketplace_roles_active ON marketplace_roles(is_active);
`

const populateExistingSellers = `
-- Populate existing sellers from products table
INSERT OR IGNORE INTO marketplace_roles (user_id, role, auto_detected, registration_data, is_active, created_at, updated_at)
SELECT DISTINCT
    p.seller_id,
    'seller',
    1,
    json_object(
        'auto_detected', 1,
        'product_count', (SELECT COUNT(*) FROM products p2 WHERE p2.seller_id = p.seller_id),
        'first_product_date', (SELECT MIN(created_at) FROM products p3 WHERE p3.seller_id = p.seller_id),
        'migration_date', datetime('now')
    ),
    1,
    datetime('now'),
    datetime('now')
FROM products p
WHERE p.seller_id IS NOT NULL
AND p.seller_id != ''
AND NOT EXISTS (
    SELECT 1 FROM marketplace_roles mr
    WHERE mr.user_id = p.seller_id AND mr.role = 'seller'
);
`

// addOrderItemDeliveryPersonField adds delivery_person_id field to order_items table
const addOrderItemDeliveryPersonField = "SELECT 1" // Placeholder - actual logic in migration function

// addMissingOrderItemDeliveryPersonField adds delivery_person_id field to order_items table if it doesn't exist
func addMissingOrderItemDeliveryPersonField(db *sql.DB) error <span class="cov8" title="1">{
        // Check if delivery_person_id column exists
        var exists bool
        query := `SELECT COUNT(*) FROM pragma_table_info('order_items') WHERE name = 'delivery_person_id'`
        err := db.QueryRow(query).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if delivery_person_id column exists: %w", err)
        }</span>

        // Add column if it doesn't exist
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                alterQuery := "ALTER TABLE order_items ADD COLUMN delivery_person_id TEXT"
                if _, err := db.Exec(alterQuery); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add delivery_person_id column: %w", err)
                }</span>
                <span class="cov8" title="1">log.Printf("Added delivery_person_id column to order_items table")</span>
        } else<span class="cov0" title="0"> {
                log.Printf("Column delivery_person_id already exists in order_items table")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// addOrderItemDeliveryFields adds delivery-related fields to order_items table
const addOrderItemDeliveryFields = "SELECT 1" // Placeholder - actual logic in migration function

// addMissingOrderItemDeliveryFields adds delivery fields to order_items table if they don't exist
func addMissingOrderItemDeliveryFields(db *sql.DB) error <span class="cov0" title="0">{
        columns := []struct {
                name     string
                dataType string
        }{
                {"delivery_person_id", "TEXT"},
                {"delivery_status", "TEXT DEFAULT 'pending'"},
                {"delivery_fee", "REAL DEFAULT 0"},
                {"buyer_notes", "TEXT"},
                {"delivery_notes", "TEXT"},
                {"assigned_at", "DATETIME"},
                {"delivered_at", "DATETIME"},
        }

        for _, col := range columns </span><span class="cov0" title="0">{
                // Check if column exists
                var exists bool
                query := `SELECT COUNT(*) FROM pragma_table_info('order_items') WHERE name = ?`
                err := db.QueryRow(query, col.name).Scan(&amp;exists)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check if column %s exists: %w", col.name, err)
                }</span>

                // Add column if it doesn't exist
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        alterQuery := fmt.Sprintf("ALTER TABLE order_items ADD COLUMN %s %s", col.name, col.dataType)
                        if _, err := db.Exec(alterQuery); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add column %s: %w", col.name, err)
                        }</span>
                        <span class="cov0" title="0">log.Printf("Added column %s to order_items table", col.name)</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("Column %s already exists in order_items table", col.name)
                }</span>
        }

        // Add foreign key constraint for delivery_person_id if it doesn't exist
        // Note: SQLite doesn't support adding foreign key constraints to existing tables,
        // so we'll handle this at the application level

        <span class="cov0" title="0">return nil</span>
}

// addEnhancedLearningContentFields adds enhanced content fields to learning_courses table
const addEnhancedLearningContentFields = "SELECT 1" // Placeholder - actual logic in migration function

// createQuizResultsTable creates the quiz_results table for storing quiz results
const createQuizResultsTable = `
CREATE TABLE IF NOT EXISTS quiz_results (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    user_id TEXT NOT NULL,
    course_id TEXT NOT NULL,
    score INTEGER NOT NULL,
    correct_answers INTEGER NOT NULL,
    total_questions INTEGER NOT NULL,
    passed BOOLEAN NOT NULL DEFAULT 0,
    time_taken INTEGER, -- in seconds
    detailed_results TEXT, -- JSON string with detailed results
    created_at DATETIME NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (course_id) REFERENCES learning_courses(id) ON DELETE CASCADE
);`

// addMissingEnhancedLearningContentFields adds enhanced learning content fields if they don't exist
func addMissingEnhancedLearningContentFields(db *sql.DB) error <span class="cov8" title="1">{
        // First check if the learning_courses table exists
        var tableExists bool
        query := `SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='learning_courses'`
        err := db.QueryRow(query).Scan(&amp;tableExists)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if learning_courses table exists: %w", err)
        }</span>

        <span class="cov8" title="1">if !tableExists </span><span class="cov8" title="1">{
                log.Printf("learning_courses table does not exist, skipping enhanced learning content fields migration")
                return nil
        }</span>

        // Define the columns to add
        <span class="cov0" title="0">columns := []struct {
                name     string
                dataType string
        }{
                {"video_url", "TEXT"},
                {"quiz_questions", "TEXT"},
                {"article_content", "TEXT"},
                {"course_structure", "TEXT"},
        }

        // Check and add each column
        for _, col := range columns </span><span class="cov0" title="0">{
                var exists bool
                query := `SELECT COUNT(*) FROM pragma_table_info('learning_courses') WHERE name = ?`
                err := db.QueryRow(query, col.name).Scan(&amp;exists)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check if column %s exists: %w", col.name, err)
                }</span>

                // Add column if it doesn't exist
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        alterQuery := fmt.Sprintf("ALTER TABLE learning_courses ADD COLUMN %s %s", col.name, col.dataType)
                        if _, err := db.Exec(alterQuery); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add column %s: %w", col.name, err)
                        }</span>
                        <span class="cov0" title="0">log.Printf("Added column %s to learning_courses table", col.name)</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("Column %s already exists in learning_courses table", col.name)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package middleware

import (
        "net/http"
        "strings"
        "vaultke-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// AuthMiddleware contains the auth service for token validation
type AuthMiddleware struct {
        authService *services.AuthService
}

// NewAuthMiddleware creates a new auth middleware
func NewAuthMiddleware(authService *services.AuthService) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                authService: authService,
        }
}</span>

// AuthRequired is a middleware that checks for valid JWT token
func (m *AuthMiddleware) AuthRequired() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get token from Authorization header
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error":   "Authorization header required",
                        })
                        c.Abort()
                        return
                }</span>

                // Check if header starts with "Bearer "
                <span class="cov0" title="0">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error":   "Invalid authorization header format",
                        })
                        c.Abort()
                        return
                }</span>

                // Extract token
                <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, "Bearer ")
                if token == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error":   "Token required",
                        })
                        c.Abort()
                        return
                }</span>

                // Validate JWT token
                <span class="cov0" title="0">claims, err := m.authService.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error":   "Invalid token: " + err.Error(),
                        })
                        c.Abort()
                        return
                }</span>

                // Set user information in context
                <span class="cov0" title="0">c.Set("userID", claims.UserID)
                c.Set("userRole", claims.Role)
                c.Set("userEmail", claims.Email)

                c.Next()</span>
        }
}

// OptionalAuth is a middleware that optionally validates JWT token
func (m *AuthMiddleware) OptionalAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get token from Authorization header
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Check if header starts with "Bearer "
                <span class="cov0" title="0">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Extract token
                <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, "Bearer ")
                if token == "" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Validate JWT token
                <span class="cov0" title="0">claims, err := m.authService.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Set user information in context
                <span class="cov0" title="0">c.Set("userID", claims.UserID)
                c.Set("userRole", claims.Role)
                c.Set("userEmail", claims.Email)

                c.Next()</span>
        }
}

// RequireRole is a middleware that checks if the user has a specific role
func (m *AuthMiddleware) RequireRole(requiredRole string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                userRole := c.GetString("userRole")
                if userRole == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error":   "User not authenticated",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if userRole != requiredRole </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "success": false,
                                "error":   "Insufficient permissions",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireRoles is a middleware that checks if the user has one of the specified roles
func (m *AuthMiddleware) RequireRoles(requiredRoles ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                userRole := c.GetString("userRole")
                if userRole == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error":   "User not authenticated",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">hasValidRole := false
                for _, role := range requiredRoles </span><span class="cov0" title="0">{
                        if userRole == role </span><span class="cov0" title="0">{
                                hasValidRole = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !hasValidRole </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "success": false,
                                "error":   "Insufficient permissions",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "golang.org/x/time/rate"
)

// SecurityConfig holds security middleware configuration
type SecurityConfig struct {
        MaxRequestSize    int64
        RateLimitRequests int
        RateLimitWindow   time.Duration
        AllowedOrigins    []string
        RequireHTTPS      bool
}

// DefaultSecurityConfig returns default security configuration
func DefaultSecurityConfig() *SecurityConfig <span class="cov0" title="0">{
        return &amp;SecurityConfig{
                MaxRequestSize:    10 * 1024 * 1024, // 10MB
                RateLimitRequests: 100,
                RateLimitWindow:   time.Minute,
                AllowedOrigins:    []string{"*"}, // Configure properly in production
                RequireHTTPS:      false,         // Set to true in production
        }
}</span>

// SecurityMiddleware provides comprehensive security protection
func SecurityMiddleware(config *SecurityConfig) gin.HandlerFunc <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultSecurityConfig()
        }</span>

        // Rate limiter per IP
        <span class="cov0" title="0">limiters := make(map[string]*rate.Limiter)

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 1. Request size validation
                if c.Request.ContentLength &gt; config.MaxRequestSize </span><span class="cov0" title="0">{
                        c.JSON(http.StatusRequestEntityTooLarge, gin.H{
                                "success": false,
                                "error":   "Request body too large",
                        })
                        c.Abort()
                        return
                }</span>

                // 2. Rate limiting per IP
                <span class="cov0" title="0">clientIP := c.ClientIP()
                limiter, exists := limiters[clientIP]
                if !exists </span><span class="cov0" title="0">{
                        limiter = rate.NewLimiter(rate.Every(config.RateLimitWindow/time.Duration(config.RateLimitRequests)), config.RateLimitRequests)
                        limiters[clientIP] = limiter
                }</span>

                <span class="cov0" title="0">if !limiter.Allow() </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "success": false,
                                "error":   "Rate limit exceeded",
                        })
                        c.Abort()
                        return
                }</span>

                // 3. Content-Type validation for POST/PUT requests
                <span class="cov0" title="0">if c.Request.Method == "POST" || c.Request.Method == "PUT" || c.Request.Method == "PATCH" </span><span class="cov0" title="0">{
                        contentType := c.GetHeader("Content-Type")
                        fmt.Printf("🔍 Security Middleware - Content-Type: '%s' for %s %s\n", contentType, c.Request.Method, c.Request.URL.Path)

                        // Skip Content-Type validation for upload endpoints to debug
                        if strings.Contains(c.Request.URL.Path, "/upload/") </span><span class="cov0" title="0">{
                                fmt.Printf("🔧 Skipping Content-Type validation for upload endpoint\n")
                                c.Next()
                                return
                        }</span>

                        <span class="cov0" title="0">if contentType == "" </span><span class="cov0" title="0">{
                                fmt.Printf("❌ Missing Content-Type header for %s %s\n", c.Request.Method, c.Request.URL.Path)
                                c.JSON(http.StatusBadRequest, gin.H{
                                        "success": false,
                                        "error":   "Content-Type header required",
                                })
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">validContentTypes := []string{
                                "application/json",
                                "multipart/form-data",
                                "application/x-www-form-urlencoded",
                        }

                        isValid := false
                        for _, validType := range validContentTypes </span><span class="cov0" title="0">{
                                if strings.Contains(contentType, validType) </span><span class="cov0" title="0">{
                                        isValid = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                                fmt.Printf("❌ Invalid Content-Type: '%s' for %s %s\n", contentType, c.Request.Method, c.Request.URL.Path)
                                fmt.Printf("❌ Valid types: %v\n", validContentTypes)
                                c.JSON(http.StatusUnsupportedMediaType, gin.H{
                                        "success": false,
                                        "error":   "Unsupported content type: " + contentType,
                                })
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("✅ Valid Content-Type: '%s'\n", contentType)</span>
                }

                // 4. Security headers
                <span class="cov0" title="0">c.Header("X-Content-Type-Options", "nosniff")
                c.Header("X-Frame-Options", "DENY")
                c.Header("X-XSS-Protection", "1; mode=block")
                c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
                c.Header("Content-Security-Policy", "default-src 'self'")

                // 5. HTTPS enforcement (if enabled)
                if config.RequireHTTPS &amp;&amp; c.Request.Header.Get("X-Forwarded-Proto") != "https" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUpgradeRequired, gin.H{
                                "success": false,
                                "error":   "HTTPS required",
                        })
                        c.Abort()
                        return
                }</span>

                // 6. Validate User-Agent (block empty or suspicious agents)
                <span class="cov0" title="0">userAgent := c.GetHeader("User-Agent")
                if userAgent == "" || len(userAgent) &lt; 10 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "Invalid User-Agent",
                        })
                        c.Abort()
                        return
                }</span>

                // 7. Block suspicious patterns in URL
                <span class="cov0" title="0">suspiciousPatterns := []string{
                        "../", "..\\", "&lt;script", "javascript:", "vbscript:",
                        "onload=", "onerror=", "eval(", "expression(",
                }

                requestURI := strings.ToLower(c.Request.RequestURI)
                for _, pattern := range suspiciousPatterns </span><span class="cov0" title="0">{
                        if strings.Contains(requestURI, pattern) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusBadRequest, gin.H{
                                        "success": false,
                                        "error":   "Suspicious request pattern detected",
                                })
                                c.Abort()
                                return
                        }</span>
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}

// InputValidationMiddleware validates common input patterns
func InputValidationMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Validate query parameters
                for key, values := range c.Request.URL.Query() </span><span class="cov0" title="0">{
                        for _, value := range values </span><span class="cov0" title="0">{
                                if len(value) &gt; 1000 </span><span class="cov0" title="0">{ // Max query param length
                                        c.JSON(http.StatusBadRequest, gin.H{
                                                "success": false,
                                                "error":   "Query parameter too long: " + key,
                                        })
                                        c.Abort()
                                        return
                                }</span>

                                // Check for injection patterns
                                <span class="cov0" title="0">dangerous := []string{
                                        "'", "\"", "&lt;script", "javascript:", "onload=", "onerror=",
                                        "onclick=", "onmouseover=", "onfocus=", "onblur=", "onchange=",
                                        "onsubmit=", "&lt;iframe", "&lt;object", "&lt;embed", "&lt;link", "&lt;meta",
                                        "data:text/html", "eval(", "expression(", "url(javascript:",
                                        "&amp;#", "&amp;#x", "&lt;svg", "&lt;img", "union", "select", "insert",
                                        "update", "delete", "drop", "create", "alter", "truncate",
                                        "exec", "execute", "declare", "cast", "convert", "grant", "revoke",
                                }
                                lowerValue := strings.ToLower(value)
                                for _, pattern := range dangerous </span><span class="cov0" title="0">{
                                        if strings.Contains(lowerValue, pattern) </span><span class="cov0" title="0">{
                                                c.JSON(http.StatusBadRequest, gin.H{
                                                        "success": false,
                                                        "error":   "Invalid characters in query parameter: " + key,
                                                })
                                                c.Abort()
                                                return
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}

// FileUploadSecurityMiddleware validates file uploads
func FileUploadSecurityMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.Request.Method == "POST" || c.Request.Method == "PUT" </span><span class="cov0" title="0">{
                        contentType := c.GetHeader("Content-Type")
                        fmt.Printf("🔍 FileUpload Middleware - Content-Type: %s\n", contentType)
                        fmt.Printf("🔍 FileUpload Middleware - Method: %s, Path: %s\n", c.Request.Method, c.Request.URL.Path)

                        if strings.Contains(contentType, "multipart/form-data") </span><span class="cov0" title="0">{
                                fmt.Printf("🔍 Parsing multipart form data...\n")
                                // Parse multipart form with size limit
                                err := c.Request.ParseMultipartForm(5 * 1024 * 1024) // 5MB limit
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("❌ Failed to parse multipart form: %v\n", err)
                                        c.JSON(http.StatusBadRequest, gin.H{
                                                "success": false,
                                                "error":   "Failed to parse multipart form: " + err.Error(),
                                        })
                                        c.Abort()
                                        return
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("✅ Multipart form parsed successfully\n")

                                // Validate uploaded files
                                if c.Request.MultipartForm != nil &amp;&amp; c.Request.MultipartForm.File != nil </span><span class="cov0" title="0">{
                                        // Different allowed types based on endpoint
                                        var allowedTypes map[string]bool

                                        // Check if this is a meeting document upload
                                        if strings.Contains(c.Request.URL.Path, "/meetings/") &amp;&amp; strings.Contains(c.Request.URL.Path, "/documents") </span><span class="cov0" title="0">{
                                                // Allow more file types for meeting documents
                                                allowedTypes = map[string]bool{
                                                        "image/jpeg":         true,
                                                        "image/jpg":          true,
                                                        "image/png":          true,
                                                        "image/webp":         true,
                                                        "image/gif":          true,
                                                        "application/pdf":    true,
                                                        "application/msword": true,
                                                        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": true, // .docx
                                                        "application/vnd.ms-excel": true,
                                                        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":         true, // .xlsx
                                                        "application/vnd.ms-powerpoint":                                             true,
                                                        "application/vnd.openxmlformats-officedocument.presentationml.presentation": true, // .pptx
                                                        "text/plain": true,
                                                        "text/csv":   true,
                                                }
                                        }</span> else<span class="cov0" title="0"> {
                                                // Default to images only for other endpoints (like avatar uploads)
                                                allowedTypes = map[string]bool{
                                                        "image/jpeg": true,
                                                        "image/jpg":  true,
                                                        "image/png":  true,
                                                        "image/webp": true,
                                                        "image/gif":  true,
                                                }
                                        }</span>

                                        <span class="cov0" title="0">for _, files := range c.Request.MultipartForm.File </span><span class="cov0" title="0">{
                                                for _, file := range files </span><span class="cov0" title="0">{
                                                        // Check file size
                                                        if file.Size &gt; 5*1024*1024 </span><span class="cov0" title="0">{ // 5MB per file
                                                                c.JSON(http.StatusBadRequest, gin.H{
                                                                        "success": false,
                                                                        "error":   "File too large: " + file.Filename,
                                                                })
                                                                c.Abort()
                                                                return
                                                        }</span>

                                                        // Check file type
                                                        <span class="cov0" title="0">contentType := file.Header.Get("Content-Type")
                                                        if !allowedTypes[contentType] </span><span class="cov0" title="0">{
                                                                c.JSON(http.StatusBadRequest, gin.H{
                                                                        "success": false,
                                                                        "error":   "Invalid file type: " + file.Filename,
                                                                })
                                                                c.Abort()
                                                                return
                                                        }</span>

                                                        // Check filename for dangerous patterns
                                                        <span class="cov0" title="0">filename := strings.ToLower(file.Filename)
                                                        dangerousExtensions := []string{".exe", ".bat", ".cmd", ".scr", ".pif", ".js", ".vbs", ".php", ".asp"}
                                                        for _, ext := range dangerousExtensions </span><span class="cov0" title="0">{
                                                                if strings.HasSuffix(filename, ext) </span><span class="cov0" title="0">{
                                                                        c.JSON(http.StatusBadRequest, gin.H{
                                                                                "success": false,
                                                                                "error":   "Dangerous file type: " + file.Filename,
                                                                        })
                                                                        c.Abort()
                                                                        return
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}

// AuthRateLimitMiddleware provides stricter rate limiting for auth endpoints
func AuthRateLimitMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        // Stricter rate limiting for auth endpoints: 5 requests per minute per IP
        authLimiters := make(map[string]*rate.Limiter)

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                clientIP := c.ClientIP()

                limiter, exists := authLimiters[clientIP]
                if !exists </span><span class="cov0" title="0">{
                        // 5 requests per minute for auth endpoints
                        limiter = rate.NewLimiter(rate.Every(time.Minute/5), 5)
                        authLimiters[clientIP] = limiter
                }</span>

                <span class="cov0" title="0">if !limiter.Allow() </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "success": false,
                                "error":   "Too many authentication attempts. Please try again later.",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package models

import (
        "encoding/json"
        "time"
)

// ChamaStatus represents chama status
type ChamaStatus string

const (
        ChamaStatusActive    ChamaStatus = "active"
        ChamaStatusSuspended ChamaStatus = "suspended"
        ChamaStatusPending   ChamaStatus = "pending"
        ChamaStatusDissolved ChamaStatus = "dissolved"
)

// ChamaType represents the type of chama
type ChamaType string

const (
        ChamaTypeInvestment ChamaType = "investment"
        ChamaTypeSavings    ChamaType = "savings"
        ChamaTypeBusiness   ChamaType = "business"
        ChamaTypeSocial     ChamaType = "social"
        ChamaTypeMixed      ChamaType = "mixed"
)

// ContributionFrequency represents how often contributions are made
type ContributionFrequency string

const (
        ContributionFrequencyWeekly    ContributionFrequency = "weekly"
        ContributionFrequencyMonthly   ContributionFrequency = "monthly"
        ContributionFrequencyQuarterly ContributionFrequency = "quarterly"
        ContributionFrequencyCustom    ContributionFrequency = "custom"
)

// MeetingSchedule represents the meeting schedule for a chama
type MeetingSchedule struct {
        Frequency    string `json:"frequency"`    // weekly, monthly, quarterly
        DayOfWeek    *int   `json:"dayOfWeek"`    // 0 = Sunday, 1 = Monday, etc.
        DayOfMonth   *int   `json:"dayOfMonth"`   // 1-31
        Time         string `json:"time"`         // HH:MM format
}

// Chama represents a chama (investment group) in the system
type Chama struct {
        ID                     string                `json:"id" db:"id"`
        Name                   string                `json:"name" db:"name"`
        Description            *string               `json:"description,omitempty" db:"description"`
        Type                   ChamaType             `json:"type" db:"type"`
        Status                 ChamaStatus           `json:"status" db:"status"`
        Avatar                 *string               `json:"avatar,omitempty" db:"avatar"`
        County                 string                `json:"county" db:"county"`
        Town                   string                `json:"town" db:"town"`
        Latitude               *float64              `json:"latitude,omitempty" db:"latitude"`
        Longitude              *float64              `json:"longitude,omitempty" db:"longitude"`
        ContributionAmount     float64               `json:"contributionAmount" db:"contribution_amount"`
        ContributionFrequency  ContributionFrequency `json:"contributionFrequency" db:"contribution_frequency"`
        MaxMembers             *int                  `json:"maxMembers,omitempty" db:"max_members"`
        CurrentMembers         int                   `json:"currentMembers" db:"current_members"`
        TotalFunds             float64               `json:"totalFunds" db:"total_funds"`
        IsPublic               bool                  `json:"isPublic" db:"is_public"`
        RequiresApproval       bool                  `json:"requiresApproval" db:"requires_approval"`
        Rules                  []string              `json:"rules" db:"rules"`
        MeetingSchedule        *MeetingSchedule      `json:"meetingSchedule,omitempty" db:"meeting_schedule"`
        Permissions            map[string]interface{} `json:"permissions,omitempty" db:"permissions"`
        CreatedBy              string                `json:"createdBy" db:"created_by"`
        CreatedAt              time.Time             `json:"createdAt" db:"created_at"`
        UpdatedAt              time.Time             `json:"updatedAt" db:"updated_at"`
}

// ChamaMember represents a member of a chama
type ChamaMember struct {
        ID                  string     `json:"id" db:"id"`
        ChamaID             string     `json:"chamaId" db:"chama_id"`
        UserID              string     `json:"userId" db:"user_id"`
        Role                ChamaRole  `json:"role" db:"role"`
        JoinedAt            time.Time  `json:"joinedAt" db:"joined_at"`
        IsActive            bool       `json:"isActive" db:"is_active"`
        TotalContributions  float64    `json:"totalContributions" db:"total_contributions"`
        LastContribution    *time.Time `json:"lastContribution,omitempty" db:"last_contribution"`
        Rating              float64    `json:"rating" db:"rating"`
        TotalRatings        int        `json:"totalRatings" db:"total_ratings"`
        
        // Joined user data (populated when needed)
        User *User `json:"user,omitempty"`
}

// ChamaCreation represents data for creating a new chama
type ChamaCreation struct {
        Name                  string                `json:"name" validate:"required"`
        Description           *string               `json:"description,omitempty"`
        Type                  ChamaType             `json:"type" validate:"required"`
        County                string                `json:"county" validate:"required"`
        Town                  string                `json:"town" validate:"required"`
        Latitude              *float64              `json:"latitude,omitempty"`
        Longitude             *float64              `json:"longitude,omitempty"`
        ContributionAmount    float64               `json:"contributionAmount" validate:"required,gt=0"`
        ContributionFrequency ContributionFrequency `json:"contributionFrequency" validate:"required"`
        MaxMembers            *int                  `json:"maxMembers,omitempty"`
        IsPublic              bool                  `json:"isPublic"`
        RequiresApproval      bool                  `json:"requiresApproval"`
        Rules                 []string              `json:"rules"`
        MeetingSchedule       *MeetingSchedule      `json:"meetingSchedule,omitempty"`
}

// ChamaUpdate represents data for updating a chama
type ChamaUpdate struct {
        Name                  *string               `json:"name,omitempty"`
        Description           *string               `json:"description,omitempty"`
        Type                  *ChamaType            `json:"type,omitempty"`
        County                *string               `json:"county,omitempty"`
        Town                  *string               `json:"town,omitempty"`
        Latitude              *float64              `json:"latitude,omitempty"`
        Longitude             *float64              `json:"longitude,omitempty"`
        ContributionAmount    *float64              `json:"contributionAmount,omitempty"`
        ContributionFrequency *ContributionFrequency `json:"contributionFrequency,omitempty"`
        MaxMembers            *int                  `json:"maxMembers,omitempty"`
        IsPublic              *bool                 `json:"isPublic,omitempty"`
        RequiresApproval      *bool                 `json:"requiresApproval,omitempty"`
        Rules                 []string              `json:"rules,omitempty"`
        MeetingSchedule       *MeetingSchedule      `json:"meetingSchedule,omitempty"`
}

// GetLocation returns the chama's location as a formatted string
func (c *Chama) GetLocation() string <span class="cov0" title="0">{
        return c.Town + ", " + c.County
}</span>

// HasCoordinates checks if the chama has location coordinates
func (c *Chama) HasCoordinates() bool <span class="cov0" title="0">{
        return c.Latitude != nil &amp;&amp; c.Longitude != nil
}</span>

// GetCoordinates returns the chama's coordinates
func (c *Chama) GetCoordinates() (float64, float64) <span class="cov0" title="0">{
        if c.HasCoordinates() </span><span class="cov0" title="0">{
                return *c.Latitude, *c.Longitude
        }</span>
        <span class="cov0" title="0">return 0, 0</span>
}

// IsActive checks if the chama is active
func (c *Chama) IsActive() bool <span class="cov0" title="0">{
        return c.Status == ChamaStatusActive
}</span>

// IsFull checks if the chama has reached its maximum members
func (c *Chama) IsFull() bool <span class="cov0" title="0">{
        return c.MaxMembers != nil &amp;&amp; c.CurrentMembers &gt;= *c.MaxMembers
}</span>

// CanJoin checks if a user can join the chama
func (c *Chama) CanJoin() bool <span class="cov0" title="0">{
        return c.IsActive() &amp;&amp; !c.IsFull()
}</span>

// GetRulesJSON returns rules as JSON string for database storage
func (c *Chama) GetRulesJSON() (string, error) <span class="cov0" title="0">{
        if len(c.Rules) == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(c.Rules)
        return string(data), err</span>
}

// SetRulesFromJSON sets rules from JSON string
func (c *Chama) SetRulesFromJSON(rulesJSON string) error <span class="cov0" title="0">{
        if rulesJSON == "" </span><span class="cov0" title="0">{
                c.Rules = []string{}
                return nil
        }</span>
        <span class="cov0" title="0">return json.Unmarshal([]byte(rulesJSON), &amp;c.Rules)</span>
}

// GetMeetingScheduleJSON returns meeting schedule as JSON string for database storage
func (c *Chama) GetMeetingScheduleJSON() (string, error) <span class="cov0" title="0">{
        if c.MeetingSchedule == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(c.MeetingSchedule)
        return string(data), err</span>
}

// SetMeetingScheduleFromJSON sets meeting schedule from JSON string
func (c *Chama) SetMeetingScheduleFromJSON(scheduleJSON string) error <span class="cov0" title="0">{
        if scheduleJSON == "" </span><span class="cov0" title="0">{
                c.MeetingSchedule = nil
                return nil
        }</span>
        <span class="cov0" title="0">var schedule MeetingSchedule
        err := json.Unmarshal([]byte(scheduleJSON), &amp;schedule)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.MeetingSchedule = &amp;schedule
        return nil</span>
}

// IsLeader checks if a member role is a leadership role
func (cm *ChamaMember) IsLeader() bool <span class="cov0" title="0">{
        return cm.Role == ChamaRoleChairperson || cm.Role == ChamaRoleTreasurer || cm.Role == ChamaRoleSecretary
}</span>

// CanManageMembers checks if a member can manage other members
func (cm *ChamaMember) CanManageMembers() bool <span class="cov0" title="0">{
        return cm.Role == ChamaRoleChairperson || cm.Role == ChamaRoleSecretary
}</span>

// CanManageFinances checks if a member can manage finances
func (cm *ChamaMember) CanManageFinances() bool <span class="cov0" title="0">{
        return cm.Role == ChamaRoleChairperson || cm.Role == ChamaRoleTreasurer
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package models

import (
        "time"
)

// DividendDeclarationStatus represents the status of a dividend declaration
type DividendDeclarationStatus string

const (
        DividendStatusDeclared  DividendDeclarationStatus = "declared"
        DividendStatusApproved  DividendDeclarationStatus = "approved"
        DividendStatusPaid      DividendDeclarationStatus = "paid"
        DividendStatusCancelled DividendDeclarationStatus = "cancelled"
)

// DividendPaymentStatus represents the status of individual dividend payments
type DividendPaymentStatus string

const (
        DividendPaymentPending DividendPaymentStatus = "pending"
        DividendPaymentPaid    DividendPaymentStatus = "paid"
        DividendPaymentFailed  DividendPaymentStatus = "failed"
)

// DividendDeclaration represents a dividend declaration for a chama
type DividendDeclaration struct {
        ID                  string                    `json:"id" db:"id"`
        ChamaID             string                    `json:"chamaId" db:"chama_id"`
        DeclarationDate     time.Time                 `json:"declarationDate" db:"declaration_date"`
        DividendPerShare    float64                   `json:"dividendPerShare" db:"dividend_per_share"`
        TotalDividendAmount float64                   `json:"totalDividendAmount" db:"total_dividend_amount"`
        PaymentDate         *time.Time                `json:"paymentDate,omitempty" db:"payment_date"`
        Status              DividendDeclarationStatus `json:"status" db:"status"`
        DeclaredBy          string                    `json:"declaredBy" db:"declared_by"`
        ApprovedBy          *string                   `json:"approvedBy,omitempty" db:"approved_by"`
        Description         *string                   `json:"description,omitempty" db:"description"`
        CreatedAt           time.Time                 `json:"createdAt" db:"created_at"`
        UpdatedAt           time.Time                 `json:"updatedAt" db:"updated_at"`
}

// DividendDeclarationWithDetails represents dividend declaration with additional details
type DividendDeclarationWithDetails struct {
        DividendDeclaration
        DeclaredByName    string `json:"declaredByName"`
        ApprovedByName    *string `json:"approvedByName,omitempty"`
        TotalEligibleShares int   `json:"totalEligibleShares"`
        TotalRecipients   int    `json:"totalRecipients"`
        PaidAmount        float64 `json:"paidAmount"`
        PendingAmount     float64 `json:"pendingAmount"`
}

// DividendPayment represents an individual dividend payment to a member
type DividendPayment struct {
        ID                     string                `json:"id" db:"id"`
        DividendDeclarationID  string                `json:"dividendDeclarationId" db:"dividend_declaration_id"`
        MemberID               string                `json:"memberId" db:"member_id"`
        SharesEligible         int                   `json:"sharesEligible" db:"shares_eligible"`
        DividendAmount         float64               `json:"dividendAmount" db:"dividend_amount"`
        PaymentStatus          DividendPaymentStatus `json:"paymentStatus" db:"payment_status"`
        PaymentDate            *time.Time            `json:"paymentDate,omitempty" db:"payment_date"`
        PaymentMethod          *string               `json:"paymentMethod,omitempty" db:"payment_method"`
        TransactionReference   *string               `json:"transactionReference,omitempty" db:"transaction_reference"`
        CreatedAt              time.Time             `json:"createdAt" db:"created_at"`
        UpdatedAt              time.Time             `json:"updatedAt" db:"updated_at"`
}

// DividendPaymentWithMemberInfo represents dividend payment with member details
type DividendPaymentWithMemberInfo struct {
        DividendPayment
        MemberName  string `json:"memberName"`
        MemberEmail string `json:"memberEmail"`
        MemberPhone string `json:"memberPhone"`
}

// CreateDividendDeclarationRequest represents the request to declare dividends
type CreateDividendDeclarationRequest struct {
        DividendPerShare    float64    `json:"dividendPerShare" binding:"required,min=0"`
        TotalDividendAmount float64    `json:"totalDividendAmount" binding:"required,min=0"`
        PaymentDate         *time.Time `json:"paymentDate,omitempty"`
        Description         *string    `json:"description,omitempty" binding:"omitempty,max=500"`
}

// UpdateDividendDeclarationRequest represents the request to update dividend declaration
type UpdateDividendDeclarationRequest struct {
        DividendPerShare    *float64                   `json:"dividendPerShare,omitempty" binding:"omitempty,min=0"`
        TotalDividendAmount *float64                   `json:"totalDividendAmount,omitempty" binding:"omitempty,min=0"`
        PaymentDate         *time.Time                 `json:"paymentDate,omitempty"`
        Status              *DividendDeclarationStatus `json:"status,omitempty" binding:"omitempty,oneof=declared approved paid cancelled"`
        Description         *string                    `json:"description,omitempty" binding:"omitempty,max=500"`
}

// ProcessDividendPaymentsRequest represents the request to process dividend payments
type ProcessDividendPaymentsRequest struct {
        PaymentMethod string `json:"paymentMethod" binding:"required,oneof=bank_transfer mobile_money cash"`
        PaymentDate   *time.Time `json:"paymentDate,omitempty"`
}

// DividendSummary represents dividend summary for a member
type DividendSummary struct {
        MemberID           string  `json:"memberId"`
        MemberName         string  `json:"memberName"`
        TotalDividendsEarned float64 `json:"totalDividendsEarned"`
        TotalDividendsPaid   float64 `json:"totalDividendsPaid"`
        PendingDividends     float64 `json:"pendingDividends"`
        LastDividendDate     *time.Time `json:"lastDividendDate,omitempty"`
        DividendHistory      []DividendPayment `json:"dividendHistory"`
}

// ChamaDividendSummary represents dividend summary for a chama
type ChamaDividendSummary struct {
        ChamaID              string    `json:"chamaId"`
        TotalDividendsDeclared float64 `json:"totalDividendsDeclared"`
        TotalDividendsPaid     float64 `json:"totalDividendsPaid"`
        PendingDividends       float64 `json:"pendingDividends"`
        LastDeclarationDate    *time.Time `json:"lastDeclarationDate,omitempty"`
        ActiveDeclarations     int       `json:"activeDeclarations"`
        TotalDeclarations      int       `json:"totalDeclarations"`
}

// DividendResponse represents the response structure for dividend operations
type DividendResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Message string      `json:"message,omitempty"`
}

// DividendDeclarationsListResponse represents the response for listing dividend declarations
type DividendDeclarationsListResponse struct {
        Success bool                  `json:"success"`
        Data    []DividendDeclaration `json:"data"`
        Count   int                   `json:"count"`
        Error   string                `json:"error,omitempty"`
}

// DividendPaymentsListResponse represents the response for listing dividend payments
type DividendPaymentsListResponse struct {
        Success bool              `json:"success"`
        Data    []DividendPayment `json:"data"`
        Count   int               `json:"count"`
        Error   string            `json:"error,omitempty"`
}

// IsValidDividendDeclarationStatus checks if the dividend declaration status is valid
func IsValidDividendDeclarationStatus(status string) bool <span class="cov0" title="0">{
        switch DividendDeclarationStatus(status) </span>{
        case DividendStatusDeclared, DividendStatusApproved, DividendStatusPaid, DividendStatusCancelled:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsValidDividendPaymentStatus checks if the dividend payment status is valid
func IsValidDividendPaymentStatus(status string) bool <span class="cov0" title="0">{
        switch DividendPaymentStatus(status) </span>{
        case DividendPaymentPending, DividendPaymentPaid, DividendPaymentFailed:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// CanApprove checks if dividend declaration can be approved
func (dd *DividendDeclaration) CanApprove() bool <span class="cov0" title="0">{
        return dd.Status == DividendStatusDeclared
}</span>

// CanProcess checks if dividend declaration can be processed for payment
func (dd *DividendDeclaration) CanProcess() bool <span class="cov0" title="0">{
        return dd.Status == DividendStatusApproved
}</span>

// CanCancel checks if dividend declaration can be cancelled
func (dd *DividendDeclaration) CanCancel() bool <span class="cov0" title="0">{
        return dd.Status == DividendStatusDeclared || dd.Status == DividendStatusApproved
}</span>

// CalculateDividendAmount calculates dividend amount for given shares
func (dd *DividendDeclaration) CalculateDividendAmount(shares int) float64 <span class="cov0" title="0">{
        return float64(shares) * dd.DividendPerShare
}</span>

// IsEligibleForPayment checks if a dividend payment is eligible for processing
func (dp *DividendPayment) IsEligibleForPayment() bool <span class="cov0" title="0">{
        return dp.PaymentStatus == DividendPaymentPending &amp;&amp; dp.DividendAmount &gt; 0
}</span>

// MarkAsPaid marks a dividend payment as paid
func (dp *DividendPayment) MarkAsPaid(paymentMethod, transactionRef string) <span class="cov0" title="0">{
        now := time.Now()
        dp.PaymentStatus = DividendPaymentPaid
        dp.PaymentDate = &amp;now
        dp.PaymentMethod = &amp;paymentMethod
        dp.TransactionReference = &amp;transactionRef
        dp.UpdatedAt = now
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package models

import (
        "time"
)

// LoanStatus represents loan status
type LoanStatus string

const (
        LoanStatusPending   LoanStatus = "pending"
        LoanStatusApproved  LoanStatus = "approved"
        LoanStatusRejected  LoanStatus = "rejected"
        LoanStatusActive    LoanStatus = "active"
        LoanStatusCompleted LoanStatus = "completed"
        LoanStatusDefaulted LoanStatus = "defaulted"
)

// LoanType represents loan type
type LoanType string

const (
        LoanTypePersonal   LoanType = "personal"
        LoanTypeBusiness   LoanType = "business"
        LoanTypeEmergency  LoanType = "emergency"
        LoanTypeEducation  LoanType = "education"
)

// GuarantorStatus represents guarantor status
type GuarantorStatus string

const (
        GuarantorStatusPending  GuarantorStatus = "pending"
        GuarantorStatusAccepted GuarantorStatus = "accepted"
        GuarantorStatusRejected GuarantorStatus = "rejected"
)

// Loan represents a loan in the system
type Loan struct {
        ID                string      `json:"id" db:"id"`
        BorrowerID        string      `json:"borrowerId" db:"borrower_id"`
        ChamaID           string      `json:"chamaId" db:"chama_id"`
        Type              LoanType    `json:"type" db:"type"`
        Amount            float64     `json:"amount" db:"amount"`
        InterestRate      float64     `json:"interestRate" db:"interest_rate"`
        Duration          int         `json:"duration" db:"duration"` // in months
        Purpose           string      `json:"purpose" db:"purpose"`
        Status            LoanStatus  `json:"status" db:"status"`
        ApprovedBy        *string     `json:"approvedBy,omitempty" db:"approved_by"`
        ApprovedAt        *time.Time  `json:"approvedAt,omitempty" db:"approved_at"`
        DisbursedAt       *time.Time  `json:"disbursedAt,omitempty" db:"disbursed_at"`
        DueDate           *time.Time  `json:"dueDate,omitempty" db:"due_date"`
        TotalAmount       float64     `json:"totalAmount" db:"total_amount"`
        PaidAmount        float64     `json:"paidAmount" db:"paid_amount"`
        RemainingAmount   float64     `json:"remainingAmount" db:"remaining_amount"`
        RequiredGuarantors int        `json:"requiredGuarantors" db:"required_guarantors"`
        ApprovedGuarantors int        `json:"approvedGuarantors" db:"approved_guarantors"`
        CreatedAt         time.Time   `json:"createdAt" db:"created_at"`
        UpdatedAt         time.Time   `json:"updatedAt" db:"updated_at"`
        
        // Joined data
        Borrower   *User        `json:"borrower,omitempty"`
        Chama      *Chama       `json:"chama,omitempty"`
        Guarantors []Guarantor  `json:"guarantors,omitempty"`
        Payments   []LoanPayment `json:"payments,omitempty"`
}

// Guarantor represents a loan guarantor
type Guarantor struct {
        ID         string          `json:"id" db:"id"`
        LoanID     string          `json:"loanId" db:"loan_id"`
        UserID     string          `json:"userId" db:"user_id"`
        Amount     float64         `json:"amount" db:"amount"`
        Status     GuarantorStatus `json:"status" db:"status"`
        Message    *string         `json:"message,omitempty" db:"message"`
        RespondedAt *time.Time     `json:"respondedAt,omitempty" db:"responded_at"`
        CreatedAt  time.Time       `json:"createdAt" db:"created_at"`
        
        // Joined data
        User *User `json:"user,omitempty"`
}

// LoanPayment represents a loan payment
type LoanPayment struct {
        ID            string    `json:"id" db:"id"`
        LoanID        string    `json:"loanId" db:"loan_id"`
        Amount        float64   `json:"amount" db:"amount"`
        PrincipalAmount float64 `json:"principalAmount" db:"principal_amount"`
        InterestAmount  float64 `json:"interestAmount" db:"interest_amount"`
        PaymentMethod string    `json:"paymentMethod" db:"payment_method"`
        Reference     *string   `json:"reference,omitempty" db:"reference"`
        PaidAt        time.Time `json:"paidAt" db:"paid_at"`
        CreatedAt     time.Time `json:"createdAt" db:"created_at"`
}

// LoanApplication represents loan application data
type LoanApplication struct {
        Type              LoanType `json:"type" validate:"required"`
        Amount            float64  `json:"amount" validate:"required,gt=0"`
        Duration          int      `json:"duration" validate:"required,gt=0"`
        Purpose           string   `json:"purpose" validate:"required"`
        RequiredGuarantors int     `json:"requiredGuarantors" validate:"required,gt=0"`
        GuarantorUserIDs  []string `json:"guarantorUserIds" validate:"required,min=1"`
}

// LoanApproval represents loan approval data
type LoanApproval struct {
        Approved     bool    `json:"approved"`
        InterestRate float64 `json:"interestRate,omitempty"`
        Message      *string `json:"message,omitempty"`
}

// GuarantorResponse represents guarantor response data
type GuarantorResponse struct {
        Accept  bool    `json:"accept"`
        Message *string `json:"message,omitempty"`
}

// IsActive checks if the loan is active
func (l *Loan) IsActive() bool <span class="cov0" title="0">{
        return l.Status == LoanStatusActive
}</span>

// IsCompleted checks if the loan is completed
func (l *Loan) IsCompleted() bool <span class="cov0" title="0">{
        return l.Status == LoanStatusCompleted
}</span>

// IsPending checks if the loan is pending approval
func (l *Loan) IsPending() bool <span class="cov0" title="0">{
        return l.Status == LoanStatusPending
}</span>

// IsApproved checks if the loan is approved
func (l *Loan) IsApproved() bool <span class="cov0" title="0">{
        return l.Status == LoanStatusApproved
}</span>

// IsOverdue checks if the loan is overdue
func (l *Loan) IsOverdue() bool <span class="cov0" title="0">{
        return l.IsActive() &amp;&amp; l.DueDate != nil &amp;&amp; time.Now().After(*l.DueDate)
}</span>

// GetProgress returns the loan payment progress as percentage
func (l *Loan) GetProgress() float64 <span class="cov0" title="0">{
        if l.TotalAmount == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return (l.PaidAmount / l.TotalAmount) * 100</span>
}

// GetMonthlyPayment calculates the monthly payment amount
func (l *Loan) GetMonthlyPayment() float64 <span class="cov0" title="0">{
        if l.Duration == 0 </span><span class="cov0" title="0">{
                return l.TotalAmount
        }</span>
        <span class="cov0" title="0">return l.TotalAmount / float64(l.Duration)</span>
}

// CalculateTotalAmount calculates total amount including interest
func (l *Loan) CalculateTotalAmount() float64 <span class="cov0" title="0">{
        interest := l.Amount * (l.InterestRate / 100) * (float64(l.Duration) / 12)
        return l.Amount + interest
}</span>

// HasSufficientGuarantors checks if loan has enough approved guarantors
func (l *Loan) HasSufficientGuarantors() bool <span class="cov0" title="0">{
        return l.ApprovedGuarantors &gt;= l.RequiredGuarantors
}</span>

// CanBeApproved checks if loan can be approved
func (l *Loan) CanBeApproved() bool <span class="cov0" title="0">{
        return l.IsPending() &amp;&amp; l.HasSufficientGuarantors()
}</span>

// GetRemainingDays returns remaining days until due date
func (l *Loan) GetRemainingDays() int <span class="cov0" title="0">{
        if l.DueDate == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        <span class="cov0" title="0">remaining := time.Until(*l.DueDate)
        return int(remaining.Hours() / 24)</span>
}

// IsAccepted checks if guarantor has accepted
func (g *Guarantor) IsAccepted() bool <span class="cov0" title="0">{
        return g.Status == GuarantorStatusAccepted
}</span>

// IsRejected checks if guarantor has rejected
func (g *Guarantor) IsRejected() bool <span class="cov0" title="0">{
        return g.Status == GuarantorStatusRejected
}</span>

// IsPending checks if guarantor response is pending
func (g *Guarantor) IsPending() bool <span class="cov0" title="0">{
        return g.Status == GuarantorStatusPending
}</span>

// HasResponded checks if guarantor has responded
func (g *Guarantor) HasResponded() bool <span class="cov0" title="0">{
        return g.Status != GuarantorStatusPending
}</span>

// GetTotalAmount returns total payment amount
func (lp *LoanPayment) GetTotalAmount() float64 <span class="cov0" title="0">{
        return lp.PrincipalAmount + lp.InterestAmount
}</span>

// LoanSummary represents loan summary statistics
type LoanSummary struct {
        TotalLoans       int     `json:"totalLoans"`
        ActiveLoans      int     `json:"activeLoans"`
        CompletedLoans   int     `json:"completedLoans"`
        DefaultedLoans   int     `json:"defaultedLoans"`
        TotalBorrowed    float64 `json:"totalBorrowed"`
        TotalRepaid      float64 `json:"totalRepaid"`
        TotalOutstanding float64 `json:"totalOutstanding"`
        AverageInterestRate float64 `json:"averageInterestRate"`
}

// LoanSchedule represents loan repayment schedule
type LoanSchedule struct {
        PaymentNumber   int       `json:"paymentNumber"`
        DueDate         time.Time `json:"dueDate"`
        PrincipalAmount float64   `json:"principalAmount"`
        InterestAmount  float64   `json:"interestAmount"`
        TotalAmount     float64   `json:"totalAmount"`
        RemainingBalance float64  `json:"remainingBalance"`
        IsPaid          bool      `json:"isPaid"`
}

// GenerateSchedule generates loan repayment schedule
func (l *Loan) GenerateSchedule() []LoanSchedule <span class="cov0" title="0">{
        if l.Duration == 0 || l.DisbursedAt == nil </span><span class="cov0" title="0">{
                return []LoanSchedule{}
        }</span>

        <span class="cov0" title="0">var schedule []LoanSchedule
        monthlyPayment := l.GetMonthlyPayment()
        monthlyPrincipal := l.Amount / float64(l.Duration)
        monthlyInterest := (l.TotalAmount - l.Amount) / float64(l.Duration)
        remainingBalance := l.Amount

        for i := 1; i &lt;= l.Duration; i++ </span><span class="cov0" title="0">{
                dueDate := l.DisbursedAt.AddDate(0, i, 0)
                
                // Adjust last payment to account for rounding
                if i == l.Duration </span><span class="cov0" title="0">{
                        monthlyPrincipal = remainingBalance
                        monthlyPayment = monthlyPrincipal + monthlyInterest
                }</span>

                <span class="cov0" title="0">schedule = append(schedule, LoanSchedule{
                        PaymentNumber:    i,
                        DueDate:          dueDate,
                        PrincipalAmount:  monthlyPrincipal,
                        InterestAmount:   monthlyInterest,
                        TotalAmount:      monthlyPayment,
                        RemainingBalance: remainingBalance - monthlyPrincipal,
                        IsPaid:          false, // This would be determined by checking actual payments
                })

                remainingBalance -= monthlyPrincipal</span>
        }

        <span class="cov0" title="0">return schedule</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package models

import (
        "encoding/json"
        "time"
)

// ProductCategory represents product categories
type ProductCategory string

const (
        ProductCategoryAgriculture  ProductCategory = "agriculture"
        ProductCategoryFoodBeverage ProductCategory = "food_beverage"
        ProductCategoryClothing     ProductCategory = "clothing"
        ProductCategoryElectronics  ProductCategory = "electronics"
        ProductCategoryServices     ProductCategory = "services"
        ProductCategoryCrafts       ProductCategory = "crafts"
        ProductCategoryBeauty       ProductCategory = "beauty"
        ProductCategoryHomeGarden   ProductCategory = "home_garden"
        ProductCategoryAutomotive   ProductCategory = "automotive"
        ProductCategoryOther        ProductCategory = "other"
)

// ProductStatus represents product status
type ProductStatus string

const (
        ProductStatusActive       ProductStatus = "active"
        ProductStatusInactive     ProductStatus = "inactive"
        ProductStatusOutOfStock   ProductStatus = "out_of_stock"
        ProductStatusDiscontinued ProductStatus = "discontinued"
)

// OrderStatus represents order status
type OrderStatus string

const (
        OrderStatusPending    OrderStatus = "pending"
        OrderStatusConfirmed  OrderStatus = "confirmed"
        OrderStatusProcessing OrderStatus = "processing"
        OrderStatusShipped    OrderStatus = "shipped"
        OrderStatusDelivered  OrderStatus = "delivered"
        OrderStatusCancelled  OrderStatus = "cancelled"
        OrderStatusRefunded   OrderStatus = "refunded"
)

// DeliveryStatus represents delivery status
type DeliveryStatus string

const (
        DeliveryStatusPending   DeliveryStatus = "pending"
        DeliveryStatusAssigned  DeliveryStatus = "assigned"
        DeliveryStatusInTransit DeliveryStatus = "in_transit"
        DeliveryStatusDelivered DeliveryStatus = "delivered"
        DeliveryStatusFailed    DeliveryStatus = "failed"
)

// Product represents a product in the marketplace
type Product struct {
        ID           string          `json:"id" db:"id"`
        Name         string          `json:"name" db:"name"`
        Description  string          `json:"description" db:"description"`
        Category     ProductCategory `json:"category" db:"category"`
        Price        float64         `json:"price" db:"price"`
        Currency     string          `json:"currency" db:"currency"`
        Images       []string        `json:"images" db:"images"`
        Status       ProductStatus   `json:"status" db:"status"`
        Stock        int             `json:"stock" db:"stock"`
        MinOrder     int             `json:"minOrder" db:"min_order"`
        MaxOrder     *int            `json:"maxOrder,omitempty" db:"max_order"`
        SellerID     string          `json:"sellerId" db:"seller_id"`
        ChamaID      *string         `json:"chamaId,omitempty" db:"chama_id"`
        County       string          `json:"county" db:"county"`
        Town         string          `json:"town" db:"town"`
        Address      *string         `json:"address,omitempty" db:"address"`
        Tags         []string        `json:"tags" db:"tags"`
        Rating       float64         `json:"rating" db:"rating"`
        TotalRatings int             `json:"totalRatings" db:"total_ratings"`
        TotalSales   int             `json:"totalSales" db:"total_sales"`
        IsPromoted   bool            `json:"isPromoted" db:"is_promoted"`
        CreatedAt    time.Time       `json:"createdAt" db:"created_at"`
        UpdatedAt    time.Time       `json:"updatedAt" db:"updated_at"`

        // Joined data (populated when needed)
        Seller *User  `json:"seller,omitempty"`
        Chama  *Chama `json:"chama,omitempty"`
}

// CartItem represents an item in a user's cart
type CartItem struct {
        ID        string    `json:"id" db:"id"`
        UserID    string    `json:"userId" db:"user_id"`
        ProductID string    `json:"productId" db:"product_id"`
        Quantity  int       `json:"quantity" db:"quantity"`
        Price     float64   `json:"price" db:"price"`
        AddedAt   time.Time `json:"addedAt" db:"added_at"`

        // Joined data (populated when needed)
        Product *Product `json:"product,omitempty"`
}

// OrderItem represents an item within an order
type OrderItem struct {
        ID        string  `json:"id" db:"id"`
        OrderID   string  `json:"orderId" db:"order_id"`
        ProductID string  `json:"productId" db:"product_id"`
        Quantity  int     `json:"quantity" db:"quantity"`
        Price     float64 `json:"price" db:"price"`
        Name      string  `json:"name" db:"name"`

        // Joined data (populated when needed)
        Product *Product `json:"product,omitempty"`
}

// Order represents an order in the marketplace
type Order struct {
        ID                string         `json:"id" db:"id"`
        BuyerID           string         `json:"buyerId" db:"buyer_id"`
        SellerID          string         `json:"sellerId" db:"seller_id"`
        ChamaID           *string        `json:"chamaId,omitempty" db:"chama_id"`
        TotalAmount       float64        `json:"totalAmount" db:"total_amount"`
        Currency          string         `json:"currency" db:"currency"`
        Status            OrderStatus    `json:"status" db:"status"`
        PaymentMethod     string         `json:"paymentMethod" db:"payment_method"`
        PaymentStatus     string         `json:"paymentStatus" db:"payment_status"`
        DeliveryCounty    string         `json:"deliveryCounty" db:"delivery_county"`
        DeliveryTown      string         `json:"deliveryTown" db:"delivery_town"`
        DeliveryAddress   string         `json:"deliveryAddress" db:"delivery_address"`
        DeliveryPhone     string         `json:"deliveryPhone" db:"delivery_phone"`
        DeliveryFee       float64        `json:"deliveryFee" db:"delivery_fee"`
        DeliveryPersonID  *string        `json:"deliveryPersonId,omitempty" db:"delivery_person_id"`
        DeliveryStatus    DeliveryStatus `json:"deliveryStatus" db:"delivery_status"`
        EstimatedDelivery *time.Time     `json:"estimatedDelivery,omitempty" db:"estimated_delivery"`
        ActualDelivery    *time.Time     `json:"actualDelivery,omitempty" db:"actual_delivery"`
        Notes             *string        `json:"notes,omitempty" db:"notes"`
        CreatedAt         time.Time      `json:"createdAt" db:"created_at"`
        UpdatedAt         time.Time      `json:"updatedAt" db:"updated_at"`

        // Joined data (populated when needed)
        Buyer          *User       `json:"buyer,omitempty"`
        Seller         *User       `json:"seller,omitempty"`
        Chama          *Chama      `json:"chama,omitempty"`
        DeliveryPerson *User       `json:"deliveryPerson,omitempty"`
        Items          []OrderItem `json:"items,omitempty"`
}

// ProductReview represents a review for a product
type ProductReview struct {
        ID                 string    `json:"id" db:"id"`
        ProductID          string    `json:"productId" db:"product_id"`
        OrderID            string    `json:"orderId" db:"order_id"`
        ReviewerID         string    `json:"reviewerId" db:"reviewer_id"`
        Rating             int       `json:"rating" db:"rating"`
        Comment            *string   `json:"comment,omitempty" db:"comment"`
        Images             []string  `json:"images" db:"images"`
        IsVerifiedPurchase bool      `json:"isVerifiedPurchase" db:"is_verified_purchase"`
        CreatedAt          time.Time `json:"createdAt" db:"created_at"`

        // Joined data (populated when needed)
        Reviewer *User    `json:"reviewer,omitempty"`
        Product  *Product `json:"product,omitempty"`
        Order    *Order   `json:"order,omitempty"`
}

// ProductCreation represents data for creating a new product
type ProductCreation struct {
        Name        string          `json:"name" validate:"required"`
        Description string          `json:"description" validate:"required"`
        Category    ProductCategory `json:"category" validate:"required"`
        Price       float64         `json:"price" validate:"required,gt=0"`
        Images      []string        `json:"images" validate:"required,min=1"`
        Stock       int             `json:"stock" validate:"required,gte=0"`
        MinOrder    int             `json:"minOrder" validate:"required,gt=0"`
        MaxOrder    *int            `json:"maxOrder,omitempty"`
        County      string          `json:"county" validate:"required"`
        Town        string          `json:"town" validate:"required"`
        Address     *string         `json:"address,omitempty"`
        Tags        []string        `json:"tags"`
}

// ProductUpdate represents data for updating a product
type ProductUpdate struct {
        Name        *string          `json:"name,omitempty"`
        Description *string          `json:"description,omitempty"`
        Category    *ProductCategory `json:"category,omitempty"`
        Price       *float64         `json:"price,omitempty"`
        Images      []string         `json:"images,omitempty"`
        Status      *ProductStatus   `json:"status,omitempty"`
        Stock       *int             `json:"stock,omitempty"`
        MinOrder    *int             `json:"minOrder,omitempty"`
        MaxOrder    *int             `json:"maxOrder,omitempty"`
        County      *string          `json:"county,omitempty"`
        Town        *string          `json:"town,omitempty"`
        Address     *string          `json:"address,omitempty"`
        Tags        []string         `json:"tags,omitempty"`
}

// OrderCreation represents data for creating a new order
type OrderCreation struct {
        Items           []CartItem `json:"items" validate:"required,min=1"`
        PaymentMethod   string     `json:"paymentMethod" validate:"required"`
        DeliveryCounty  string     `json:"deliveryCounty" validate:"required"`
        DeliveryTown    string     `json:"deliveryTown" validate:"required"`
        DeliveryAddress string     `json:"deliveryAddress" validate:"required"`
        DeliveryPhone   string     `json:"deliveryPhone" validate:"required"`
        Notes           *string    `json:"notes,omitempty"`
}

// IsAvailable checks if the product is available for purchase
func (p *Product) IsAvailable() bool <span class="cov0" title="0">{
        return p.Status == ProductStatusActive &amp;&amp; p.Stock &gt; 0
}</span>

// IsInStock checks if the product has sufficient stock
func (p *Product) IsInStock(quantity int) bool <span class="cov0" title="0">{
        return p.Stock &gt;= quantity
}</span>

// CanOrder checks if the quantity is within order limits
func (p *Product) CanOrder(quantity int) bool <span class="cov0" title="0">{
        if quantity &lt; p.MinOrder </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if p.MaxOrder != nil &amp;&amp; quantity &gt; *p.MaxOrder </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// GetLocation returns the product's location as a formatted string
func (p *Product) GetLocation() string <span class="cov0" title="0">{
        return p.Town + ", " + p.County
}</span>

// GetImagesJSON returns images as JSON string for database storage
func (p *Product) GetImagesJSON() (string, error) <span class="cov0" title="0">{
        if len(p.Images) == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(p.Images)
        return string(data), err</span>
}

// SetImagesFromJSON sets images from JSON string
func (p *Product) SetImagesFromJSON(imagesJSON string) error <span class="cov0" title="0">{
        if imagesJSON == "" </span><span class="cov0" title="0">{
                p.Images = []string{}
                return nil
        }</span>
        <span class="cov0" title="0">return json.Unmarshal([]byte(imagesJSON), &amp;p.Images)</span>
}

// GetTagsJSON returns tags as JSON string for database storage
func (p *Product) GetTagsJSON() (string, error) <span class="cov0" title="0">{
        if len(p.Tags) == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(p.Tags)
        return string(data), err</span>
}

// SetTagsFromJSON sets tags from JSON string
func (p *Product) SetTagsFromJSON(tagsJSON string) error <span class="cov0" title="0">{
        if tagsJSON == "" </span><span class="cov0" title="0">{
                p.Tags = []string{}
                return nil
        }</span>
        <span class="cov0" title="0">return json.Unmarshal([]byte(tagsJSON), &amp;p.Tags)</span>
}

// GetTotalPrice returns the total price for the cart item
func (ci *CartItem) GetTotalPrice() float64 <span class="cov0" title="0">{
        return ci.Price * float64(ci.Quantity)
}</span>

// GetTotalPrice returns the total price for the order item
func (oi *OrderItem) GetTotalPrice() float64 <span class="cov0" title="0">{
        return oi.Price * float64(oi.Quantity)
}</span>

// GetTotalItems returns the total number of items in the order
func (o *Order) GetTotalItems() int <span class="cov0" title="0">{
        total := 0
        for _, item := range o.Items </span><span class="cov0" title="0">{
                total += item.Quantity
        }</span>
        <span class="cov0" title="0">return total</span>
}

// GetGrandTotal returns the total amount including delivery fee
func (o *Order) GetGrandTotal() float64 <span class="cov0" title="0">{
        return o.TotalAmount + o.DeliveryFee
}</span>

// IsCompleted checks if the order is completed
func (o *Order) IsCompleted() bool <span class="cov0" title="0">{
        return o.Status == OrderStatusDelivered
}</span>

// IsCancelled checks if the order is cancelled
func (o *Order) IsCancelled() bool <span class="cov0" title="0">{
        return o.Status == OrderStatusCancelled
}</span>

// CanCancel checks if the order can be cancelled
func (o *Order) CanCancel() bool <span class="cov0" title="0">{
        return o.Status == OrderStatusPending || o.Status == OrderStatusConfirmed
}</span>

// CanRate checks if the order can be rated (delivered and not yet rated)
func (o *Order) CanRate() bool <span class="cov0" title="0">{
        return o.Status == OrderStatusDelivered
}</span>

// GetDeliveryLocation returns the delivery location as a formatted string
func (o *Order) GetDeliveryLocation() string <span class="cov0" title="0">{
        return o.DeliveryTown + ", " + o.DeliveryCounty
}</span>

// IsValidRating checks if the rating is valid (1-5)
func (pr *ProductReview) IsValidRating() bool <span class="cov0" title="0">{
        return pr.Rating &gt;= 1 &amp;&amp; pr.Rating &lt;= 5
}</span>

// GetImagesJSON returns images as JSON string for database storage
func (pr *ProductReview) GetImagesJSON() (string, error) <span class="cov0" title="0">{
        if len(pr.Images) == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(pr.Images)
        return string(data), err</span>
}

// SetImagesFromJSON sets images from JSON string
func (pr *ProductReview) SetImagesFromJSON(imagesJSON string) error <span class="cov0" title="0">{
        if imagesJSON == "" </span><span class="cov0" title="0">{
                pr.Images = []string{}
                return nil
        }</span>
        <span class="cov0" title="0">return json.Unmarshal([]byte(imagesJSON), &amp;pr.Images)</span>
}

// Review represents a product review (alias for ProductReview for consistency)
type Review = ProductReview

// WishlistItem represents an item in user's wishlist
type WishlistItem struct {
        ID        string    `json:"id" db:"id"`
        UserID    string    `json:"userId" db:"user_id"`
        ProductID string    `json:"productId" db:"product_id"`
        AddedAt   time.Time `json:"addedAt" db:"added_at"`

        // Relationships
        User    *User    `json:"user,omitempty"`
        Product *Product `json:"product,omitempty"`
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package models

import (
        "crypto/sha256"
        "encoding/hex"
        "time"
)

// PollType represents the type of poll
type PollType string

const (
        PollTypeGeneral           PollType = "general"
        PollTypeRoleEscalation    PollType = "Election / Voting"
        PollTypeFinancialDecision PollType = "financial_decision"
)

// PollStatus represents the status of a poll
type PollStatus string

const (
        PollStatusActive    PollStatus = "active"
        PollStatusCompleted PollStatus = "completed"
        PollStatusCancelled PollStatus = "cancelled"
)

// PollResult represents the result of a poll
type PollResult string

const (
        PollResultPassed  PollResult = "passed"
        PollResultFailed  PollResult = "failed"
        PollResultPending PollResult = "pending"
)

// Poll represents a poll in the system
type Poll struct {
        ID                  string      `json:"id" db:"id"`
        ChamaID             string      `json:"chamaId" db:"chama_id"`
        Title               string      `json:"title" db:"title"`
        Description         *string     `json:"description,omitempty" db:"description"`
        PollType            PollType    `json:"pollType" db:"poll_type"`
        CreatedBy           string      `json:"createdBy" db:"created_by"`
        StartDate           time.Time   `json:"startDate" db:"start_date"`
        EndDate             time.Time   `json:"endDate" db:"end_date"`
        Status              PollStatus  `json:"status" db:"status"`
        IsAnonymous         bool        `json:"isAnonymous" db:"is_anonymous"`
        RequiresMajority    bool        `json:"requiresMajority" db:"requires_majority"`
        MajorityPercentage  float64     `json:"majorityPercentage" db:"majority_percentage"`
        TotalEligibleVoters int         `json:"totalEligibleVoters" db:"total_eligible_voters"`
        TotalVotesCast      int         `json:"totalVotesCast" db:"total_votes_cast"`
        Result              *PollResult `json:"result,omitempty" db:"result"`
        ResultDeclaredAt    *time.Time  `json:"resultDeclaredAt,omitempty" db:"result_declared_at"`
        Metadata            *string     `json:"metadata,omitempty" db:"metadata"`
        CreatedAt           time.Time   `json:"createdAt" db:"created_at"`
        UpdatedAt           time.Time   `json:"updatedAt" db:"updated_at"`
}

// PollOption represents an option in a poll
type PollOption struct {
        ID          string    `json:"id" db:"id"`
        PollID      string    `json:"pollId" db:"poll_id"`
        OptionText  string    `json:"optionText" db:"option_text"`
        OptionOrder int       `json:"optionOrder" db:"option_order"`
        VoteCount   int       `json:"voteCount" db:"vote_count"`
        Metadata    *string   `json:"metadata,omitempty" db:"metadata"`
        CreatedAt   time.Time `json:"createdAt" db:"created_at"`
}

// Vote represents a vote in the system
type Vote struct {
        ID            string    `json:"id" db:"id"`
        PollID        string    `json:"pollId" db:"poll_id"`
        OptionID      string    `json:"optionId" db:"option_id"`
        VoterHash     string    `json:"voterHash" db:"voter_hash"`
        VoteTimestamp time.Time `json:"voteTimestamp" db:"vote_timestamp"`
        IsValid       bool      `json:"isValid" db:"is_valid"`
}

// RoleEscalationRequest represents a role escalation request
type RoleEscalationRequest struct {
        ID            string    `json:"id" db:"id"`
        ChamaID       string    `json:"chamaId" db:"chama_id"`
        CandidateID   string    `json:"candidateId" db:"candidate_id"`
        CurrentRole   string    `json:"currentRole" db:"current_role"`
        RequestedRole string    `json:"requestedRole" db:"requested_role"`
        RequestedBy   string    `json:"requestedBy" db:"requested_by"`
        PollID        *string   `json:"pollId,omitempty" db:"poll_id"`
        Status        string    `json:"status" db:"status"`
        Justification *string   `json:"justification,omitempty" db:"justification"`
        CreatedAt     time.Time `json:"createdAt" db:"created_at"`
        UpdatedAt     time.Time `json:"updatedAt" db:"updated_at"`
}

// CreatePollRequest represents the request to create a new poll
type CreatePollRequest struct {
        Title              string              `json:"title" binding:"required,min=1,max=200"`
        Description        *string             `json:"description,omitempty" binding:"omitempty,max=1000"`
        PollType           PollType            `json:"pollType" binding:"required,oneof=general Election / Voting financial_decision"`
        EndDate            time.Time           `json:"endDate" binding:"required"`
        IsAnonymous        *bool               `json:"isAnonymous,omitempty"`
        RequiresMajority   *bool               `json:"requiresMajority,omitempty"`
        MajorityPercentage *float64            `json:"majorityPercentage,omitempty" binding:"omitempty,min=0,max=100"`
        Options            []PollOptionRequest `json:"options" binding:"required,min=2,max=10"`
        Metadata           *string             `json:"metadata,omitempty"`
}

// PollOptionRequest represents a poll option in the create request
type PollOptionRequest struct {
        OptionText string  `json:"optionText" binding:"required,min=1,max=200"`
        Metadata   *string `json:"metadata,omitempty"`
}

// UpdatePollRequest represents the request to update a poll
type UpdatePollRequest struct {
        Title       *string     `json:"title,omitempty" binding:"omitempty,min=1,max=200"`
        Description *string     `json:"description,omitempty" binding:"omitempty,max=1000"`
        EndDate     *time.Time  `json:"endDate,omitempty"`
        Status      *PollStatus `json:"status,omitempty" binding:"omitempty,oneof=active completed cancelled"`
}

// CastVoteRequest represents the request to cast a vote
type CastVoteRequest struct {
        OptionID string `json:"optionId" binding:"required"`
}

// CreateRoleEscalationRequest represents the request to create a role escalation
type CreateRoleEscalationRequest struct {
        CandidateID   string  `json:"candidateId" binding:"required"`
        RequestedRole string  `json:"requestedRole" binding:"required,oneof=chairperson secretary treasurer member"`
        Justification *string `json:"justification,omitempty" binding:"omitempty,max=500"`
}

// PollWithDetails represents a poll with additional details
type PollWithDetails struct {
        Poll
        CreatedByName string       `json:"createdByName"`
        Options       []PollOption `json:"options"`
        UserVoted     bool         `json:"userVoted"`
        UserCanVote   bool         `json:"userCanVote"`
        TimeRemaining *int64       `json:"timeRemaining,omitempty"` // seconds
}

// PollResponse represents the response structure for poll operations
type PollResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Message string      `json:"message,omitempty"`
}

// PollsListResponse represents the response for listing polls
type PollsListResponse struct {
        Success bool   `json:"success"`
        Data    []Poll `json:"data"`
        Count   int    `json:"count"`
        Error   string `json:"error,omitempty"`
}

// VoteResponse represents the response for voting operations
type VoteResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Message string      `json:"message,omitempty"`
}

// IsValidPollType checks if the poll type is valid
func IsValidPollType(pollType string) bool <span class="cov0" title="0">{
        switch PollType(pollType) </span>{
        case PollTypeGeneral, PollTypeRoleEscalation, PollTypeFinancialDecision:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsValidPollStatus checks if the poll status is valid
func IsValidPollStatus(status string) bool <span class="cov0" title="0">{
        switch PollStatus(status) </span>{
        case PollStatusActive, PollStatusCompleted, PollStatusCancelled:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GenerateVoterHash generates an anonymous hash for a voter
func GenerateVoterHash(voterID, pollID string) string <span class="cov0" title="0">{
        data := voterID + pollID + "salt_for_anonymity"
        hash := sha256.Sum256([]byte(data))
        return hex.EncodeToString(hash[:])
}</span>

// IsActive checks if the poll is currently active
func (p *Poll) IsActive() bool <span class="cov0" title="0">{
        now := time.Now()
        return p.Status == PollStatusActive &amp;&amp; now.After(p.StartDate) &amp;&amp; now.Before(p.EndDate)
}</span>

// HasEnded checks if the poll has ended
func (p *Poll) HasEnded() bool <span class="cov0" title="0">{
        return time.Now().After(p.EndDate)
}</span>

// CanVote checks if voting is allowed on this poll
func (p *Poll) CanVote() bool <span class="cov0" title="0">{
        return p.IsActive() &amp;&amp; !p.HasEnded()
}</span>

// GetTimeRemaining returns the time remaining for the poll in seconds
func (p *Poll) GetTimeRemaining() *int64 <span class="cov0" title="0">{
        if p.HasEnded() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">remaining := int64(p.EndDate.Sub(time.Now()).Seconds())
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;remaining</span>
}

// CalculateResult calculates the poll result based on votes
func (p *Poll) CalculateResult(options []PollOption) PollResult <span class="cov0" title="0">{
        if p.TotalVotesCast == 0 </span><span class="cov0" title="0">{
                return PollResultFailed
        }</span>

        <span class="cov0" title="0">if !p.RequiresMajority </span><span class="cov0" title="0">{
                // Simple plurality - option with most votes wins
                maxVotes := 0
                for _, option := range options </span><span class="cov0" title="0">{
                        if option.VoteCount &gt; maxVotes </span><span class="cov0" title="0">{
                                maxVotes = option.VoteCount
                        }</span>
                }
                <span class="cov0" title="0">if maxVotes &gt; 0 </span><span class="cov0" title="0">{
                        return PollResultPassed
                }</span>
                <span class="cov0" title="0">return PollResultFailed</span>
        }

        // Majority required
        <span class="cov0" title="0">requiredVotes := int(float64(p.TotalEligibleVoters) * (p.MajorityPercentage / 100.0))
        for _, option := range options </span><span class="cov0" title="0">{
                if option.VoteCount &gt;= requiredVotes </span><span class="cov0" title="0">{
                        return PollResultPassed
                }</span>
        }

        <span class="cov0" title="0">return PollResultFailed</span>
}

// ShouldDeclareResult checks if the result should be declared immediately
func (p *Poll) ShouldDeclareResult(options []PollOption) bool <span class="cov0" title="0">{
        if !p.RequiresMajority </span><span class="cov0" title="0">{
                return p.HasEnded()
        }</span>

        // For majority polls, declare immediately if majority is reached
        <span class="cov0" title="0">requiredVotes := int(float64(p.TotalEligibleVoters) * (p.MajorityPercentage / 100.0))
        for _, option := range options </span><span class="cov0" title="0">{
                if option.VoteCount &gt;= requiredVotes </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return p.HasEnded()</span>
}

// ChamaMemberInfo represents member information for role voting
type ChamaMemberInfo struct {
        UserID    string `json:"userId" db:"user_id"`
        Role      string `json:"role" db:"role"`
        FirstName string `json:"firstName" db:"first_name"`
        LastName  string `json:"lastName" db:"last_name"`
        Email     string `json:"email" db:"email"`
        Phone     string `json:"phone" db:"phone"`
        FullName  string `json:"fullName"`
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package models

import (
        "time"
)

// ReminderType represents the type of reminder
type ReminderType string

const (
        ReminderTypeOnce    ReminderType = "once"
        ReminderTypeDaily   ReminderType = "daily"
        ReminderTypeWeekly  ReminderType = "weekly"
        ReminderTypeMonthly ReminderType = "monthly"
)

// Reminder represents a user reminder in the system
type Reminder struct {
        ID               string       `json:"id" db:"id"`
        UserID           string       `json:"userId" db:"user_id"`
        Title            string       `json:"title" db:"title"`
        Description      *string      `json:"description,omitempty" db:"description"`
        ReminderType     ReminderType `json:"reminderType" db:"reminder_type"`
        ScheduledAt      time.Time    `json:"scheduledAt" db:"scheduled_at"`
        IsEnabled        bool         `json:"isEnabled" db:"is_enabled"`
        IsCompleted      bool         `json:"isCompleted" db:"is_completed"`
        NotificationSent bool         `json:"notificationSent" db:"notification_sent"`
        CreatedAt        time.Time    `json:"createdAt" db:"created_at"`
        UpdatedAt        time.Time    `json:"updatedAt" db:"updated_at"`
}

// CreateReminderRequest represents the request to create a new reminder
type CreateReminderRequest struct {
        Title        string       `json:"title" binding:"required,min=1,max=100"`
        Description  *string      `json:"description,omitempty" binding:"omitempty,max=500"`
        ReminderType ReminderType `json:"reminderType" binding:"required,oneof=once daily weekly monthly"`
        ScheduledAt  time.Time    `json:"scheduledAt" binding:"required"`
        IsEnabled    *bool        `json:"isEnabled,omitempty"`
}

// UpdateReminderRequest represents the request to update a reminder
type UpdateReminderRequest struct {
        Title        *string      `json:"title,omitempty" binding:"omitempty,min=1,max=100"`
        Description  *string      `json:"description,omitempty" binding:"omitempty,max=500"`
        ReminderType *ReminderType `json:"reminderType,omitempty" binding:"omitempty,oneof=once daily weekly monthly"`
        ScheduledAt  *time.Time   `json:"scheduledAt,omitempty"`
        IsEnabled    *bool        `json:"isEnabled,omitempty"`
        IsCompleted  *bool        `json:"isCompleted,omitempty"`
}

// ReminderResponse represents the response structure for reminder operations
type ReminderResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Message string      `json:"message,omitempty"`
}

// RemindersListResponse represents the response for listing reminders
type RemindersListResponse struct {
        Success bool       `json:"success"`
        Data    []Reminder `json:"data"`
        Count   int        `json:"count"`
        Error   string     `json:"error,omitempty"`
}

// ReminderNotification represents a notification to be sent for a reminder
type ReminderNotification struct {
        ReminderID  string    `json:"reminderId"`
        UserID      string    `json:"userId"`
        Title       string    `json:"title"`
        Description string    `json:"description"`
        ScheduledAt time.Time `json:"scheduledAt"`
        Type        string    `json:"type"`
}

// IsValidReminderType checks if the reminder type is valid
func IsValidReminderType(reminderType string) bool <span class="cov0" title="0">{
        switch ReminderType(reminderType) </span>{
        case ReminderTypeOnce, ReminderTypeDaily, ReminderTypeWeekly, ReminderTypeMonthly:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetNextScheduledTime calculates the next scheduled time for recurring reminders
func (r *Reminder) GetNextScheduledTime() *time.Time <span class="cov0" title="0">{
        if r.ReminderType == ReminderTypeOnce </span><span class="cov0" title="0">{
                return nil // One-time reminders don't have a next time
        }</span>

        <span class="cov0" title="0">now := time.Now()
        if r.ScheduledAt.After(now) </span><span class="cov0" title="0">{
                return &amp;r.ScheduledAt // If the original time hasn't passed yet
        }</span>

        <span class="cov0" title="0">var nextTime time.Time
        switch r.ReminderType </span>{
        case ReminderTypeDaily:<span class="cov0" title="0">
                nextTime = r.ScheduledAt.AddDate(0, 0, 1)
                for nextTime.Before(now) </span><span class="cov0" title="0">{
                        nextTime = nextTime.AddDate(0, 0, 1)
                }</span>
        case ReminderTypeWeekly:<span class="cov0" title="0">
                nextTime = r.ScheduledAt.AddDate(0, 0, 7)
                for nextTime.Before(now) </span><span class="cov0" title="0">{
                        nextTime = nextTime.AddDate(0, 0, 7)
                }</span>
        case ReminderTypeMonthly:<span class="cov0" title="0">
                nextTime = r.ScheduledAt.AddDate(0, 1, 0)
                for nextTime.Before(now) </span><span class="cov0" title="0">{
                        nextTime = nextTime.AddDate(0, 1, 0)
                }</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }

        <span class="cov0" title="0">return &amp;nextTime</span>
}

// ShouldSendNotification checks if a notification should be sent for this reminder
func (r *Reminder) ShouldSendNotification() bool <span class="cov0" title="0">{
        if !r.IsEnabled || r.IsCompleted </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">now := time.Now()
        
        // For one-time reminders, check if the scheduled time has passed and notification hasn't been sent
        if r.ReminderType == ReminderTypeOnce </span><span class="cov0" title="0">{
                return now.After(r.ScheduledAt) &amp;&amp; !r.NotificationSent
        }</span>

        // For recurring reminders, check if it's time for the next occurrence
        <span class="cov0" title="0">nextTime := r.GetNextScheduledTime()
        if nextTime == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Send notification if we're within 1 minute of the scheduled time
        <span class="cov0" title="0">timeDiff := nextTime.Sub(now)
        return timeDiff &lt;= time.Minute &amp;&amp; timeDiff &gt;= -time.Minute</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package models

import (
        "time"
)

// ShareType represents the type of shares
type ShareType string

const (
        ShareTypeOrdinary  ShareType = "ordinary"
        ShareTypePreferred ShareType = "preferred"
)

// ShareStatus represents the status of shares
type ShareStatus string

const (
        ShareStatusActive      ShareStatus = "active"
        ShareStatusTransferred ShareStatus = "transferred"
        ShareStatusRedeemed    ShareStatus = "redeemed"
)

// Share represents a member's share ownership in a chama
type Share struct {
        ID                string      `json:"id" db:"id"`
        ChamaID           string      `json:"chamaId" db:"chama_id"`
        MemberID          string      `json:"memberId" db:"member_id"`
        ShareType         ShareType   `json:"shareType" db:"share_type"`
        SharesOwned       int         `json:"sharesOwned" db:"shares_owned"`
        ShareValue        float64     `json:"shareValue" db:"share_value"`
        TotalValue        float64     `json:"totalValue" db:"total_value"`
        PurchaseDate      time.Time   `json:"purchaseDate" db:"purchase_date"`
        CertificateNumber *string     `json:"certificateNumber,omitempty" db:"certificate_number"`
        Status            ShareStatus `json:"status" db:"status"`
        CreatedAt         time.Time   `json:"createdAt" db:"created_at"`
        UpdatedAt         time.Time   `json:"updatedAt" db:"updated_at"`
}

// ShareWithMemberInfo represents share information with member details
type ShareWithMemberInfo struct {
        Share
        MemberName  string `json:"memberName"`
        MemberEmail string `json:"memberEmail"`
}

// ShareSummary represents aggregated share information for a member
type ShareSummary struct {
        MemberID       string  `json:"memberId"`
        MemberName     string  `json:"memberName"`
        TotalShares    int     `json:"totalShares"`
        TotalValue     float64 `json:"totalValue"`
        ShareTypes     []Share `json:"shareTypes"`
        LastPurchase   *time.Time `json:"lastPurchase,omitempty"`
}

// CreateShareRequest represents the request to create new shares
type CreateShareRequest struct {
        MemberID          string    `json:"memberId" binding:"required"`
        ShareType         ShareType `json:"shareType" binding:"required,oneof=ordinary preferred"`
        SharesCount       int       `json:"sharesCount" binding:"required,min=1"`
        ShareValue        float64   `json:"shareValue" binding:"required,min=0"`
        PurchaseDate      time.Time `json:"purchaseDate" binding:"required"`
        CertificateNumber *string   `json:"certificateNumber,omitempty"`
}

// UpdateShareRequest represents the request to update shares
type UpdateShareRequest struct {
        SharesOwned       *int        `json:"sharesOwned,omitempty" binding:"omitempty,min=0"`
        ShareValue        *float64    `json:"shareValue,omitempty" binding:"omitempty,min=0"`
        CertificateNumber *string     `json:"certificateNumber,omitempty"`
        Status            *ShareStatus `json:"status,omitempty" binding:"omitempty,oneof=active transferred redeemed"`
}

// ShareTransactionType represents the type of share transaction
type ShareTransactionType string

const (
        ShareTransactionPurchase   ShareTransactionType = "purchase"
        ShareTransactionTransfer   ShareTransactionType = "transfer"
        ShareTransactionRedemption ShareTransactionType = "redemption"
        ShareTransactionSplit      ShareTransactionType = "split"
)

// ShareTransactionStatus represents the status of a share transaction
type ShareTransactionStatus string

const (
        ShareTransactionPending   ShareTransactionStatus = "pending"
        ShareTransactionCompleted ShareTransactionStatus = "completed"
        ShareTransactionCancelled ShareTransactionStatus = "cancelled"
)

// ShareTransaction represents a share transaction
type ShareTransaction struct {
        ID             string                  `json:"id" db:"id"`
        ChamaID        string                  `json:"chamaId" db:"chama_id"`
        FromMemberID   *string                 `json:"fromMemberId,omitempty" db:"from_member_id"`
        ToMemberID     *string                 `json:"toMemberId,omitempty" db:"to_member_id"`
        TransactionType ShareTransactionType   `json:"transactionType" db:"transaction_type"`
        SharesCount    int                     `json:"sharesCount" db:"shares_count"`
        ShareValue     float64                 `json:"shareValue" db:"share_value"`
        TotalAmount    float64                 `json:"totalAmount" db:"total_amount"`
        TransactionDate time.Time              `json:"transactionDate" db:"transaction_date"`
        Status         ShareTransactionStatus  `json:"status" db:"status"`
        ApprovedBy     *string                 `json:"approvedBy,omitempty" db:"approved_by"`
        Description    *string                 `json:"description,omitempty" db:"description"`
        CreatedAt      time.Time               `json:"createdAt" db:"created_at"`
        UpdatedAt      time.Time               `json:"updatedAt" db:"updated_at"`
}

// CreateShareTransactionRequest represents the request to create a share transaction
type CreateShareTransactionRequest struct {
        FromMemberID    *string              `json:"fromMemberId,omitempty"`
        ToMemberID      *string              `json:"toMemberId,omitempty"`
        TransactionType ShareTransactionType `json:"transactionType" binding:"required,oneof=purchase transfer redemption split"`
        SharesCount     int                  `json:"sharesCount" binding:"required,min=1"`
        ShareValue      float64              `json:"shareValue" binding:"required,min=0"`
        TransactionDate time.Time            `json:"transactionDate" binding:"required"`
        Description     *string              `json:"description,omitempty"`
}

// SharesResponse represents the response structure for share operations
type SharesResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Message string      `json:"message,omitempty"`
}

// SharesListResponse represents the response for listing shares
type SharesListResponse struct {
        Success bool    `json:"success"`
        Data    []Share `json:"data"`
        Count   int     `json:"count"`
        Error   string  `json:"error,omitempty"`
}

// ChamaSharesSummaryResponse represents the response for chama shares summary
type ChamaSharesSummaryResponse struct {
        Success      bool           `json:"success"`
        Data         []ShareSummary `json:"data"`
        TotalShares  int            `json:"totalShares"`
        TotalValue   float64        `json:"totalValue"`
        TotalMembers int            `json:"totalMembers"`
        Error        string         `json:"error,omitempty"`
}

// IsValidShareType checks if the share type is valid
func IsValidShareType(shareType string) bool <span class="cov0" title="0">{
        switch ShareType(shareType) </span>{
        case ShareTypeOrdinary, ShareTypePreferred:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsValidShareStatus checks if the share status is valid
func IsValidShareStatus(status string) bool <span class="cov0" title="0">{
        switch ShareStatus(status) </span>{
        case ShareStatusActive, ShareStatusTransferred, ShareStatusRedeemed:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsValidShareTransactionType checks if the transaction type is valid
func IsValidShareTransactionType(transactionType string) bool <span class="cov0" title="0">{
        switch ShareTransactionType(transactionType) </span>{
        case ShareTransactionPurchase, ShareTransactionTransfer, ShareTransactionRedemption, ShareTransactionSplit:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// CalculateTotalValue calculates the total value of shares
func (s *Share) CalculateTotalValue() <span class="cov0" title="0">{
        s.TotalValue = float64(s.SharesOwned) * s.ShareValue
}</span>

// CanTransfer checks if shares can be transferred
func (s *Share) CanTransfer() bool <span class="cov0" title="0">{
        return s.Status == ShareStatusActive &amp;&amp; s.SharesOwned &gt; 0
}</span>

// CanRedeem checks if shares can be redeemed
func (s *Share) CanRedeem() bool <span class="cov0" title="0">{
        return s.Status == ShareStatusActive &amp;&amp; s.SharesOwned &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package models

import (
        "fmt"
        "time"
)

// UserRole represents user roles in the system
type UserRole string

const (
        UserRoleUser  UserRole = "user"
        UserRoleAdmin UserRole = "admin"
)

// UserStatus represents user account status
type UserStatus string

const (
        UserStatusPending   UserStatus = "pending"
        UserStatusActive    UserStatus = "active"
        UserStatusSuspended UserStatus = "suspended"
        UserStatusVerified  UserStatus = "verified"
)

// ChamaRole represents roles within a chama
type ChamaRole string

const (
        ChamaRoleChairperson ChamaRole = "chairperson"
        ChamaRoleTreasurer   ChamaRole = "treasurer"
        ChamaRoleSecretary   ChamaRole = "secretary"
        ChamaRoleMember      ChamaRole = "member"
        ChamaRoleAssistant   ChamaRole = "assistant"
)

// User represents a user in the VaultKe system
type User struct {
        ID                  string     `json:"id" db:"id"`
        Email               string     `json:"email" db:"email"`
        Phone               string     `json:"phone" db:"phone"`
        FirstName           string     `json:"firstName" db:"first_name"`
        LastName            string     `json:"lastName" db:"last_name"`
        PasswordHash        string     `json:"-" db:"password_hash"`
        Avatar              *string    `json:"avatar,omitempty" db:"avatar"`
        Role                UserRole   `json:"role" db:"role"`
        Status              UserStatus `json:"status" db:"status"`
        IsEmailVerified     bool       `json:"isEmailVerified" db:"is_email_verified"`
        IsPhoneVerified     bool       `json:"isPhoneVerified" db:"is_phone_verified"`
        Language            string     `json:"language" db:"language"`
        Theme               string     `json:"theme" db:"theme"`
        County              *string    `json:"county,omitempty" db:"county"`
        Town                *string    `json:"town,omitempty" db:"town"`
        Latitude            *float64   `json:"latitude,omitempty" db:"latitude"`
        Longitude           *float64   `json:"longitude,omitempty" db:"longitude"`
        BusinessType        *string    `json:"businessType,omitempty" db:"business_type"`
        BusinessDescription *string    `json:"businessDescription,omitempty" db:"business_description"`
        Bio                 *string    `json:"bio,omitempty" db:"bio"`
        Occupation          *string    `json:"occupation,omitempty" db:"occupation"`
        DateOfBirth         *time.Time `json:"dateOfBirth,omitempty" db:"date_of_birth"`
        Rating              float64    `json:"rating" db:"rating"`
        TotalRatings        int        `json:"totalRatings" db:"total_ratings"`
        CreatedAt           time.Time  `json:"createdAt" db:"created_at"`
        UpdatedAt           time.Time  `json:"updatedAt" db:"updated_at"`
}

// UserRegistration represents user registration data
type UserRegistration struct {
        Email     string `json:"email" validate:"required,email,max=100,no_sql_injection,no_xss"`
        Phone     string `json:"phone" validate:"required,phone"`
        FirstName string `json:"firstName" validate:"required,min=2,max=50,alpha,no_sql_injection,no_xss"`
        LastName  string `json:"lastName" validate:"required,min=2,max=50,alpha,no_sql_injection,no_xss"`
        Password  string `json:"password" validate:"required,min=8,max=128"`
        Language  string `json:"language" validate:"alpha,max=5"`
}

// UserLogin represents user login data
type UserLogin struct {
        Identifier string `json:"identifier" validate:"required,max=100,no_sql_injection,no_xss"` // email or phone
        Password   string `json:"password" validate:"required,max=128"`
}

// UserProfileUpdate represents user profile update data
type UserProfileUpdate struct {
        FirstName           *string       `json:"firstName,omitempty"`
        LastName            *string       `json:"lastName,omitempty"`
        Avatar              *string       `json:"avatar,omitempty"`
        Language            *string       `json:"language,omitempty"`
        Theme               *string       `json:"theme,omitempty"`
        County              *string       `json:"county,omitempty"`
        Town                *string       `json:"town,omitempty"`
        Bio                 *string       `json:"bio,omitempty"`
        Occupation          *string       `json:"occupation,omitempty"`
        DateOfBirth         *FlexibleDate `json:"dateOfBirth,omitempty"`
        Latitude            *float64      `json:"latitude,omitempty"`
        Longitude           *float64      `json:"longitude,omitempty"`
        BusinessType        *string       `json:"businessType,omitempty"`
        BusinessDescription *string       `json:"businessDescription,omitempty"`
}

// GetFullName returns the user's full name
func (u *User) GetFullName() string <span class="cov0" title="0">{
        return u.FirstName + " " + u.LastName
}</span>

// IsActive checks if the user account is active
func (u *User) IsActive() bool <span class="cov0" title="0">{
        return u.Status == UserStatusActive || u.Status == UserStatusVerified
}</span>

// IsVerified checks if both email and phone are verified
func (u *User) IsVerified() bool <span class="cov0" title="0">{
        return u.IsEmailVerified &amp;&amp; u.IsPhoneVerified
}</span>

// GetLocation returns the user's location as a formatted string
func (u *User) GetLocation() string <span class="cov0" title="0">{
        if u.Town != nil &amp;&amp; u.County != nil </span><span class="cov0" title="0">{
                return *u.Town + ", " + *u.County
        }</span>
        <span class="cov0" title="0">if u.County != nil </span><span class="cov0" title="0">{
                return *u.County
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// HasCoordinates checks if the user has location coordinates
func (u *User) HasCoordinates() bool <span class="cov0" title="0">{
        return u.Latitude != nil &amp;&amp; u.Longitude != nil
}</span>

// GetCoordinates returns the user's coordinates
func (u *User) GetCoordinates() (float64, float64) <span class="cov0" title="0">{
        if u.HasCoordinates() </span><span class="cov0" title="0">{
                return *u.Latitude, *u.Longitude
        }</span>
        <span class="cov0" title="0">return 0, 0</span>
}

// FlexibleDate is a custom type that can handle both date and datetime formats
type FlexibleDate struct {
        time.Time
}

// UnmarshalJSON implements custom JSON unmarshaling for flexible date parsing
func (fd *FlexibleDate) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        // Remove quotes from JSON string
        str := string(data)
        if len(str) &gt;= 2 &amp;&amp; str[0] == '"' &amp;&amp; str[len(str)-1] == '"' </span><span class="cov0" title="0">{
                str = str[1 : len(str)-1]
        }</span>

        // Skip empty strings
        <span class="cov0" title="0">if str == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try different date formats
        <span class="cov0" title="0">formats := []string{
                "2006-01-02",                // Date only (YYYY-MM-DD)
                "2006-01-02T15:04:05Z07:00", // Full datetime with timezone
                "2006-01-02T15:04:05Z",      // Full datetime UTC
                "2006-01-02T15:04:05",       // Full datetime without timezone
                "2006-01-02 15:04:05",       // Date and time with space
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                if t, err := time.Parse(format, str); err == nil </span><span class="cov0" title="0">{
                        fd.Time = t
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("unable to parse date: %s", str)</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package models

import (
        "encoding/json"
        "time"
)

// WalletType represents the type of wallet
type WalletType string

const (
        WalletTypePersonal WalletType = "personal"
        WalletTypeChama    WalletType = "chama"
        WalletTypeBusiness WalletType = "business"
)

// TransactionType represents the type of transaction
type TransactionType string

const (
        TransactionTypeDeposit        TransactionType = "deposit"
        TransactionTypeWithdrawal     TransactionType = "withdrawal"
        TransactionTypeTransfer       TransactionType = "transfer"
        TransactionTypeContribution   TransactionType = "contribution"
        TransactionTypeLoan           TransactionType = "loan"
        TransactionTypeLoanRepayment  TransactionType = "loan_repayment"
        TransactionTypePurchase       TransactionType = "purchase"
        TransactionTypeRefund         TransactionType = "refund"
        TransactionTypeFee            TransactionType = "fee"
)

// TransactionStatus represents the status of a transaction
type TransactionStatus string

const (
        TransactionStatusPending    TransactionStatus = "pending"
        TransactionStatusCompleted  TransactionStatus = "completed"
        TransactionStatusFailed     TransactionStatus = "failed"
        TransactionStatusCancelled  TransactionStatus = "cancelled"
        TransactionStatusProcessing TransactionStatus = "processing"
)

// PaymentMethod represents the payment method used
type PaymentMethod string

const (
        PaymentMethodMpesa         PaymentMethod = "mpesa"
        PaymentMethodBankTransfer  PaymentMethod = "bank_transfer"
        PaymentMethodCash          PaymentMethod = "cash"
        PaymentMethodWalletTransfer PaymentMethod = "wallet_transfer"
)

// Wallet represents a wallet in the system
type Wallet struct {
        ID           string      `json:"id" db:"id"`
        Type         WalletType  `json:"type" db:"type"`
        OwnerID      string      `json:"ownerId" db:"owner_id"`
        Balance      float64     `json:"balance" db:"balance"`
        Currency     string      `json:"currency" db:"currency"`
        IsActive     bool        `json:"isActive" db:"is_active"`
        IsLocked     bool        `json:"isLocked" db:"is_locked"`
        DailyLimit   *float64    `json:"dailyLimit,omitempty" db:"daily_limit"`
        MonthlyLimit *float64    `json:"monthlyLimit,omitempty" db:"monthly_limit"`
        CreatedAt    time.Time   `json:"createdAt" db:"created_at"`
        UpdatedAt    time.Time   `json:"updatedAt" db:"updated_at"`
}

// Transaction represents a financial transaction
type Transaction struct {
        ID               string            `json:"id" db:"id"`
        FromWalletID     *string           `json:"fromWalletId,omitempty" db:"from_wallet_id"`
        ToWalletID       *string           `json:"toWalletId,omitempty" db:"to_wallet_id"`
        Type             TransactionType   `json:"type" db:"type"`
        Status           TransactionStatus `json:"status" db:"status"`
        Amount           float64           `json:"amount" db:"amount"`
        Currency         string            `json:"currency" db:"currency"`
        Description      *string           `json:"description,omitempty" db:"description"`
        Reference        *string           `json:"reference,omitempty" db:"reference"`
        PaymentMethod    PaymentMethod     `json:"paymentMethod" db:"payment_method"`
        Metadata         map[string]interface{} `json:"metadata,omitempty" db:"metadata"`
        Fees             float64           `json:"fees" db:"fees"`
        InitiatedBy      string            `json:"initiatedBy" db:"initiated_by"`
        ApprovedBy       *string           `json:"approvedBy,omitempty" db:"approved_by"`
        RequiresApproval bool              `json:"requiresApproval" db:"requires_approval"`
        ApprovalDeadline *time.Time        `json:"approvalDeadline,omitempty" db:"approval_deadline"`
        CreatedAt        time.Time         `json:"createdAt" db:"created_at"`
        UpdatedAt        time.Time         `json:"updatedAt" db:"updated_at"`
}

// TransactionCreation represents data for creating a new transaction
type TransactionCreation struct {
        FromWalletID  *string                `json:"fromWalletId,omitempty"`
        ToWalletID    *string                `json:"toWalletId,omitempty"`
        Type          TransactionType        `json:"type" validate:"required"`
        Amount        float64                `json:"amount" validate:"required,gt=0"`
        Description   *string                `json:"description,omitempty"`
        PaymentMethod PaymentMethod          `json:"paymentMethod" validate:"required"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// MpesaTransaction represents M-Pesa specific transaction data
type MpesaTransaction struct {
        PhoneNumber        string  `json:"phoneNumber" validate:"required"`
        Amount             float64 `json:"amount" validate:"required,gt=0"`
        AccountReference   string  `json:"accountReference" validate:"required"`
        TransactionDesc    string  `json:"transactionDesc" validate:"required"`
}

// MpesaCallback represents M-Pesa callback data
type MpesaCallback struct {
        MerchantRequestID   string `json:"MerchantRequestID"`
        CheckoutRequestID   string `json:"CheckoutRequestID"`
        ResultCode          int    `json:"ResultCode"`
        ResultDesc          string `json:"ResultDesc"`
        CallbackMetadata    *struct {
                Item []struct {
                        Name  string      `json:"Name"`
                        Value interface{} `json:"Value"`
                } `json:"Item"`
        } `json:"CallbackMetadata,omitempty"`
}

// WalletSummary represents a summary of wallet information
type WalletSummary struct {
        TotalBalance     float64 `json:"totalBalance"`
        PersonalBalance  float64 `json:"personalBalance"`
        ChamaBalance     float64 `json:"chamaBalance"`
        BusinessBalance  float64 `json:"businessBalance"`
        PendingIncoming  float64 `json:"pendingIncoming"`
        PendingOutgoing  float64 `json:"pendingOutgoing"`
        MonthlyIncome    float64 `json:"monthlyIncome"`
        MonthlyExpenses  float64 `json:"monthlyExpenses"`
}

// IsAvailable checks if the wallet is available for transactions
func (w *Wallet) IsAvailable() bool <span class="cov0" title="0">{
        return w.IsActive &amp;&amp; !w.IsLocked
}</span>

// CanWithdraw checks if the wallet can withdraw the specified amount
func (w *Wallet) CanWithdraw(amount float64) bool <span class="cov0" title="0">{
        return w.IsAvailable() &amp;&amp; w.Balance &gt;= amount
}</span>

// HasDailyLimit checks if the wallet has a daily limit
func (w *Wallet) HasDailyLimit() bool <span class="cov0" title="0">{
        return w.DailyLimit != nil
}</span>

// HasMonthlyLimit checks if the wallet has a monthly limit
func (w *Wallet) HasMonthlyLimit() bool <span class="cov0" title="0">{
        return w.MonthlyLimit != nil
}</span>

// GetDailyLimit returns the daily limit or 0 if not set
func (w *Wallet) GetDailyLimit() float64 <span class="cov0" title="0">{
        if w.DailyLimit != nil </span><span class="cov0" title="0">{
                return *w.DailyLimit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// GetMonthlyLimit returns the monthly limit or 0 if not set
func (w *Wallet) GetMonthlyLimit() float64 <span class="cov0" title="0">{
        if w.MonthlyLimit != nil </span><span class="cov0" title="0">{
                return *w.MonthlyLimit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// IsCompleted checks if the transaction is completed
func (t *Transaction) IsCompleted() bool <span class="cov0" title="0">{
        return t.Status == TransactionStatusCompleted
}</span>

// IsPending checks if the transaction is pending
func (t *Transaction) IsPending() bool <span class="cov0" title="0">{
        return t.Status == TransactionStatusPending
}</span>

// IsFailed checks if the transaction failed
func (t *Transaction) IsFailed() bool <span class="cov0" title="0">{
        return t.Status == TransactionStatusFailed
}</span>

// IsApproved checks if the transaction is approved
func (t *Transaction) IsApproved() bool <span class="cov0" title="0">{
        return t.ApprovedBy != nil
}</span>

// NeedsApproval checks if the transaction needs approval
func (t *Transaction) NeedsApproval() bool <span class="cov0" title="0">{
        return t.RequiresApproval &amp;&amp; !t.IsApproved()
}</span>

// IsExpired checks if the approval deadline has passed
func (t *Transaction) IsExpired() bool <span class="cov0" title="0">{
        return t.ApprovalDeadline != nil &amp;&amp; time.Now().After(*t.ApprovalDeadline)
}</span>

// GetTotalAmount returns the total amount including fees
func (t *Transaction) GetTotalAmount() float64 <span class="cov0" title="0">{
        return t.Amount + t.Fees
}</span>

// GetMetadataJSON returns metadata as JSON string for database storage
func (t *Transaction) GetMetadataJSON() (string, error) <span class="cov0" title="0">{
        if len(t.Metadata) == 0 </span><span class="cov0" title="0">{
                return "{}", nil
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(t.Metadata)
        return string(data), err</span>
}

// SetMetadataFromJSON sets metadata from JSON string
func (t *Transaction) SetMetadataFromJSON(metadataJSON string) error <span class="cov0" title="0">{
        if metadataJSON == "" || metadataJSON == "{}" </span><span class="cov0" title="0">{
                t.Metadata = make(map[string]interface{})
                return nil
        }</span>
        <span class="cov0" title="0">return json.Unmarshal([]byte(metadataJSON), &amp;t.Metadata)</span>
}

// IsDebit checks if the transaction is a debit (money going out)
func (t *Transaction) IsDebit() bool <span class="cov0" title="0">{
        return t.Type == TransactionTypeWithdrawal || 
                   t.Type == TransactionTypeTransfer || 
                   t.Type == TransactionTypeContribution ||
                   t.Type == TransactionTypePurchase ||
                   t.Type == TransactionTypeFee
}</span>

// IsCredit checks if the transaction is a credit (money coming in)
func (t *Transaction) IsCredit() bool <span class="cov0" title="0">{
        return t.Type == TransactionTypeDeposit || 
                   t.Type == TransactionTypeLoan ||
                   t.Type == TransactionTypeRefund
}</span>

// GetMpesaAmount extracts amount from M-Pesa callback metadata
func (mc *MpesaCallback) GetMpesaAmount() float64 <span class="cov0" title="0">{
        if mc.CallbackMetadata == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        <span class="cov0" title="0">for _, item := range mc.CallbackMetadata.Item </span><span class="cov0" title="0">{
                if item.Name == "Amount" </span><span class="cov0" title="0">{
                        if amount, ok := item.Value.(float64); ok </span><span class="cov0" title="0">{
                                return amount
                        }</span>
                }
        }
        <span class="cov0" title="0">return 0</span>
}

// GetMpesaReceiptNumber extracts receipt number from M-Pesa callback metadata
func (mc *MpesaCallback) GetMpesaReceiptNumber() string <span class="cov0" title="0">{
        if mc.CallbackMetadata == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">for _, item := range mc.CallbackMetadata.Item </span><span class="cov0" title="0">{
                if item.Name == "MpesaReceiptNumber" </span><span class="cov0" title="0">{
                        if receipt, ok := item.Value.(string); ok </span><span class="cov0" title="0">{
                                return receipt
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// GetMpesaPhoneNumber extracts phone number from M-Pesa callback metadata
func (mc *MpesaCallback) GetMpesaPhoneNumber() string <span class="cov0" title="0">{
        if mc.CallbackMetadata == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">for _, item := range mc.CallbackMetadata.Item </span><span class="cov0" title="0">{
                if item.Name == "PhoneNumber" </span><span class="cov0" title="0">{
                        if phone, ok := item.Value.(string); ok </span><span class="cov0" title="0">{
                                return phone
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package services

import (
        "fmt"
        "sync"
        "time"

        "github.com/golang-jwt/jwt/v5"

        "vaultke-backend/internal/models"
)

// AuthService handles authentication-related business logic
type AuthService struct {
        jwtSecret     string
        jwtExpiration time.Duration
        // In-memory blacklist for tokens (in production, use Redis or database)
        blacklistedTokens map[string]time.Time
        blacklistMutex    sync.RWMutex
}

// NewAuthService creates a new auth service
func NewAuthService(jwtSecret string, jwtExpirationSeconds int) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                jwtSecret:         jwtSecret,
                jwtExpiration:     time.Duration(jwtExpirationSeconds) * time.Second,
                blacklistedTokens: make(map[string]time.Time),
        }
}</span>

// JWTClaims represents JWT token claims
type JWTClaims struct {
        UserID string `json:"userId"`
        Email  string `json:"email"`
        Role   string `json:"role"`
        jwt.RegisteredClaims
}

// GenerateToken generates a JWT token for a user
func (s *AuthService) GenerateToken(user *models.User) (string, error) <span class="cov8" title="1">{
        now := time.Now()
        claims := &amp;JWTClaims{
                UserID: user.ID,
                Email:  user.Email,
                Role:   string(user.Role),
                RegisteredClaims: jwt.RegisteredClaims{
                        IssuedAt:  jwt.NewNumericDate(now),
                        ExpiresAt: jwt.NewNumericDate(now.Add(s.jwtExpiration)),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    "vaultke",
                        Subject:   user.ID,
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(s.jwtSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign token: %w", err)
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}

// ValidateToken validates a JWT token and returns the claims
func (s *AuthService) ValidateToken(tokenString string) (*JWTClaims, error) <span class="cov8" title="1">{
        // Check if token is blacklisted first
        if s.IsTokenBlacklisted(tokenString) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("token has been revoked")
        }</span>

        <span class="cov8" title="1">token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                // Validate signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return []byte(s.jwtSecret), nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token")
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(*JWTClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

// RefreshToken generates a new token for a user (if the current token is valid)
func (s *AuthService) RefreshToken(tokenString string) (string, error) <span class="cov0" title="0">{
        claims, err := s.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Check if token is close to expiry (within 1 hour)
        <span class="cov0" title="0">if time.Until(claims.ExpiresAt.Time) &gt; time.Hour </span><span class="cov0" title="0">{
                return "", fmt.Errorf("token is not close to expiry")
        }</span>

        // Create new token with same claims but new expiry
        <span class="cov0" title="0">now := time.Now()
        newClaims := &amp;JWTClaims{
                UserID: claims.UserID,
                Email:  claims.Email,
                Role:   claims.Role,
                RegisteredClaims: jwt.RegisteredClaims{
                        IssuedAt:  jwt.NewNumericDate(now),
                        ExpiresAt: jwt.NewNumericDate(now.Add(s.jwtExpiration)),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    "vaultke",
                        Subject:   claims.UserID,
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, newClaims)
        tokenString, err = token.SignedString([]byte(s.jwtSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign refreshed token: %w", err)
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}

// ExtractUserIDFromToken extracts user ID from token without full validation
func (s *AuthService) ExtractUserIDFromToken(tokenString string) (string, error) <span class="cov0" title="0">{
        claims, err := s.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return claims.UserID, nil</span>
}

// IsTokenExpired checks if a token is expired
func (s *AuthService) IsTokenExpired(tokenString string) bool <span class="cov0" title="0">{
        claims, err := s.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return time.Now().After(claims.ExpiresAt.Time)</span>
}

// GetTokenExpiryTime returns the expiry time of a token
func (s *AuthService) GetTokenExpiryTime(tokenString string) (time.Time, error) <span class="cov8" title="1">{
        claims, err := s.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">return claims.ExpiresAt.Time, nil</span>
}

// BlacklistToken adds a token to the blacklist
func (s *AuthService) BlacklistToken(tokenString string) error <span class="cov8" title="1">{
        // Get token expiry time to know when to remove it from blacklist
        expiryTime, err := s.GetTokenExpiryTime(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't parse the token, still add it to blacklist with a default expiry
                expiryTime = time.Now().Add(s.jwtExpiration)
        }</span>

        <span class="cov8" title="1">s.blacklistMutex.Lock()
        defer s.blacklistMutex.Unlock()

        s.blacklistedTokens[tokenString] = expiryTime
        return nil</span>
}

// IsTokenBlacklisted checks if a token is blacklisted
func (s *AuthService) IsTokenBlacklisted(tokenString string) bool <span class="cov8" title="1">{
        s.blacklistMutex.RLock()
        defer s.blacklistMutex.RUnlock()

        expiryTime, exists := s.blacklistedTokens[tokenString]
        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>

        // If token has expired, remove it from blacklist and return false
        <span class="cov8" title="1">if time.Now().After(expiryTime) </span><span class="cov0" title="0">{
                s.blacklistMutex.RUnlock()
                s.blacklistMutex.Lock()
                delete(s.blacklistedTokens, tokenString)
                s.blacklistMutex.Unlock()
                s.blacklistMutex.RLock()
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// CleanupExpiredTokens removes expired tokens from the blacklist
func (s *AuthService) CleanupExpiredTokens() <span class="cov0" title="0">{
        s.blacklistMutex.Lock()
        defer s.blacklistMutex.Unlock()

        now := time.Now()
        for token, expiryTime := range s.blacklistedTokens </span><span class="cov0" title="0">{
                if now.After(expiryTime) </span><span class="cov0" title="0">{
                        delete(s.blacklistedTokens, token)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "time"

        "golang.org/x/oauth2"
        "golang.org/x/oauth2/google"
        "google.golang.org/api/calendar/v3"
        "google.golang.org/api/option"
)

// CalendarService handles Google Calendar integration
type CalendarService struct {
        service *calendar.Service
        config  *oauth2.Config
}

// CalendarEvent represents a calendar event
type CalendarEvent struct {
        ID          string    `json:"id"`
        Title       string    `json:"title"`
        Description string    `json:"description"`
        StartTime   time.Time `json:"startTime"`
        EndTime     time.Time `json:"endTime"`
        Location    string    `json:"location"`
        MeetingURL  string    `json:"meetingUrl"`
        Attendees   []string  `json:"attendees"`
}

// NewCalendarService creates a new calendar service instance
func NewCalendarService(credentialsJSON []byte) (*CalendarService, error) <span class="cov0" title="0">{
        config, err := google.ConfigFromJSON(credentialsJSON, calendar.CalendarScope)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse credentials: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;CalendarService{
                config: config,
        }, nil</span>
}

// InitializeWithToken initializes the service with an OAuth token
func (cs *CalendarService) InitializeWithToken(token *oauth2.Token) error <span class="cov0" title="0">{
        ctx := context.Background()
        client := cs.config.Client(ctx, token)

        service, err := calendar.NewService(ctx, option.WithHTTPClient(client))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create calendar service: %w", err)
        }</span>

        <span class="cov0" title="0">cs.service = service
        return nil</span>
}

// CreateEvent creates a new calendar event
func (cs *CalendarService) CreateEvent(calendarID string, event *CalendarEvent) (*calendar.Event, error) <span class="cov0" title="0">{
        if cs.service == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("calendar service not initialized")
        }</span>

        // Convert attendees to calendar attendees
        <span class="cov0" title="0">var attendees []*calendar.EventAttendee
        for _, email := range event.Attendees </span><span class="cov0" title="0">{
                attendees = append(attendees, &amp;calendar.EventAttendee{
                        Email: email,
                })
        }</span>

        // Create the calendar event
        <span class="cov0" title="0">calendarEvent := &amp;calendar.Event{
                Summary:     event.Title,
                Description: event.Description,
                Location:    event.Location,
                Start: &amp;calendar.EventDateTime{
                        DateTime: event.StartTime.Format(time.RFC3339),
                        TimeZone: "UTC",
                },
                End: &amp;calendar.EventDateTime{
                        DateTime: event.EndTime.Format(time.RFC3339),
                        TimeZone: "UTC",
                },
                Attendees: attendees,
        }

        // Add meeting URL to description if provided
        if event.MeetingURL != "" </span><span class="cov0" title="0">{
                calendarEvent.Description += fmt.Sprintf("\n\nJoin meeting: %s", event.MeetingURL)
                
                // Add conference data for Google Meet integration
                calendarEvent.ConferenceData = &amp;calendar.ConferenceData{
                        CreateRequest: &amp;calendar.CreateConferenceRequest{
                                RequestId: fmt.Sprintf("meeting_%d", time.Now().Unix()),
                        },
                }
        }</span>

        // Create the event
        <span class="cov0" title="0">createdEvent, err := cs.service.Events.Insert(calendarID, calendarEvent).Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create calendar event: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Created calendar event: %s (ID: %s)", createdEvent.Summary, createdEvent.Id)
        return createdEvent, nil</span>
}

// UpdateEvent updates an existing calendar event
func (cs *CalendarService) UpdateEvent(calendarID, eventID string, event *CalendarEvent) (*calendar.Event, error) <span class="cov0" title="0">{
        if cs.service == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("calendar service not initialized")
        }</span>

        // Get the existing event
        <span class="cov0" title="0">existingEvent, err := cs.service.Events.Get(calendarID, eventID).Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get existing event: %w", err)
        }</span>

        // Update the event fields
        <span class="cov0" title="0">existingEvent.Summary = event.Title
        existingEvent.Description = event.Description
        existingEvent.Location = event.Location
        existingEvent.Start = &amp;calendar.EventDateTime{
                DateTime: event.StartTime.Format(time.RFC3339),
                TimeZone: "UTC",
        }
        existingEvent.End = &amp;calendar.EventDateTime{
                DateTime: event.EndTime.Format(time.RFC3339),
                TimeZone: "UTC",
        }

        // Update attendees
        var attendees []*calendar.EventAttendee
        for _, email := range event.Attendees </span><span class="cov0" title="0">{
                attendees = append(attendees, &amp;calendar.EventAttendee{
                        Email: email,
                })
        }</span>
        <span class="cov0" title="0">existingEvent.Attendees = attendees

        // Add meeting URL to description if provided
        if event.MeetingURL != "" </span><span class="cov0" title="0">{
                existingEvent.Description += fmt.Sprintf("\n\nJoin meeting: %s", event.MeetingURL)
        }</span>

        // Update the event
        <span class="cov0" title="0">updatedEvent, err := cs.service.Events.Update(calendarID, eventID, existingEvent).Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update calendar event: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Updated calendar event: %s (ID: %s)", updatedEvent.Summary, updatedEvent.Id)
        return updatedEvent, nil</span>
}

// DeleteEvent deletes a calendar event
func (cs *CalendarService) DeleteEvent(calendarID, eventID string) error <span class="cov0" title="0">{
        if cs.service == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("calendar service not initialized")
        }</span>

        <span class="cov0" title="0">err := cs.service.Events.Delete(calendarID, eventID).Do()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete calendar event: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Deleted calendar event: %s", eventID)
        return nil</span>
}

// GetEvent retrieves a calendar event
func (cs *CalendarService) GetEvent(calendarID, eventID string) (*calendar.Event, error) <span class="cov0" title="0">{
        if cs.service == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("calendar service not initialized")
        }</span>

        <span class="cov0" title="0">event, err := cs.service.Events.Get(calendarID, eventID).Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get calendar event: %w", err)
        }</span>

        <span class="cov0" title="0">return event, nil</span>
}

// ListEvents lists calendar events within a time range
func (cs *CalendarService) ListEvents(calendarID string, timeMin, timeMax time.Time) ([]*calendar.Event, error) <span class="cov0" title="0">{
        if cs.service == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("calendar service not initialized")
        }</span>

        <span class="cov0" title="0">events, err := cs.service.Events.List(calendarID).
                TimeMin(timeMin.Format(time.RFC3339)).
                TimeMax(timeMax.Format(time.RFC3339)).
                SingleEvents(true).
                OrderBy("startTime").
                Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list calendar events: %w", err)
        }</span>

        <span class="cov0" title="0">return events.Items, nil</span>
}

// GetAuthURL returns the OAuth authorization URL
func (cs *CalendarService) GetAuthURL(state string) string <span class="cov0" title="0">{
        return cs.config.AuthCodeURL(state, oauth2.AccessTypeOffline)
}</span>

// ExchangeCode exchanges an authorization code for a token
func (cs *CalendarService) ExchangeCode(code string) (*oauth2.Token, error) <span class="cov0" title="0">{
        ctx := context.Background()
        token, err := cs.config.Exchange(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to exchange code for token: %w", err)
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

// TokenToJSON converts a token to JSON string
func (cs *CalendarService) TokenToJSON(token *oauth2.Token) (string, error) <span class="cov0" title="0">{
        tokenJSON, err := json.Marshal(token)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal token: %w", err)
        }</span>

        <span class="cov0" title="0">return string(tokenJSON), nil</span>
}

// TokenFromJSON creates a token from JSON string
func (cs *CalendarService) TokenFromJSON(tokenJSON string) (*oauth2.Token, error) <span class="cov0" title="0">{
        var token oauth2.Token
        err := json.Unmarshal([]byte(tokenJSON), &amp;token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal token: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;token, nil</span>
}

// CreateMeetingEvent creates a calendar event for a chama meeting
func (cs *CalendarService) CreateMeetingEvent(calendarID string, meeting *Meeting, attendeeEmails []string) (*calendar.Event, error) <span class="cov0" title="0">{
        event := &amp;CalendarEvent{
                Title:       meeting.Title,
                Description: meeting.Description,
                StartTime:   meeting.ScheduledAt,
                EndTime:     meeting.ScheduledAt.Add(time.Duration(meeting.Duration) * time.Minute),
                Location:    meeting.Location,
                MeetingURL:  meeting.MeetingURL,
                Attendees:   attendeeEmails,
        }

        return cs.CreateEvent(calendarID, event)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package services

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "vaultke-backend/internal/models"
        "vaultke-backend/internal/utils"

        "github.com/google/uuid"
)

// AddToCart adds a product to user's cart
func (s *MarketplaceService) AddToCart(userID, productID string, quantity int) error <span class="cov0" title="0">{
        // Check if product exists and is available
        product, err := s.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !product.IsAvailable() </span><span class="cov0" title="0">{
                return fmt.Errorf("product is not available")
        }</span>

        <span class="cov0" title="0">if !product.IsInStock(quantity) </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient stock")
        }</span>

        <span class="cov0" title="0">if !product.CanOrder(quantity) </span><span class="cov0" title="0">{
                return fmt.Errorf("quantity not within order limits")
        }</span>

        // Check if item already in cart
        <span class="cov0" title="0">var existingID string
        checkQuery := "SELECT id FROM cart_items WHERE user_id = ? AND product_id = ?"
        err = s.db.QueryRow(checkQuery, userID, productID).Scan(&amp;existingID)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                // Add new item to cart
                cartItem := &amp;models.CartItem{
                        ID:        uuid.New().String(),
                        UserID:    userID,
                        ProductID: productID,
                        Quantity:  quantity,
                        Price:     product.Price,
                        AddedAt:   utils.NowEAT(),
                }

                insertQuery := `
                        INSERT INTO cart_items (id, user_id, product_id, quantity, price, added_at)
                        VALUES (?, ?, ?, ?, ?, ?)
                `
                _, err = s.db.Exec(insertQuery,
                        cartItem.ID, cartItem.UserID, cartItem.ProductID,
                        cartItem.Quantity, cartItem.Price, cartItem.AddedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add to cart: %w", err)
                }</span>
        } else<span class="cov0" title="0"> if err == nil </span><span class="cov0" title="0">{
                // Update existing item quantity
                updateQuery := "UPDATE cart_items SET quantity = quantity + ?, price = ? WHERE id = ?"
                _, err = s.db.Exec(updateQuery, quantity, product.Price, existingID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update cart item: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("failed to check cart: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetCart retrieves user's cart items with full product and seller details (only in-stock products)
func (s *MarketplaceService) GetCart(userID string) ([]*models.CartItem, error) <span class="cov0" title="0">{
        query := `
                SELECT ci.id, ci.user_id, ci.product_id, ci.quantity, ci.price, ci.added_at,
                           p.id, p.name, p.description, p.category, p.price, p.currency, p.images,
                           p.status, p.stock, p.seller_id, p.county, p.town,
                           u.first_name, u.last_name, u.avatar
                FROM cart_items ci
                INNER JOIN products p ON ci.product_id = p.id
                INNER JOIN users u ON p.seller_id = u.id
                WHERE ci.user_id = ? AND p.status = ? AND p.stock &gt; 0
                ORDER BY ci.added_at DESC
        `

        rows, err := s.db.Query(query, userID, models.ProductStatusActive)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query cart items: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var cartItems []*models.CartItem
        for rows.Next() </span><span class="cov0" title="0">{
                var item models.CartItem
                var product models.Product
                var seller models.User
                var images string
                var sellerAvatar sql.NullString

                err := rows.Scan(
                        &amp;item.ID, &amp;item.UserID, &amp;item.ProductID, &amp;item.Quantity, &amp;item.Price, &amp;item.AddedAt,
                        &amp;product.ID, &amp;product.Name, &amp;product.Description, &amp;product.Category, &amp;product.Price,
                        &amp;product.Currency, &amp;images, &amp;product.Status, &amp;product.Stock, &amp;product.SellerID,
                        &amp;product.County, &amp;product.Town,
                        &amp;seller.FirstName, &amp;seller.LastName, &amp;sellerAvatar,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse images JSON
                <span class="cov0" title="0">if images != "" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal([]byte(images), &amp;product.Images); err != nil </span><span class="cov0" title="0">{
                                product.Images = []string{}
                        }</span>
                }

                // Set seller info
                <span class="cov0" title="0">seller.ID = product.SellerID
                if sellerAvatar.Valid </span><span class="cov0" title="0">{
                        seller.Avatar = &amp;sellerAvatar.String
                }</span>
                <span class="cov0" title="0">product.Seller = &amp;seller

                // Set product in cart item
                item.Product = &amp;product

                cartItems = append(cartItems, &amp;item)</span>
        }

        <span class="cov0" title="0">return cartItems, nil</span>
}

// RemoveFromCart removes an item from cart
func (s *MarketplaceService) RemoveFromCart(userID, cartItemID string) error <span class="cov0" title="0">{
        query := "DELETE FROM cart_items WHERE id = ? AND user_id = ?"
        result, err := s.db.Exec(query, cartItemID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove from cart: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check affected rows: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cart item not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package services

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/utils"
)

// ChamaService handles chama-related business logic
type ChamaService struct {
        db           *sql.DB
        emailService *EmailService
}

// NewChamaService creates a new chama service
func NewChamaService(db *sql.DB) *ChamaService <span class="cov8" title="1">{
        return &amp;ChamaService{
                db:           db,
                emailService: NewEmailService(),
        }
}</span>

// CreateChama creates a new chama
func (s *ChamaService) CreateChama(creation *models.ChamaCreation, createdBy string) (*models.Chama, error) <span class="cov0" title="0">{
        // Validate input
        if err := utils.ValidateStruct(creation); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        // Create chama
        <span class="cov0" title="0">chama := &amp;models.Chama{
                ID:                    uuid.New().String(),
                Name:                  creation.Name,
                Description:           creation.Description,
                Type:                  creation.Type,
                Status:                models.ChamaStatusActive,
                County:                creation.County,
                Town:                  creation.Town,
                Latitude:              creation.Latitude,
                Longitude:             creation.Longitude,
                ContributionAmount:    creation.ContributionAmount,
                ContributionFrequency: creation.ContributionFrequency,
                MaxMembers:            creation.MaxMembers,
                CurrentMembers:        1, // Creator is the first member
                TotalFunds:            0,
                IsPublic:              creation.IsPublic,
                RequiresApproval:      creation.RequiresApproval,
                Rules:                 creation.Rules,
                MeetingSchedule:       creation.MeetingSchedule,
                CreatedBy:             createdBy,
                CreatedAt:             time.Now(),
                UpdatedAt:             time.Now(),
        }

        // Serialize JSON fields
        rulesJSON, err := chama.GetRulesJSON()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to serialize rules: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = chama.GetMeetingScheduleJSON()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to serialize meeting schedule: %w", err)
        }</span>

        // Start database transaction
        <span class="cov0" title="0">tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Insert chama
        query := `
                INSERT INTO chamas (
                        id, name, description, type, status, county, town, latitude, longitude,
                        contribution_amount, contribution_frequency, max_members, current_members,
                        total_funds, is_public, requires_approval, rules, meeting_frequency,
                        meeting_day_of_week, meeting_day_of_month, meeting_time, created_by,
                        created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        var meetingFreq, meetingTime *string
        var meetingDayOfWeek, meetingDayOfMonth *int

        if chama.MeetingSchedule != nil </span><span class="cov0" title="0">{
                meetingFreq = &amp;chama.MeetingSchedule.Frequency
                meetingTime = &amp;chama.MeetingSchedule.Time
                meetingDayOfWeek = chama.MeetingSchedule.DayOfWeek
                meetingDayOfMonth = chama.MeetingSchedule.DayOfMonth
        }</span>

        <span class="cov0" title="0">_, err = tx.Exec(query,
                chama.ID, chama.Name, chama.Description, chama.Type, chama.Status,
                chama.County, chama.Town, chama.Latitude, chama.Longitude,
                chama.ContributionAmount, chama.ContributionFrequency, chama.MaxMembers,
                chama.CurrentMembers, chama.TotalFunds, chama.IsPublic, chama.RequiresApproval,
                rulesJSON, meetingFreq, meetingDayOfWeek, meetingDayOfMonth, meetingTime,
                chama.CreatedBy, chama.CreatedAt, chama.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create chama: %w", err)
        }</span>

        // Add creator as chairperson
        <span class="cov0" title="0">member := &amp;models.ChamaMember{
                ID:                 uuid.New().String(),
                ChamaID:            chama.ID,
                UserID:             createdBy,
                Role:               models.ChamaRoleChairperson,
                JoinedAt:           time.Now(),
                IsActive:           true,
                TotalContributions: 0,
                Rating:             0,
                TotalRatings:       0,
        }

        memberQuery := `
                INSERT INTO chama_members (
                        id, chama_id, user_id, role, joined_at, is_active,
                        total_contributions, rating, total_ratings
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = tx.Exec(memberQuery,
                member.ID, member.ChamaID, member.UserID, member.Role, member.JoinedAt,
                member.IsActive, member.TotalContributions, member.Rating, member.TotalRatings,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add creator as member: %w", err)
        }</span>

        // Create chama wallet within the same transaction
        <span class="cov0" title="0">walletService := NewWalletService(s.db)
        _, err = walletService.CreateWalletWithTx(tx, chama.ID, models.WalletTypeChama)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create chama wallet: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return chama, nil</span>
}

// GetChamaByID retrieves a chama by ID
func (s *ChamaService) GetChamaByID(chamaID string) (*models.Chama, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, type, status, avatar, county, town,
                           latitude, longitude, contribution_amount, contribution_frequency,
                           max_members, current_members, total_funds, is_public, requires_approval,
                           rules, meeting_frequency, meeting_day_of_week, meeting_day_of_month,
                           meeting_time, permissions, created_by, created_at, updated_at
                FROM chamas WHERE id = ?
        `

        chama := &amp;models.Chama{}
        var rulesJSON, permissionsJSON string
        var meetingFreq, meetingTime *string
        var meetingDayOfWeek, meetingDayOfMonth *int

        err := s.db.QueryRow(query, chamaID).Scan(
                &amp;chama.ID, &amp;chama.Name, &amp;chama.Description, &amp;chama.Type, &amp;chama.Status,
                &amp;chama.Avatar, &amp;chama.County, &amp;chama.Town, &amp;chama.Latitude, &amp;chama.Longitude,
                &amp;chama.ContributionAmount, &amp;chama.ContributionFrequency, &amp;chama.MaxMembers,
                &amp;chama.CurrentMembers, &amp;chama.TotalFunds, &amp;chama.IsPublic, &amp;chama.RequiresApproval,
                &amp;rulesJSON, &amp;meetingFreq, &amp;meetingDayOfWeek, &amp;meetingDayOfMonth, &amp;meetingTime,
                &amp;permissionsJSON, &amp;chama.CreatedBy, &amp;chama.CreatedAt, &amp;chama.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("chama not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get chama: %w", err)</span>
        }

        // Parse JSON fields
        <span class="cov0" title="0">if err = chama.SetRulesFromJSON(rulesJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse rules: %w", err)
        }</span>

        // Parse permissions JSON
        <span class="cov0" title="0">if permissionsJSON != "" </span><span class="cov0" title="0">{
                var permissions map[string]interface{}
                if err := json.Unmarshal([]byte(permissionsJSON), &amp;permissions); err == nil </span><span class="cov0" title="0">{
                        chama.Permissions = permissions
                }</span>
        }
        // Set default permissions if none exist
        <span class="cov0" title="0">if chama.Permissions == nil </span><span class="cov0" title="0">{
                chama.Permissions = map[string]interface{}{
                        "allowMerryGoRound": true,
                        "allowWelfare":      true,
                        "allowMarketplace":  true,
                }
        }</span>

        // Reconstruct meeting schedule
        <span class="cov0" title="0">if meetingFreq != nil </span><span class="cov0" title="0">{
                chama.MeetingSchedule = &amp;models.MeetingSchedule{
                        Frequency:  *meetingFreq,
                        DayOfWeek:  meetingDayOfWeek,
                        DayOfMonth: meetingDayOfMonth,
                        Time:       utils.DerefString(meetingTime),
                }
        }</span>

        <span class="cov0" title="0">return chama, nil</span>
}

// GetChamas retrieves all public chamas
func (s *ChamaService) GetChamas(limit, offset int) ([]*models.Chama, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, description, type, status, avatar, county, town,
                           latitude, longitude, contribution_amount, contribution_frequency,
                           max_members, current_members, total_funds, is_public, requires_approval,
                           rules, meeting_frequency, meeting_day_of_week, meeting_day_of_month,
                           meeting_time, created_by, created_at, updated_at
                FROM chamas
                WHERE is_public = true AND status = 'active'
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get chamas: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var chamas []*models.Chama
        for rows.Next() </span><span class="cov0" title="0">{
                chama := &amp;models.Chama{}
                var rulesJSON string
                var meetingFreq, meetingTime *string
                var meetingDayOfWeek, meetingDayOfMonth *int

                err := rows.Scan(
                        &amp;chama.ID, &amp;chama.Name, &amp;chama.Description, &amp;chama.Type, &amp;chama.Status,
                        &amp;chama.Avatar, &amp;chama.County, &amp;chama.Town, &amp;chama.Latitude, &amp;chama.Longitude,
                        &amp;chama.ContributionAmount, &amp;chama.ContributionFrequency, &amp;chama.MaxMembers,
                        &amp;chama.CurrentMembers, &amp;chama.TotalFunds, &amp;chama.IsPublic, &amp;chama.RequiresApproval,
                        &amp;rulesJSON, &amp;meetingFreq, &amp;meetingDayOfWeek, &amp;meetingDayOfMonth, &amp;meetingTime,
                        &amp;chama.CreatedBy, &amp;chama.CreatedAt, &amp;chama.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan chama: %w", err)
                }</span>

                // Parse JSON fields
                <span class="cov0" title="0">if err = chama.SetRulesFromJSON(rulesJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse rules: %w", err)
                }</span>

                // Reconstruct meeting schedule
                <span class="cov0" title="0">if meetingFreq != nil </span><span class="cov0" title="0">{
                        chama.MeetingSchedule = &amp;models.MeetingSchedule{
                                Frequency:  *meetingFreq,
                                DayOfWeek:  meetingDayOfWeek,
                                DayOfMonth: meetingDayOfMonth,
                                Time:       utils.DerefString(meetingTime),
                        }
                }</span>

                <span class="cov0" title="0">chamas = append(chamas, chama)</span>
        }

        <span class="cov8" title="1">return chamas, nil</span>
}

// GetAllChamasForAdmin retrieves all chamas for admin management (no filters)
func (s *ChamaService) GetAllChamasForAdmin(limit, offset int) ([]*models.Chama, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, type, status, avatar, county, town,
                           latitude, longitude, contribution_amount, contribution_frequency,
                           max_members, current_members, total_funds, is_public, requires_approval,
                           rules, meeting_frequency, meeting_day_of_week, meeting_day_of_month,
                           meeting_time, created_by, created_at, updated_at
                FROM chamas
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all chamas for admin: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var chamas []*models.Chama
        for rows.Next() </span><span class="cov0" title="0">{
                chama := &amp;models.Chama{}
                var rulesJSON string
                var meetingFreq, meetingTime *string
                var meetingDayOfWeek, meetingDayOfMonth *int

                err := rows.Scan(
                        &amp;chama.ID, &amp;chama.Name, &amp;chama.Description, &amp;chama.Type, &amp;chama.Status,
                        &amp;chama.Avatar, &amp;chama.County, &amp;chama.Town, &amp;chama.Latitude, &amp;chama.Longitude,
                        &amp;chama.ContributionAmount, &amp;chama.ContributionFrequency, &amp;chama.MaxMembers,
                        &amp;chama.CurrentMembers, &amp;chama.TotalFunds, &amp;chama.IsPublic, &amp;chama.RequiresApproval,
                        &amp;rulesJSON, &amp;meetingFreq, &amp;meetingDayOfWeek, &amp;meetingDayOfMonth, &amp;meetingTime,
                        &amp;chama.CreatedBy, &amp;chama.CreatedAt, &amp;chama.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan chama: %w", err)
                }</span>

                // Parse JSON fields
                <span class="cov0" title="0">if err = chama.SetRulesFromJSON(rulesJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse rules: %w", err)
                }</span>

                // Reconstruct meeting schedule
                <span class="cov0" title="0">if meetingFreq != nil </span><span class="cov0" title="0">{
                        chama.MeetingSchedule = &amp;models.MeetingSchedule{
                                Frequency:  *meetingFreq,
                                DayOfWeek:  meetingDayOfWeek,
                                DayOfMonth: meetingDayOfMonth,
                                Time:       utils.DerefString(meetingTime),
                        }
                }</span>

                <span class="cov0" title="0">chamas = append(chamas, chama)</span>
        }

        <span class="cov0" title="0">return chamas, nil</span>
}

// GetChamasByUser retrieves chamas for a user
func (s *ChamaService) GetChamasByUser(userID string, limit, offset int) ([]*models.Chama, error) <span class="cov0" title="0">{
        query := `
                SELECT c.id, c.name, c.description, c.type, c.status, c.avatar, c.county, c.town,
                           c.latitude, c.longitude, c.contribution_amount, c.contribution_frequency,
                           c.max_members, c.current_members, c.total_funds, c.is_public, c.requires_approval,
                           c.rules, c.meeting_frequency, c.meeting_day_of_week, c.meeting_day_of_month,
                           c.meeting_time, c.created_by, c.created_at, c.updated_at
                FROM chamas c
                INNER JOIN chama_members cm ON c.id = cm.chama_id
                WHERE cm.user_id = ? AND cm.is_active = true
                ORDER BY c.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user chamas: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var chamas []*models.Chama
        for rows.Next() </span><span class="cov0" title="0">{
                chama := &amp;models.Chama{}
                var rulesJSON string
                var meetingFreq, meetingTime *string
                var meetingDayOfWeek, meetingDayOfMonth *int

                err := rows.Scan(
                        &amp;chama.ID, &amp;chama.Name, &amp;chama.Description, &amp;chama.Type, &amp;chama.Status,
                        &amp;chama.Avatar, &amp;chama.County, &amp;chama.Town, &amp;chama.Latitude, &amp;chama.Longitude,
                        &amp;chama.ContributionAmount, &amp;chama.ContributionFrequency, &amp;chama.MaxMembers,
                        &amp;chama.CurrentMembers, &amp;chama.TotalFunds, &amp;chama.IsPublic, &amp;chama.RequiresApproval,
                        &amp;rulesJSON, &amp;meetingFreq, &amp;meetingDayOfWeek, &amp;meetingDayOfMonth, &amp;meetingTime,
                        &amp;chama.CreatedBy, &amp;chama.CreatedAt, &amp;chama.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan chama: %w", err)
                }</span>

                // Parse JSON fields
                <span class="cov0" title="0">if err = chama.SetRulesFromJSON(rulesJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse rules: %w", err)
                }</span>

                // Reconstruct meeting schedule
                <span class="cov0" title="0">if meetingFreq != nil </span><span class="cov0" title="0">{
                        chama.MeetingSchedule = &amp;models.MeetingSchedule{
                                Frequency:  *meetingFreq,
                                DayOfWeek:  meetingDayOfWeek,
                                DayOfMonth: meetingDayOfMonth,
                                Time:       utils.DerefString(meetingTime),
                        }
                }</span>

                <span class="cov0" title="0">chamas = append(chamas, chama)</span>
        }

        <span class="cov0" title="0">return chamas, nil</span>
}

// JoinChama adds a user to a chama
func (s *ChamaService) JoinChama(chamaID, userID string) error <span class="cov0" title="0">{
        // Get chama
        chama, err := s.GetChamaByID(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if user can join
        <span class="cov0" title="0">if !chama.CanJoin() </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot join this chama")
        }</span>

        // Check if user is already a member
        <span class="cov0" title="0">exists, err := s.IsUserMember(chamaID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("user is already a member")
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Add member
        member := &amp;models.ChamaMember{
                ID:                 uuid.New().String(),
                ChamaID:            chamaID,
                UserID:             userID,
                Role:               models.ChamaRoleMember,
                JoinedAt:           time.Now(),
                IsActive:           true,
                TotalContributions: 0,
                Rating:             0,
                TotalRatings:       0,
        }

        memberQuery := `
                INSERT INTO chama_members (
                        id, chama_id, user_id, role, joined_at, is_active,
                        total_contributions, rating, total_ratings
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = tx.Exec(memberQuery,
                member.ID, member.ChamaID, member.UserID, member.Role, member.JoinedAt,
                member.IsActive, member.TotalContributions, member.Rating, member.TotalRatings,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add member: %w", err)
        }</span>

        // Update chama member count
        <span class="cov0" title="0">_, err = tx.Exec(
                "UPDATE chamas SET current_members = current_members + 1, updated_at = ? WHERE id = ?",
                time.Now(), chamaID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update member count: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LeaveChama removes a user from a chama
func (s *ChamaService) LeaveChama(chamaID, userID string) error <span class="cov0" title="0">{
        // Check if user is a member
        exists, err := s.IsUserMember(chamaID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("user is not a member")
        }</span>

        // Get member details
        <span class="cov0" title="0">member, err := s.GetChamaMember(chamaID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if user is chairperson (chairperson cannot leave unless transferring role)
        <span class="cov0" title="0">if member.Role == models.ChamaRoleChairperson </span><span class="cov0" title="0">{
                return fmt.Errorf("chairperson cannot leave without transferring role")
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Deactivate member
        _, err = tx.Exec(
                "UPDATE chama_members SET is_active = false WHERE chama_id = ? AND user_id = ?",
                chamaID, userID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deactivate member: %w", err)
        }</span>

        // Update chama member count
        <span class="cov0" title="0">_, err = tx.Exec(
                "UPDATE chamas SET current_members = current_members - 1, updated_at = ? WHERE id = ?",
                time.Now(), chamaID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update member count: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetChamaMembers retrieves members of a chama
func (s *ChamaService) GetChamaMembers(chamaID string) ([]*models.ChamaMember, error) <span class="cov0" title="0">{
        query := `
                SELECT cm.id, cm.chama_id, cm.user_id, cm.role, cm.joined_at, cm.is_active,
                           cm.total_contributions, cm.last_contribution, cm.rating, cm.total_ratings,
                           u.first_name, u.last_name, u.email, u.phone, u.avatar
                FROM chama_members cm
                INNER JOIN users u ON cm.user_id = u.id
                WHERE cm.chama_id = ? AND cm.is_active = true
                ORDER BY cm.joined_at ASC
        `

        rows, err := s.db.Query(query, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get chama members: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var members []*models.ChamaMember
        for rows.Next() </span><span class="cov0" title="0">{
                member := &amp;models.ChamaMember{}
                user := &amp;models.User{}

                err := rows.Scan(
                        &amp;member.ID, &amp;member.ChamaID, &amp;member.UserID, &amp;member.Role, &amp;member.JoinedAt,
                        &amp;member.IsActive, &amp;member.TotalContributions, &amp;member.LastContribution,
                        &amp;member.Rating, &amp;member.TotalRatings, &amp;user.FirstName, &amp;user.LastName,
                        &amp;user.Email, &amp;user.Phone, &amp;user.Avatar,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan member: %w", err)
                }</span>

                <span class="cov0" title="0">user.ID = member.UserID
                member.User = user
                members = append(members, member)</span>
        }

        <span class="cov0" title="0">return members, nil</span>
}

// GetChamaMember retrieves a specific chama member
func (s *ChamaService) GetChamaMember(chamaID, userID string) (*models.ChamaMember, error) <span class="cov0" title="0">{
        query := `
                SELECT id, chama_id, user_id, role, joined_at, is_active,
                           total_contributions, last_contribution, rating, total_ratings
                FROM chama_members
                WHERE chama_id = ? AND user_id = ?
        `

        member := &amp;models.ChamaMember{}
        err := s.db.QueryRow(query, chamaID, userID).Scan(
                &amp;member.ID, &amp;member.ChamaID, &amp;member.UserID, &amp;member.Role, &amp;member.JoinedAt,
                &amp;member.IsActive, &amp;member.TotalContributions, &amp;member.LastContribution,
                &amp;member.Rating, &amp;member.TotalRatings,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("member not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get member: %w", err)</span>
        }

        <span class="cov0" title="0">return member, nil</span>
}

// IsUserMember checks if a user is a member of a chama
func (s *ChamaService) IsUserMember(chamaID, userID string) (bool, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM chama_members WHERE chama_id = ? AND user_id = ? AND is_active = true"
        var count int
        err := s.db.QueryRow(query, chamaID, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check membership: %w", err)
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// UpdateMemberRole updates a member's role in a chama (with permission check)
func (s *ChamaService) UpdateMemberRole(chamaID, userID string, newRole models.ChamaRole, updatedBy string) error <span class="cov0" title="0">{
        // Check if updater has permission (only chairperson can change roles)
        updaterMember, err := s.GetChamaMember(chamaID, updatedBy)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if updaterMember.Role != models.ChamaRoleChairperson </span><span class="cov0" title="0">{
                return fmt.Errorf("only chairperson can update member roles")
        }</span>

        // Update role
        <span class="cov0" title="0">query := "UPDATE chama_members SET role = ? WHERE chama_id = ? AND user_id = ?"
        _, err = s.db.Exec(query, newRole, chamaID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update member role: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateMemberRoleSimple updates a member's role in a chama (for API compatibility)
func (s *ChamaService) UpdateMemberRoleSimple(chamaID, userID, newRole string) error <span class="cov0" title="0">{
        // Update role directly with string
        query := "UPDATE chama_members SET role = ?, updated_at = ? WHERE chama_id = ? AND user_id = ?"
        _, err := s.db.Exec(query, newRole, time.Now(), chamaID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update member role: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateMemberStatus updates a member's status in a chama
func (s *ChamaService) UpdateMemberStatus(chamaID, userID, status string) error <span class="cov0" title="0">{
        // Validate status
        validStatuses := map[string]bool{
                "active":    true,
                "inactive":  true,
                "suspended": true,
                "pending":   true,
        }

        if !validStatuses[status] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid status: %s", status)
        }</span>

        // Update status by setting is_active based on status
        <span class="cov0" title="0">isActive := status == "active"
        query := "UPDATE chama_members SET is_active = ?, updated_at = ? WHERE chama_id = ? AND user_id = ?"
        _, err := s.db.Exec(query, isActive, time.Now(), chamaID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update member status: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetChamaStatistics returns comprehensive statistics for a chama
func (s *ChamaService) GetChamaStatistics(chamaID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Get basic chama info
        chama, err := s.GetChamaByID(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get chama: %w", err)
        }</span>

        // Get member statistics
        <span class="cov0" title="0">memberStats, err := s.getMemberStatistics(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get member statistics: %w", err)
        }</span>

        // Get financial statistics
        <span class="cov0" title="0">financialStats, err := s.getFinancialStatistics(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get financial statistics: %w", err)
        }</span>

        // Get activity statistics
        <span class="cov0" title="0">activityStats, err := s.getActivityStatistics(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get activity statistics: %w", err)
        }</span>

        <span class="cov0" title="0">stats["chama_info"] = map[string]interface{}{
                "id":                     chama.ID,
                "name":                   chama.Name,
                "type":                   chama.Type,
                "status":                 chama.Status,
                "created_at":             chama.CreatedAt,
                "contribution_amount":    chama.ContributionAmount,
                "contribution_frequency": chama.ContributionFrequency,
                "max_members":            chama.MaxMembers,
                "current_members":        chama.CurrentMembers,
                "total_funds":            chama.TotalFunds,
        }

        stats["member_statistics"] = memberStats
        stats["financial_statistics"] = financialStats
        stats["activity_statistics"] = activityStats

        return stats, nil</span>
}

// getMemberStatistics gets member-related statistics
func (s *ChamaService) getMemberStatistics(chamaID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Count members by role
        roleQuery := `
                SELECT role, COUNT(*) as count
                FROM chama_members
                WHERE chama_id = ? AND is_active = true
                GROUP BY role
        `
        rows, err := s.db.Query(roleQuery, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        roleStats := make(map[string]int)
        totalMembers := 0
        for rows.Next() </span><span class="cov0" title="0">{
                var role string
                var count int
                if err := rows.Scan(&amp;role, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">roleStats[role] = count
                totalMembers += count</span>
        }

        <span class="cov0" title="0">stats["total_members"] = totalMembers
        stats["members_by_role"] = roleStats

        // Get member join trend (last 6 months)
        joinTrendQuery := `
                SELECT DATE(joined_at) as join_date, COUNT(*) as count
                FROM chama_members
                WHERE chama_id = ? AND joined_at &gt;= DATE('now', '-6 months')
                GROUP BY DATE(joined_at)
                ORDER BY join_date
        `
        rows, err = s.db.Query(joinTrendQuery, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        joinTrend := make([]map[string]interface{}, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var joinDate string
                var count int
                if err := rows.Scan(&amp;joinDate, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">joinTrend = append(joinTrend, map[string]interface{}{
                        "date":  joinDate,
                        "count": count,
                })</span>
        }

        <span class="cov0" title="0">stats["join_trend"] = joinTrend

        return stats, nil</span>
}

// getFinancialStatistics gets financial-related statistics
func (s *ChamaService) getFinancialStatistics(chamaID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Get total contributions
        contributionQuery := `
                SELECT
                        COALESCE(SUM(amount), 0) as total_contributions,
                        COUNT(*) as total_transactions,
                        COALESCE(AVG(amount), 0) as average_contribution
                FROM transactions
                WHERE chama_id = ? AND type = 'contribution' AND status = 'completed'
        `
        var totalContributions, averageContribution float64
        var totalTransactions int
        err := s.db.QueryRow(contributionQuery, chamaID).Scan(&amp;totalContributions, &amp;totalTransactions, &amp;averageContribution)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stats["total_contributions"] = totalContributions
        stats["total_transactions"] = totalTransactions
        stats["average_contribution"] = averageContribution

        // Get monthly contribution trend
        monthlyQuery := `
                SELECT
                        strftime('%Y-%m', created_at) as month,
                        COALESCE(SUM(amount), 0) as total,
                        COUNT(*) as count
                FROM transactions
                WHERE chama_id = ? AND type = 'contribution' AND status = 'completed'
                AND created_at &gt;= DATE('now', '-12 months')
                GROUP BY strftime('%Y-%m', created_at)
                ORDER BY month
        `
        rows, err := s.db.Query(monthlyQuery, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        monthlyTrend := make([]map[string]interface{}, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var month string
                var total float64
                var count int
                if err := rows.Scan(&amp;month, &amp;total, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">monthlyTrend = append(monthlyTrend, map[string]interface{}{
                        "month": month,
                        "total": total,
                        "count": count,
                })</span>
        }

        <span class="cov0" title="0">stats["monthly_trend"] = monthlyTrend

        return stats, nil</span>
}

// getActivityStatistics gets activity-related statistics
func (s *ChamaService) getActivityStatistics(chamaID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Get meeting statistics
        meetingQuery := `
                SELECT
                        COUNT(*) as total_meetings,
                        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_meetings,
                        COUNT(CASE WHEN status = 'scheduled' THEN 1 END) as scheduled_meetings
                FROM meetings
                WHERE chama_id = ?
        `
        var totalMeetings, completedMeetings, scheduledMeetings int
        err := s.db.QueryRow(meetingQuery, chamaID).Scan(&amp;totalMeetings, &amp;completedMeetings, &amp;scheduledMeetings)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stats["total_meetings"] = totalMeetings
        stats["completed_meetings"] = completedMeetings
        stats["scheduled_meetings"] = scheduledMeetings

        // Get loan statistics
        loanQuery := `
                SELECT
                        COUNT(*) as total_loans,
                        COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_loans,
                        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_loans,
                        COALESCE(SUM(CASE WHEN status = 'approved' THEN amount ELSE 0 END), 0) as total_loan_amount
                FROM loans
                WHERE chama_id = ?
        `
        var totalLoans, approvedLoans, pendingLoans int
        var totalLoanAmount float64
        err = s.db.QueryRow(loanQuery, chamaID).Scan(&amp;totalLoans, &amp;approvedLoans, &amp;pendingLoans, &amp;totalLoanAmount)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stats["total_loans"] = totalLoans
        stats["approved_loans"] = approvedLoans
        stats["pending_loans"] = pendingLoans
        stats["total_loan_amount"] = totalLoanAmount

        return stats, nil</span>
}

// AddMemberToChama adds a member to a chama with specified role
func (s *ChamaService) AddMemberToChama(chamaID, userID, role string) error <span class="cov0" title="0">{
        // Validate role
        validRoles := map[string]bool{
                "chairperson": true,
                "treasurer":   true,
                "secretary":   true,
                "member":      true,
                "assistant":   true,
        }

        if !validRoles[role] </span><span class="cov0" title="0">{
                role = "member" // Default to member if invalid role
        }</span>

        // Check if user is already a member
        <span class="cov0" title="0">checkQuery := `SELECT COUNT(*) FROM chama_members WHERE chama_id = ? AND user_id = ? AND is_active = true`
        var count int
        err := s.db.QueryRow(checkQuery, chamaID, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check existing membership: %w", err)
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("user is already a member of this chama")
        }</span>

        // Add member
        <span class="cov0" title="0">member := &amp;models.ChamaMember{
                ID:                 uuid.New().String(),
                ChamaID:            chamaID,
                UserID:             userID,
                Role:               models.ChamaRole(role),
                JoinedAt:           time.Now(),
                IsActive:           true,
                TotalContributions: 0,
                Rating:             0,
                TotalRatings:       0,
        }

        memberQuery := `
                INSERT INTO chama_members (
                        id, chama_id, user_id, role, joined_at, is_active,
                        total_contributions, rating, total_ratings
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.Exec(memberQuery,
                member.ID, member.ChamaID, member.UserID, member.Role, member.JoinedAt,
                member.IsActive, member.TotalContributions, member.Rating, member.TotalRatings,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add member to chama: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateChamaMemberCount updates the current member count for a chama
func (s *ChamaService) UpdateChamaMemberCount(chamaID string, memberCount int) error <span class="cov0" title="0">{
        query := `UPDATE chamas SET current_members = ?, updated_at = ? WHERE id = ?`

        _, err := s.db.Exec(query, memberCount, time.Now(), chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update chama member count: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetUserRoleInChama gets the user's role in a specific chama
func (s *ChamaService) GetUserRoleInChama(chamaID, userID string) (string, error) <span class="cov0" title="0">{
        query := `
                SELECT role
                FROM chama_members
                WHERE chama_id = ? AND user_id = ? AND is_active = true
        `

        var role string
        err := s.db.QueryRow(query, chamaID, userID).Scan(&amp;role)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("user is not a member of this chama")
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to get user role: %w", err)</span>
        }

        <span class="cov0" title="0">return role, nil</span>
}

// UpdateChamaSettings updates chama settings (only for chairperson)
func (s *ChamaService) UpdateChamaSettings(chamaID string, updates interface{}) error <span class="cov0" title="0">{
        // Start transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Build dynamic update query based on provided fields
        setParts := []string{}
        args := []interface{}{}

        // Use type assertion to handle the updates struct
        if updateMap, ok := updates.(*struct {
                Name                  *string                 `json:"name,omitempty"`
                Description           *string                 `json:"description,omitempty"`
                IsPublic              *bool                   `json:"is_public,omitempty"`
                RequiresApproval      *bool                   `json:"requires_approval,omitempty"`
                MaxMembers            *int                    `json:"max_members,omitempty"`
                ContributionAmount    *float64                `json:"contribution_amount,omitempty"`
                ContributionFrequency *string                 `json:"contribution_frequency,omitempty"`
                Rules                 *[]string               `json:"rules,omitempty"`
                MeetingSchedule       *map[string]interface{} `json:"meeting_schedule,omitempty"`
                Permissions           *map[string]bool        `json:"permissions,omitempty"`
                Notifications         *map[string]bool        `json:"notifications,omitempty"`
        }); ok </span><span class="cov0" title="0">{

                if updateMap.Name != nil </span><span class="cov0" title="0">{
                        setParts = append(setParts, "name = ?")
                        args = append(args, *updateMap.Name)
                }</span>

                <span class="cov0" title="0">if updateMap.Description != nil </span><span class="cov0" title="0">{
                        setParts = append(setParts, "description = ?")
                        args = append(args, *updateMap.Description)
                }</span>

                <span class="cov0" title="0">if updateMap.IsPublic != nil </span><span class="cov0" title="0">{
                        setParts = append(setParts, "is_public = ?")
                        args = append(args, *updateMap.IsPublic)
                }</span>

                <span class="cov0" title="0">if updateMap.RequiresApproval != nil </span><span class="cov0" title="0">{
                        setParts = append(setParts, "requires_approval = ?")
                        args = append(args, *updateMap.RequiresApproval)
                }</span>

                <span class="cov0" title="0">if updateMap.MaxMembers != nil </span><span class="cov0" title="0">{
                        setParts = append(setParts, "max_members = ?")
                        args = append(args, *updateMap.MaxMembers)
                }</span>

                <span class="cov0" title="0">if updateMap.ContributionAmount != nil </span><span class="cov0" title="0">{
                        setParts = append(setParts, "contribution_amount = ?")
                        args = append(args, *updateMap.ContributionAmount)
                }</span>

                <span class="cov0" title="0">if updateMap.ContributionFrequency != nil </span><span class="cov0" title="0">{
                        setParts = append(setParts, "contribution_frequency = ?")
                        args = append(args, *updateMap.ContributionFrequency)
                }</span>

                <span class="cov0" title="0">if updateMap.Rules != nil </span><span class="cov0" title="0">{
                        rulesJSON, err := json.Marshal(*updateMap.Rules)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to marshal rules: %w", err)
                        }</span>
                        <span class="cov0" title="0">setParts = append(setParts, "rules = ?")
                        args = append(args, string(rulesJSON))</span>
                }

                <span class="cov0" title="0">if updateMap.Permissions != nil </span><span class="cov0" title="0">{
                        permissionsJSON, err := json.Marshal(*updateMap.Permissions)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to marshal permissions: %w", err)
                        }</span>
                        <span class="cov0" title="0">setParts = append(setParts, "permissions = ?")
                        args = append(args, string(permissionsJSON))</span>
                }
        }

        <span class="cov0" title="0">if len(setParts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no fields to update")
        }</span>

        // Add updated_at timestamp
        <span class="cov0" title="0">setParts = append(setParts, "updated_at = ?")
        args = append(args, time.Now())

        // Add chama ID for WHERE clause
        args = append(args, chamaID)

        // Build and execute update query
        query := fmt.Sprintf("UPDATE chamas SET %s WHERE id = ?", strings.Join(setParts, ", "))

        _, err = tx.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update chama: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveUserFromChama removes a user from a chama (leave chama functionality)
func (s *ChamaService) RemoveUserFromChama(chamaID, userID string) error <span class="cov0" title="0">{
        // Start transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Check if user is a member
        var memberExists bool
        err = tx.QueryRow("SELECT EXISTS(SELECT 1 FROM chama_members WHERE chama_id = ? AND user_id = ? AND is_active = true)", chamaID, userID).Scan(&amp;memberExists)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check membership: %w", err)
        }</span>

        <span class="cov0" title="0">if !memberExists </span><span class="cov0" title="0">{
                return fmt.Errorf("user is not a member of this chama")
        }</span>

        // Mark member as inactive instead of deleting (for audit trail)
        <span class="cov0" title="0">_, err = tx.Exec("UPDATE chama_members SET is_active = false, updated_at = ? WHERE chama_id = ? AND user_id = ?", time.Now(), chamaID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove user from chama: %w", err)
        }</span>

        // Update chama member count
        <span class="cov0" title="0">_, err = tx.Exec("UPDATE chamas SET current_members = current_members - 1, updated_at = ? WHERE id = ?", time.Now(), chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update member count: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteChama deletes a chama and all related data (only for chairperson)
func (s *ChamaService) DeleteChama(chamaID string) error <span class="cov0" title="0">{
        // Start transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Check if chama exists
        var chamaExists bool
        err = tx.QueryRow("SELECT EXISTS(SELECT 1 FROM chamas WHERE id = ?)", chamaID).Scan(&amp;chamaExists)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check chama existence: %w", err)
        }</span>

        <span class="cov0" title="0">if !chamaExists </span><span class="cov0" title="0">{
                return fmt.Errorf("chama not found")
        }</span>

        // Delete related data in correct order (respecting foreign key constraints)

        // Delete meeting attendance
        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM meeting_attendance WHERE meeting_id IN (SELECT id FROM meetings WHERE chama_id = ?)", chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete meeting attendance: %w", err)
        }</span>

        // Delete meeting documents
        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM meeting_documents WHERE meeting_id IN (SELECT id FROM meetings WHERE chama_id = ?)", chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete meeting documents: %w", err)
        }</span>

        // Delete meetings
        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM meetings WHERE chama_id = ?", chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete meetings: %w", err)
        }</span>

        // Delete welfare contributions
        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM welfare_contributions WHERE chama_id = ?", chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete welfare contributions: %w", err)
        }</span>

        // Delete welfare requests
        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM welfare_requests WHERE chama_id = ?", chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete welfare requests: %w", err)
        }</span>

        // Delete loan guarantors
        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM loan_guarantors WHERE loan_id IN (SELECT id FROM loans WHERE chama_id = ?)", chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete loan guarantors: %w", err)
        }</span>

        // Delete loans
        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM loans WHERE chama_id = ?", chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete loans: %w", err)
        }</span>

        // Delete contributions
        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM contributions WHERE chama_id = ?", chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete contributions: %w", err)
        }</span>

        // Delete chama members
        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM chama_members WHERE chama_id = ?", chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete chama members: %w", err)
        }</span>

        // Finally, delete the chama itself
        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM chamas WHERE id = ?", chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete chama: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SendInvitation sends an invitation to join a chama with role information
func (s *ChamaService) SendInvitation(chamaID, inviterID, email, phoneNumber, message, role, roleName, roleDescription string) (string, error) <span class="cov0" title="0">{
        fmt.Printf("🔍 SendInvitation called with:\n")
        fmt.Printf("  - chamaID: %s\n", chamaID)
        fmt.Printf("  - inviterID: %s\n", inviterID)
        fmt.Printf("  - email: %s\n", email)
        fmt.Printf("  - phoneNumber: %s\n", phoneNumber)

        // Start transaction
        fmt.Printf("🔍 Starting database transaction...\n")
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Failed to start transaction: %v\n", err)
                return "", fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Check if user with email already exists and is already a member
        var existingUserID string
        err = tx.QueryRow("SELECT id FROM users WHERE email = ?", email).Scan(&amp;existingUserID)
        if err == nil </span><span class="cov0" title="0">{
                // User exists, check if already a member
                var memberExists bool
                err = tx.QueryRow("SELECT EXISTS(SELECT 1 FROM chama_members WHERE chama_id = ? AND user_id = ? AND is_active = true)", chamaID, existingUserID).Scan(&amp;memberExists)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to check existing membership: %w", err)
                }</span>
                <span class="cov0" title="0">if memberExists </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("user is already a member of this chama")
                }</span>
        }

        // Check if there's already a pending invitation for this email and chama
        <span class="cov0" title="0">var pendingInvitation bool
        err = tx.QueryRow("SELECT EXISTS(SELECT 1 FROM chama_invitations WHERE chama_id = ? AND email = ? AND status = 'pending')", chamaID, email).Scan(&amp;pendingInvitation)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to check pending invitations: %w", err)
        }</span>
        <span class="cov0" title="0">if pendingInvitation </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invitation already sent to this email")
        }</span>

        // Create invitation
        <span class="cov0" title="0">invitationID := uuid.New().String()
        invitationToken := uuid.New().String() // Token for accepting invitation

        _, err = tx.Exec(`
                INSERT INTO chama_invitations (
                        id, chama_id, inviter_id, email, phone_number, message,
                        role, role_name, role_description,
                        invitation_token, status, created_at, expires_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', ?, ?)
        `, invitationID, chamaID, inviterID, email, phoneNumber, message,
                role, roleName, roleDescription,
                invitationToken, time.Now(), time.Now().Add(7*24*time.Hour)) // Expires in 7 days
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create invitation: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        // Get chama and inviter details for the email
        <span class="cov0" title="0">var chamaName, inviterFirstName, inviterLastName string
        err = s.db.QueryRow(`
                SELECT c.name, u.first_name, u.last_name
                FROM chamas c, users u
                WHERE c.id = ? AND u.id = ?
        `, chamaID, inviterID).Scan(&amp;chamaName, &amp;inviterFirstName, &amp;inviterLastName)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Could not get chama/inviter details for email: %v\n", err)
                // Don't fail the invitation if email fails
                return invitationID, nil
        }</span>

        // Send email invitation
        <span class="cov0" title="0">fmt.Printf("🔍 Checking email invitation conditions:\n")
        fmt.Printf("  - Email service initialized: %t\n", s.emailService != nil)
        fmt.Printf("  - Email provided: '%s' (empty: %t)\n", email, email == "")
        fmt.Printf("  - Chama name: '%s'\n", chamaName)
        fmt.Printf("  - Inviter: '%s %s'\n", inviterFirstName, inviterLastName)

        if s.emailService != nil &amp;&amp; email != "" </span><span class="cov0" title="0">{
                fmt.Printf("📧 Attempting to send chama invitation email...\n")
                inviterFullName := fmt.Sprintf("%s %s", inviterFirstName, inviterLastName)
                err = s.emailService.SendChamaInvitationEmail(email, chamaName, inviterFullName, message, invitationToken)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Failed to send invitation email: %v\n", err)
                        // Don't fail the invitation if email fails
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Invitation email sent successfully to: %s\n", email)
                }</span>
        } else<span class="cov0" title="0"> {
                if s.emailService == nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Email service not initialized\n")
                }</span>
                <span class="cov0" title="0">if email == "" </span><span class="cov0" title="0">{
                        fmt.Printf("❌ No email address provided\n")
                }</span>
        }

        <span class="cov0" title="0">return invitationID, nil</span>
}

// RespondToInvitation handles accepting or rejecting an invitation
func (s *ChamaService) RespondToInvitation(invitationID, userID, response string) error <span class="cov0" title="0">{
        // Start transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Get invitation details
        var invitation struct {
                ChamaID   string
                Email     string
                Status    string
                ExpiresAt time.Time
        }

        err = tx.QueryRow(`
                SELECT chama_id, email, status, expires_at
                FROM chama_invitations
                WHERE id = ?
        `, invitationID).Scan(&amp;invitation.ChamaID, &amp;invitation.Email, &amp;invitation.Status, &amp;invitation.ExpiresAt)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("invitation not found")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get invitation: %w", err)</span>
        }

        // Check if invitation is still valid
        <span class="cov0" title="0">if invitation.Status != "pending" </span><span class="cov0" title="0">{
                return fmt.Errorf("invitation has already been %s", invitation.Status)
        }</span>

        <span class="cov0" title="0">if time.Now().After(invitation.ExpiresAt) </span><span class="cov0" title="0">{
                return fmt.Errorf("invitation has expired")
        }</span>

        // Verify that the user's email matches the invitation
        <span class="cov0" title="0">var userEmail string
        err = tx.QueryRow("SELECT email FROM users WHERE id = ?", userID).Scan(&amp;userEmail)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user email: %w", err)
        }</span>

        <span class="cov0" title="0">if userEmail != invitation.Email </span><span class="cov0" title="0">{
                return fmt.Errorf("invitation email does not match user email")
        }</span>

        // Update invitation status
        <span class="cov0" title="0">_, err = tx.Exec(`
                UPDATE chama_invitations
                SET status = ?, responded_at = ?, responded_by = ?
                WHERE id = ?
        `, response+"ed", time.Now(), userID, invitationID) // "accepted" or "rejected"
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update invitation: %w", err)
        }</span>

        // If accepted, add user to chama
        <span class="cov0" title="0">if response == "accept" </span><span class="cov0" title="0">{
                // Check if user is already a member (double-check)
                var memberExists bool
                err = tx.QueryRow("SELECT EXISTS(SELECT 1 FROM chama_members WHERE chama_id = ? AND user_id = ? AND is_active = true)", invitation.ChamaID, userID).Scan(&amp;memberExists)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check membership: %w", err)
                }</span>

                <span class="cov0" title="0">if !memberExists </span><span class="cov0" title="0">{
                        // Add user as member
                        memberID := uuid.New().String()
                        _, err = tx.Exec(`
                                INSERT INTO chama_members (
                                        id, chama_id, user_id, role, joined_at, is_active,
                                        total_contributions, rating, total_ratings
                                ) VALUES (?, ?, ?, 'member', ?, true, 0, 0, 0)
                        `, memberID, invitation.ChamaID, userID, time.Now())
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add user to chama: %w", err)
                        }</span>

                        // Update chama member count
                        <span class="cov0" title="0">_, err = tx.Exec("UPDATE chamas SET current_members = current_members + 1, updated_at = ? WHERE id = ?", time.Now(), invitation.ChamaID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update member count: %w", err)
                        }</span>
                }
        }

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetUserInvitations gets pending invitations for a user
func (s *ChamaService) GetUserInvitations(userID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Get user's email
        var userEmail string
        err := s.db.QueryRow("SELECT email FROM users WHERE id = ?", userID).Scan(&amp;userEmail)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user email: %w", err)
        }</span>

        // Get pending invitations for this email
        <span class="cov0" title="0">query := `
                SELECT
                        ci.id, ci.chama_id, ci.inviter_id, ci.email, ci.phone_number,
                        ci.message, ci.created_at, ci.expires_at,
                        c.name as chama_name, c.description as chama_description,
                        c.contribution_amount, c.contribution_frequency,
                        u.first_name as inviter_first_name, u.last_name as inviter_last_name
                FROM chama_invitations ci
                INNER JOIN chamas c ON ci.chama_id = c.id
                INNER JOIN users u ON ci.inviter_id = u.id
                WHERE ci.email = ? AND ci.status = 'pending' AND ci.expires_at &gt; ?
                ORDER BY ci.created_at DESC
        `

        rows, err := s.db.Query(query, userEmail, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get invitations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var invitations []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        id, chamaID, inviterID, email, chamaName, chamaDescription string
                        contributionFrequency, inviterFirstName, inviterLastName   string
                        createdAt, expiresAt                                       string
                        phoneNumber, message                                       *string
                        contributionAmount                                         float64
                )

                err := rows.Scan(
                        &amp;id, &amp;chamaID, &amp;inviterID, &amp;email, &amp;phoneNumber,
                        &amp;message, &amp;createdAt, &amp;expiresAt,
                        &amp;chamaName, &amp;chamaDescription, &amp;contributionAmount, &amp;contributionFrequency,
                        &amp;inviterFirstName, &amp;inviterLastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid rows
                }

                <span class="cov0" title="0">invitation := map[string]interface{}{
                        "id":         id,
                        "chama_id":   chamaID,
                        "inviter_id": inviterID,
                        "email":      email,
                        "phone":      phoneNumber,
                        "message":    message,
                        "created_at": createdAt,
                        "expires_at": expiresAt,
                        "chama": map[string]interface{}{
                                "id":                     chamaID,
                                "name":                   chamaName,
                                "description":            chamaDescription,
                                "contribution_amount":    contributionAmount,
                                "contribution_frequency": contributionFrequency,
                        },
                        "inviter": map[string]interface{}{
                                "id":         inviterID,
                                "first_name": inviterFirstName,
                                "last_name":  inviterLastName,
                        },
                }

                invitations = append(invitations, invitation)</span>
        }

        <span class="cov0" title="0">return invitations, nil</span>
}

// GetChamaSentInvitations gets all invitations sent for a specific chama
func (s *ChamaService) GetChamaSentInvitations(chamaID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        ci.id, ci.chama_id, ci.inviter_id, ci.email, ci.phone_number,
                        ci.message, ci.role, ci.role_name, ci.role_description,
                        ci.status, ci.created_at, ci.expires_at, ci.responded_at,
                        u.first_name as inviter_first_name, u.last_name as inviter_last_name
                FROM chama_invitations ci
                INNER JOIN users u ON ci.inviter_id = u.id
                WHERE ci.chama_id = ?
                ORDER BY ci.created_at DESC
        `

        rows, err := s.db.Query(query, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sent invitations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var invitations []map[string]interface{}

        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        id, chamaID, inviterID, email                         string
                        phoneNumber, message, role, roleName, roleDescription sql.NullString
                        status                                                string
                        createdAt, expiresAt                                  time.Time
                        respondedAt                                           sql.NullTime
                        inviterFirstName, inviterLastName                     string
                )

                err := rows.Scan(
                        &amp;id, &amp;chamaID, &amp;inviterID, &amp;email, &amp;phoneNumber,
                        &amp;message, &amp;role, &amp;roleName, &amp;roleDescription,
                        &amp;status, &amp;createdAt, &amp;expiresAt, &amp;respondedAt,
                        &amp;inviterFirstName, &amp;inviterLastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan invitation: %w", err)
                }</span>

                <span class="cov0" title="0">invitation := map[string]interface{}{
                        "id":               id,
                        "chama_id":         chamaID,
                        "inviter_id":       inviterID,
                        "email":            email,
                        "phone":            phoneNumber.String,
                        "message":          message.String,
                        "role":             role.String,
                        "role_name":        roleName.String,
                        "role_description": roleDescription.String,
                        "status":           status,
                        "created_at":       createdAt,
                        "expires_at":       expiresAt,
                        "inviter": map[string]interface{}{
                                "id":         inviterID,
                                "first_name": inviterFirstName,
                                "last_name":  inviterLastName,
                        },
                }

                if respondedAt.Valid </span><span class="cov0" title="0">{
                        invitation["responded_at"] = respondedAt.Time
                }</span>

                <span class="cov0" title="0">invitations = append(invitations, invitation)</span>
        }

        <span class="cov0" title="0">return invitations, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package services

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/utils"
)

// ChatService handles chat and messaging functionality
type ChatService struct {
        db *sql.DB
}

// NewChatService creates a new chat service
func NewChatService(db *sql.DB) *ChatService <span class="cov0" title="0">{
        return &amp;ChatService{db: db}
}</span>

// ChatRoomType represents the type of chat room
type ChatRoomType string

const (
        ChatRoomTypePrivate ChatRoomType = "private"
        ChatRoomTypeChama   ChatRoomType = "chama"
        ChatRoomTypeGroup   ChatRoomType = "group"
)

// MessageType represents the type of message
type MessageType string

const (
        MessageTypeText     MessageType = "text"
        MessageTypeImage    MessageType = "image"
        MessageTypeFile     MessageType = "file"
        MessageTypeLocation MessageType = "location"
        MessageTypeSystem   MessageType = "system"
)

// ChatRoom represents a chat room
type ChatRoom struct {
        ID            string       `json:"id" db:"id"`
        Name          *string      `json:"name,omitempty" db:"name"`
        Type          ChatRoomType `json:"type" db:"type"`
        ChamaID       *string      `json:"chamaId,omitempty" db:"chama_id"`
        CreatedBy     string       `json:"createdBy" db:"created_by"`
        IsActive      bool         `json:"isActive" db:"is_active"`
        LastMessage   *string      `json:"lastMessage,omitempty" db:"last_message"`
        LastMessageAt *time.Time   `json:"lastMessageAt,omitempty" db:"last_message_at"`
        CreatedAt     time.Time    `json:"createdAt" db:"created_at"`
        UpdatedAt     time.Time    `json:"updatedAt" db:"updated_at"`
}

// ChatMessage represents a chat message
type ChatMessage struct {
        ID        string      `json:"id" db:"id"`
        RoomID    string      `json:"roomId" db:"room_id"`
        SenderID  string      `json:"senderId" db:"sender_id"`
        Type      MessageType `json:"type" db:"type"`
        Content   string      `json:"content" db:"content"`
        Metadata  string      `json:"metadata" db:"metadata"`
        FileURL   *string     `json:"fileUrl,omitempty" db:"file_url"`
        IsEdited  bool        `json:"isEdited" db:"is_edited"`
        IsDeleted bool        `json:"isDeleted" db:"is_deleted"`
        ReplyToID *string     `json:"replyToId,omitempty" db:"reply_to_id"`
        CreatedAt time.Time   `json:"createdAt" db:"created_at"`
        UpdatedAt time.Time   `json:"updatedAt" db:"updated_at"`

        // Joined data
        Sender  *models.User `json:"sender,omitempty"`
        ReplyTo *ChatMessage `json:"replyTo,omitempty"`
}

// ChatRoomMember represents a member of a chat room
type ChatRoomMember struct {
        ID         string     `json:"id" db:"id"`
        RoomID     string     `json:"roomId" db:"room_id"`
        UserID     string     `json:"userId" db:"user_id"`
        Role       string     `json:"role" db:"role"`
        JoinedAt   time.Time  `json:"joinedAt" db:"joined_at"`
        LastReadAt *time.Time `json:"lastReadAt,omitempty" db:"last_read_at"`
        IsActive   bool       `json:"isActive" db:"is_active"`
        IsMuted    bool       `json:"isMuted" db:"is_muted"`

        // Joined data
        User *models.User `json:"user,omitempty"`
}

// CreatePrivateChat creates a private chat between two users
func (s *ChatService) CreatePrivateChat(user1ID, user2ID string) (*ChatRoom, error) <span class="cov0" title="0">{
        fmt.Printf("🔍 CreatePrivateChat called with user1ID: %s, user2ID: %s\n", user1ID, user2ID)

        // Prevent users from creating chats with themselves
        if user1ID == user2ID </span><span class="cov0" title="0">{
                fmt.Printf("❌ Cannot create private chat with yourself: %s\n", user1ID)
                return nil, fmt.Errorf("cannot create private chat with yourself")
        }</span>

        // Check if private chat already exists
        <span class="cov0" title="0">fmt.Printf("🔍 Checking for existing private chat room...\n")
        existingRoom, err := s.getPrivateChatRoom(user1ID, user2ID)
        if err == nil </span><span class="cov0" title="0">{
                fmt.Printf("✅ Found existing private chat room: %s\n", existingRoom.ID)
                return existingRoom, nil
        }</span>
        <span class="cov0" title="0">fmt.Printf("🔍 No existing room found, creating new one. Error: %v\n", err)

        // Create new private chat room
        room := &amp;ChatRoom{
                ID:        uuid.New().String(),
                Type:      ChatRoomTypePrivate,
                CreatedBy: user1ID,
                IsActive:  true,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        // Start transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Insert chat room
        roomQuery := `
                INSERT INTO chat_rooms (id, name, type, chama_id, created_by, is_active, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `
        // For private chats, name and chama_id should be NULL
        var nameValue, chamaIDValue interface{}
        if room.Name != nil </span><span class="cov0" title="0">{
                nameValue = *room.Name
        }</span> else<span class="cov0" title="0"> {
                nameValue = nil
        }</span>
        <span class="cov0" title="0">if room.ChamaID != nil </span><span class="cov0" title="0">{
                chamaIDValue = *room.ChamaID
        }</span> else<span class="cov0" title="0"> {
                chamaIDValue = nil
        }</span>

        <span class="cov0" title="0">_, err = tx.Exec(roomQuery, room.ID, nameValue, room.Type, chamaIDValue, room.CreatedBy, room.IsActive, room.CreatedAt, room.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create chat room: %w", err)
        }</span>

        // Add both users as members
        <span class="cov0" title="0">members := []string{user1ID, user2ID}
        for _, userID := range members </span><span class="cov0" title="0">{
                member := &amp;ChatRoomMember{
                        ID:       uuid.New().String(),
                        RoomID:   room.ID,
                        UserID:   userID,
                        Role:     "member",
                        JoinedAt: time.Now(),
                        IsActive: true,
                        IsMuted:  false,
                }

                memberQuery := `
                        INSERT INTO chat_room_members (id, room_id, user_id, role, joined_at, is_active, is_muted)
                        VALUES (?, ?, ?, ?, ?, ?, ?)
                `
                _, err = tx.Exec(memberQuery, member.ID, member.RoomID, member.UserID, member.Role, member.JoinedAt, member.IsActive, member.IsMuted)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add room member: %w", err)
                }</span>
        }

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return room, nil</span>
}

// CreateSupportChat creates a support chat between admin and user (allows same user)
func (s *ChatService) CreateSupportChat(adminID, userID string, context map[string]interface{}) (*ChatRoom, error) <span class="cov0" title="0">{
        fmt.Printf("🔍 CreateSupportChat called with adminID: %s, userID: %s\n", adminID, userID)

        // For support chats, we allow admin to chat with any user, including themselves for testing
        // Check if support chat already exists for this context
        var existingRoomID string
        if context != nil </span><span class="cov0" title="0">{
                if supportRequestID, ok := context["supportRequestId"].(string); ok </span><span class="cov0" title="0">{
                        // Look for existing support chat for this support request
                        query := `
                                SELECT cr.id FROM chat_rooms cr
                                WHERE cr.type = 'support'
                                AND cr.context LIKE '%"supportRequestId":"' || ? || '"%'
                                AND cr.is_active = true
                                LIMIT 1
                        `
                        err := s.db.QueryRow(query, supportRequestID).Scan(&amp;existingRoomID)
                        if err == nil </span><span class="cov0" title="0">{
                                fmt.Printf("✅ Found existing support chat room: %s\n", existingRoomID)
                                // Get the full room details
                                return s.getChatRoomByID(existingRoomID)
                        }</span>
                }
        }

        // Create new support chat room
        <span class="cov0" title="0">room := &amp;ChatRoom{
                ID:        uuid.New().String(),
                Type:      "support", // Use support type
                CreatedBy: adminID,
                IsActive:  true,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        // Serialize context
        var contextJSON string
        if context != nil </span><span class="cov0" title="0">{
                contextBytes, err := json.Marshal(context)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to serialize context: %w", err)
                }</span>
                <span class="cov0" title="0">contextJSON = string(contextBytes)</span>
        } else<span class="cov0" title="0"> {
                contextJSON = "{}"
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Insert chat room with context
        roomQuery := `
                INSERT INTO chat_rooms (id, name, type, chama_id, created_by, is_active, created_at, updated_at, context)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = tx.Exec(roomQuery, room.ID, nil, room.Type, nil, room.CreatedBy, room.IsActive, room.CreatedAt, room.UpdatedAt, contextJSON)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create support chat room: %w", err)
        }</span>

        // Add both admin and user as members (even if they're the same person for testing)
        <span class="cov0" title="0">members := []string{adminID}
        if userID != adminID </span><span class="cov0" title="0">{
                members = append(members, userID)
        }</span>

        <span class="cov0" title="0">for _, memberID := range members </span><span class="cov0" title="0">{
                member := &amp;ChatRoomMember{
                        ID:       uuid.New().String(),
                        RoomID:   room.ID,
                        UserID:   memberID,
                        Role:     "member",
                        JoinedAt: time.Now(),
                        IsActive: true,
                        IsMuted:  false,
                }

                memberQuery := `
                        INSERT INTO chat_room_members (id, room_id, user_id, role, joined_at, is_active, is_muted)
                        VALUES (?, ?, ?, ?, ?, ?, ?)
                `
                _, err = tx.Exec(memberQuery, member.ID, member.RoomID, member.UserID, member.Role, member.JoinedAt, member.IsActive, member.IsMuted)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add room member: %w", err)
                }</span>
        }

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Support chat created successfully: %s\n", room.ID)
        return room, nil</span>
}

// CreateChamaChat creates a chat room for a chama or returns existing one
func (s *ChatService) CreateChamaChat(chamaID, createdBy string) (*ChatRoom, error) <span class="cov0" title="0">{
        // Check if chama chat room already exists
        existingRoom, err := s.getChamaChatRoom(chamaID)
        if err == nil </span><span class="cov0" title="0">{
                return existingRoom, nil
        }</span>

        // Get chama details
        <span class="cov0" title="0">var chamaName string
        chamaQuery := "SELECT name FROM chamas WHERE id = ?"
        err = s.db.QueryRow(chamaQuery, chamaID).Scan(&amp;chamaName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get chama: %w", err)
        }</span>

        <span class="cov0" title="0">room := &amp;ChatRoom{
                ID:        uuid.New().String(),
                Name:      &amp;chamaName,
                Type:      ChatRoomTypeChama,
                ChamaID:   &amp;chamaID,
                CreatedBy: createdBy,
                IsActive:  true,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        // Start transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Insert chat room
        roomQuery := `
                INSERT INTO chat_rooms (id, name, type, chama_id, created_by, is_active, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `
        // For chama chats, both name and chama_id should have values
        var nameValue, chamaIDValue interface{}
        if room.Name != nil </span><span class="cov0" title="0">{
                nameValue = *room.Name
        }</span> else<span class="cov0" title="0"> {
                nameValue = nil
        }</span>
        <span class="cov0" title="0">if room.ChamaID != nil </span><span class="cov0" title="0">{
                chamaIDValue = *room.ChamaID
        }</span> else<span class="cov0" title="0"> {
                chamaIDValue = nil
        }</span>

        <span class="cov0" title="0">_, err = tx.Exec(roomQuery, room.ID, nameValue, room.Type, chamaIDValue, room.CreatedBy, room.IsActive, room.CreatedAt, room.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create chat room: %w", err)
        }</span>

        // Add all chama members to the chat
        <span class="cov0" title="0">membersQuery := "SELECT user_id FROM chama_members WHERE chama_id = ? AND is_active = true"
        rows, err := tx.Query(membersQuery, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get chama members: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var userID string
                if err := rows.Scan(&amp;userID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan member: %w", err)
                }</span>

                <span class="cov0" title="0">member := &amp;ChatRoomMember{
                        ID:       uuid.New().String(),
                        RoomID:   room.ID,
                        UserID:   userID,
                        Role:     "member",
                        JoinedAt: time.Now(),
                        IsActive: true,
                        IsMuted:  false,
                }

                memberQuery := `
                        INSERT INTO chat_room_members (id, room_id, user_id, role, joined_at, is_active, is_muted)
                        VALUES (?, ?, ?, ?, ?, ?, ?)
                `
                _, err = tx.Exec(memberQuery, member.ID, member.RoomID, member.UserID, member.Role, member.JoinedAt, member.IsActive, member.IsMuted)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add room member: %w", err)
                }</span>
        }

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return room, nil</span>
}

// SendMessage sends a message to a chat room
func (s *ChatService) SendMessage(roomID, senderID string, messageType MessageType, content string, metadata map[string]interface{}, replyToID *string) (*ChatMessage, error) <span class="cov0" title="0">{
        // Check if user is a member of the room
        isMember, err := s.isRoomMember(roomID, senderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user is not a member of this chat room")
        }</span>

        // Serialize metadata
        <span class="cov0" title="0">metadataJSON := "{}"
        if metadata != nil </span><span class="cov0" title="0">{
                metadataBytes, err := utils.JSONMarshal(metadata)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to serialize metadata: %w", err)
                }</span>
                <span class="cov0" title="0">metadataJSON = string(metadataBytes)</span>
        }

        <span class="cov0" title="0">message := &amp;ChatMessage{
                ID:        uuid.New().String(),
                RoomID:    roomID,
                SenderID:  senderID,
                Type:      messageType,
                Content:   content,
                Metadata:  metadataJSON,
                IsEdited:  false,
                IsDeleted: false,
                ReplyToID: replyToID,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        // Start transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Extract file URL from metadata if present
        var fileURL *string
        if metadata != nil </span><span class="cov0" title="0">{
                if url, exists := metadata["fileUrl"]; exists </span><span class="cov0" title="0">{
                        if urlStr, ok := url.(string); ok </span><span class="cov0" title="0">{
                                fileURL = &amp;urlStr
                        }</span>
                }
        }

        // Insert message (populate both message and content fields for compatibility)
        <span class="cov0" title="0">messageQuery := `
                INSERT INTO chat_messages (
                        id, room_id, sender_id, message, type, content, metadata, file_url, is_edited, is_deleted, reply_to_id, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `
        _, err = tx.Exec(messageQuery,
                message.ID, message.RoomID, message.SenderID, message.Content, message.Type, message.Content,
                message.Metadata, fileURL, message.IsEdited, message.IsDeleted, message.ReplyToID,
                message.CreatedAt, message.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send message: %w", err)
        }</span>

        // Update room's last message
        <span class="cov0" title="0">updateRoomQuery := `
                UPDATE chat_rooms
                SET last_message = ?, last_message_at = ?, updated_at = ?
                WHERE id = ?
        `
        _, err = tx.Exec(updateRoomQuery, content, message.CreatedAt, message.UpdatedAt, roomID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update room: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return message, nil</span>
}

// GetRoomMessages retrieves messages for a chat room
func (s *ChatService) GetRoomMessages(roomID, userID string, limit, offset int) ([]*ChatMessage, error) <span class="cov0" title="0">{
        // Check if user is a member of the room
        isMember, err := s.isRoomMember(roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user is not a member of this chat room")
        }</span>

        <span class="cov0" title="0">query := `
                SELECT m.id, m.room_id, m.sender_id, m.type, m.content, m.metadata, m.file_url,
                           m.is_edited, m.is_deleted, m.reply_to_id, m.created_at, m.updated_at,
                           u.first_name, u.last_name, u.avatar
                FROM chat_messages m
                INNER JOIN users u ON m.sender_id = u.id
                WHERE m.room_id = ? AND m.is_deleted = false
                ORDER BY m.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, roomID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get messages: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var messages []*ChatMessage
        for rows.Next() </span><span class="cov0" title="0">{
                message := &amp;ChatMessage{}
                sender := &amp;models.User{}

                err := rows.Scan(
                        &amp;message.ID, &amp;message.RoomID, &amp;message.SenderID, &amp;message.Type,
                        &amp;message.Content, &amp;message.Metadata, &amp;message.FileURL, &amp;message.IsEdited, &amp;message.IsDeleted,
                        &amp;message.ReplyToID, &amp;message.CreatedAt, &amp;message.UpdatedAt,
                        &amp;sender.FirstName, &amp;sender.LastName, &amp;sender.Avatar,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan message: %w", err)
                }</span>

                <span class="cov0" title="0">sender.ID = message.SenderID
                message.Sender = sender
                messages = append(messages, message)</span>
        }

        // Reverse to get chronological order
        <span class="cov0" title="0">for i, j := 0, len(messages)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                messages[i], messages[j] = messages[j], messages[i]
        }</span>

        <span class="cov0" title="0">return messages, nil</span>
}

// ChatRoomWithParticipants extends ChatRoom with participant information
type ChatRoomWithParticipants struct {
        *ChatRoom
        Participants    []*models.User `json:"participants,omitempty"`
        OtherUserName   *string        `json:"otherUserName,omitempty"`
        OtherUserAvatar *string        `json:"otherUserAvatar,omitempty"`
        OtherUserID     *string        `json:"otherUserId,omitempty"`
        MessageCount    int            `json:"messageCount"`
        UnreadCount     int            `json:"unreadCount"`
        MemberCount     int            `json:"memberCount"`
}

// GetUserChatRooms retrieves chat rooms for a user with participant information
func (s *ChatService) GetUserChatRooms(userID string) ([]*ChatRoomWithParticipants, error) <span class="cov0" title="0">{
        query := `
                SELECT r.id, r.name, r.type, r.chama_id, r.created_by, r.is_active,
                           r.last_message, r.last_message_at, r.created_at, r.updated_at
                FROM chat_rooms r
                INNER JOIN chat_room_members m ON r.id = m.room_id
                WHERE m.user_id = ? AND m.is_active = true AND r.is_active = true
                ORDER BY r.last_message_at DESC, r.created_at DESC
        `

        rows, err := s.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get chat rooms: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var rooms []*ChatRoomWithParticipants
        for rows.Next() </span><span class="cov0" title="0">{
                room := &amp;ChatRoom{}
                err := rows.Scan(
                        &amp;room.ID, &amp;room.Name, &amp;room.Type, &amp;room.ChamaID, &amp;room.CreatedBy,
                        &amp;room.IsActive, &amp;room.LastMessage, &amp;room.LastMessageAt,
                        &amp;room.CreatedAt, &amp;room.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan chat room: %w", err)
                }</span>

                // Create extended room with participant info
                <span class="cov0" title="0">extendedRoom := &amp;ChatRoomWithParticipants{
                        ChatRoom: room,
                }

                // Get participants for this room
                participants, err := s.getRoomParticipants(room.ID)
                if err != nil </span>{<span class="cov0" title="0">
                        // Log error but continue
                        // fmt.Printf("Warning: failed to get participants for room %s: %v\n", room.ID, err)
                }</span> else<span class="cov0" title="0"> {
                        extendedRoom.Participants = participants
                        extendedRoom.MemberCount = len(participants)

                        // For private chats, set the other user's information
                        if room.Type == ChatRoomTypePrivate &amp;&amp; len(participants) &gt;= 2 </span><span class="cov0" title="0">{
                                for _, participant := range participants </span><span class="cov0" title="0">{
                                        if participant.ID != userID </span><span class="cov0" title="0">{
                                                otherUserName := participant.FirstName + " " + participant.LastName
                                                extendedRoom.OtherUserName = &amp;otherUserName
                                                extendedRoom.OtherUserID = &amp;participant.ID

                                                // Set avatar if available
                                                if participant.Avatar != nil &amp;&amp; *participant.Avatar != "" </span><span class="cov0" title="0">{
                                                        extendedRoom.OtherUserAvatar = participant.Avatar
                                                        // fmt.Printf("✅ Setting avatar for private chat %s: %s\n", room.ID, *participant.Avatar)
                                                }</span> else <span class="cov0" title="0">{
                                                        // fmt.Printf("⚠️ No avatar found for user %s in private chat %s\n", participant.ID, room.ID)
                                                }</span>
                                                <span class="cov0" title="0">break</span>
                                        }
                                }
                        }
                }

                // Get message count
                <span class="cov0" title="0">messageCount, err := s.getRoomMessageCount(room.ID)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to get message count for room %s: %v\n", room.ID, err)
                }</span> else<span class="cov0" title="0"> {
                        extendedRoom.MessageCount = messageCount
                }</span>

                // Get unread count
                <span class="cov0" title="0">unreadCount, err := s.getRoomUnreadCount(room.ID, userID)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to get unread count for room %s: %v\n", room.ID, err)
                }</span> else<span class="cov0" title="0"> {
                        extendedRoom.UnreadCount = unreadCount
                }</span>

                <span class="cov0" title="0">rooms = append(rooms, extendedRoom)</span>
        }

        <span class="cov0" title="0">return rooms, nil</span>
}

// getRoomParticipants gets all participants for a room
func (s *ChatService) getRoomParticipants(roomID string) ([]*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT u.id, u.first_name, u.last_name, u.email, u.avatar, u.phone
                FROM users u
                INNER JOIN chat_room_members m ON u.id = m.user_id
                WHERE m.room_id = ? AND m.is_active = true
                ORDER BY u.first_name, u.last_name
        `

        rows, err := s.db.Query(query, roomID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get room participants: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var participants []*models.User
        for rows.Next() </span><span class="cov0" title="0">{
                user := &amp;models.User{}
                err := rows.Scan(
                        &amp;user.ID, &amp;user.FirstName, &amp;user.LastName,
                        &amp;user.Email, &amp;user.Avatar, &amp;user.Phone,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan participant: %w", err)
                }</span>
                <span class="cov0" title="0">participants = append(participants, user)</span>
        }

        <span class="cov0" title="0">return participants, nil</span>
}

// getRoomMessageCount gets the total message count for a room
func (s *ChatService) getRoomMessageCount(roomID string) (int, error) <span class="cov0" title="0">{
        var count int
        query := `SELECT COUNT(*) FROM chat_messages WHERE room_id = ? AND is_deleted = false`
        err := s.db.QueryRow(query, roomID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get message count: %w", err)
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

// getRoomUnreadCount gets the unread message count for a user in a room
func (s *ChatService) getRoomUnreadCount(roomID, userID string) (int, error) <span class="cov0" title="0">{
        var count int
        query := `
                SELECT COUNT(*)
                FROM chat_messages m
                LEFT JOIN chat_room_members rm ON rm.room_id = m.room_id AND rm.user_id = ?
                WHERE m.room_id = ? AND m.is_deleted = false
                AND m.sender_id != ?
                AND (rm.last_read_at IS NULL OR m.created_at &gt; rm.last_read_at)
        `
        err := s.db.QueryRow(query, userID, roomID, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get unread count: %w", err)
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

// MarkMessagesAsRead marks messages as read for a user
func (s *ChatService) MarkMessagesAsRead(roomID, userID string) error <span class="cov0" title="0">{
        now := time.Now()
        query := `
                UPDATE chat_room_members
                SET last_read_at = ?
                WHERE room_id = ? AND user_id = ?
        `

        _, err := s.db.Exec(query, now, roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark messages as read: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper methods

func (s *ChatService) getPrivateChatRoom(user1ID, user2ID string) (*ChatRoom, error) <span class="cov0" title="0">{
        query := `
                SELECT r.id, r.name, r.type, r.chama_id, r.created_by, r.is_active,
                           r.last_message, r.last_message_at, r.created_at, r.updated_at
                FROM chat_rooms r
                WHERE r.type = ? AND r.id IN (
                        SELECT m1.room_id FROM chat_room_members m1
                        INNER JOIN chat_room_members m2 ON m1.room_id = m2.room_id
                        WHERE m1.user_id = ? AND m2.user_id = ? AND m1.is_active = true AND m2.is_active = true
                )
        `

        room := &amp;ChatRoom{}
        err := s.db.QueryRow(query, ChatRoomTypePrivate, user1ID, user2ID).Scan(
                &amp;room.ID, &amp;room.Name, &amp;room.Type, &amp;room.ChamaID, &amp;room.CreatedBy,
                &amp;room.IsActive, &amp;room.LastMessage, &amp;room.LastMessageAt,
                &amp;room.CreatedAt, &amp;room.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return room, nil</span>
}

func (s *ChatService) getChatRoomByID(roomID string) (*ChatRoom, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, type, chama_id, created_by, is_active,
                           last_message, last_message_at, created_at, updated_at
                FROM chat_rooms
                WHERE id = ? AND is_active = true
        `

        room := &amp;ChatRoom{}
        err := s.db.QueryRow(query, roomID).Scan(
                &amp;room.ID, &amp;room.Name, &amp;room.Type, &amp;room.ChamaID, &amp;room.CreatedBy,
                &amp;room.IsActive, &amp;room.LastMessage, &amp;room.LastMessageAt,
                &amp;room.CreatedAt, &amp;room.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return room, nil</span>
}

func (s *ChatService) isRoomMember(roomID, userID string) (bool, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM chat_room_members WHERE room_id = ? AND user_id = ? AND is_active = true"
        var count int
        err := s.db.QueryRow(query, roomID, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check room membership: %w", err)
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (s *ChatService) getChamaChatRoom(chamaID string) (*ChatRoom, error) <span class="cov0" title="0">{
        query := `
                SELECT r.id, r.name, r.type, r.chama_id, r.created_by, r.is_active,
                           r.last_message, r.last_message_at, r.created_at, r.updated_at
                FROM chat_rooms r
                WHERE r.type = ? AND r.chama_id = ? AND r.is_active = true
        `

        room := &amp;ChatRoom{}
        err := s.db.QueryRow(query, ChatRoomTypeChama, chamaID).Scan(
                &amp;room.ID, &amp;room.Name, &amp;room.Type, &amp;room.ChamaID, &amp;room.CreatedBy,
                &amp;room.IsActive, &amp;room.LastMessage, &amp;room.LastMessageAt,
                &amp;room.CreatedAt, &amp;room.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return room, nil</span>
}

// AddUserToChamaChat adds a user to an existing chama chat room
func (s *ChatService) AddUserToChamaChat(chamaID, userID string) error <span class="cov0" title="0">{
        // Get chama chat room
        room, err := s.getChamaChatRoom(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                // If no chat room exists, that's okay - it will be created when needed
                return nil
        }</span>

        // Check if user is already a member
        <span class="cov0" title="0">isMember, err := s.isRoomMember(room.ID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check room membership: %w", err)
        }</span>
        <span class="cov0" title="0">if isMember </span><span class="cov0" title="0">{
                return nil // User is already a member
        }</span>

        // Add user to chat room
        <span class="cov0" title="0">member := &amp;ChatRoomMember{
                ID:       uuid.New().String(),
                RoomID:   room.ID,
                UserID:   userID,
                Role:     "member",
                JoinedAt: time.Now(),
                IsActive: true,
                IsMuted:  false,
        }

        memberQuery := `
                INSERT INTO chat_room_members (id, room_id, user_id, role, joined_at, is_active, is_muted)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `
        _, err = s.db.Exec(memberQuery, member.ID, member.RoomID, member.UserID, member.Role, member.JoinedAt, member.IsActive, member.IsMuted)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add user to chat room: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetRoomMembers retrieves members of a chat room
func (s *ChatService) GetRoomMembers(roomID, userID string) ([]*ChatRoomMember, error) <span class="cov0" title="0">{
        // First check if user is a member of the room
        isMember, err := s.isRoomMember(roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user is not a member of this chat room")
        }</span>

        <span class="cov0" title="0">query := `
                SELECT m.id, m.room_id, m.user_id, m.role, m.joined_at, m.last_read_at, m.is_active, m.is_muted,
                           u.first_name, u.last_name, u.email, u.avatar
                FROM chat_room_members m
                INNER JOIN users u ON m.user_id = u.id
                WHERE m.room_id = ? AND m.is_active = true
                ORDER BY m.joined_at ASC
        `

        rows, err := s.db.Query(query, roomID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get room members: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var members []*ChatRoomMember
        for rows.Next() </span><span class="cov0" title="0">{
                member := &amp;ChatRoomMember{}
                user := &amp;models.User{}

                err := rows.Scan(
                        &amp;member.ID, &amp;member.RoomID, &amp;member.UserID, &amp;member.Role,
                        &amp;member.JoinedAt, &amp;member.LastReadAt, &amp;member.IsActive, &amp;member.IsMuted,
                        &amp;user.FirstName, &amp;user.LastName, &amp;user.Email, &amp;user.Avatar,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan room member: %w", err)
                }</span>

                <span class="cov0" title="0">member.User = user
                members = append(members, member)</span>
        }

        <span class="cov0" title="0">return members, nil</span>
}

// DeleteChatRoom removes a user from a chat room (soft delete for private chats)
func (s *ChatService) DeleteChatRoom(roomID, userID string) error <span class="cov0" title="0">{
        // Check if user is a member of the room
        isMember, err := s.isRoomMember(roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                return fmt.Errorf("user is not a member of this chat room")
        }</span>

        // For private chats, we'll deactivate the membership
        // For group chats, we'll remove the user from the room
        <span class="cov0" title="0">query := `
                UPDATE chat_room_members
                SET is_active = false
                WHERE room_id = ? AND user_id = ?
        `

        _, err = s.db.Exec(query, roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete chat room: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ClearChatRoom marks all messages as deleted for a user (soft delete)
func (s *ChatService) ClearChatRoom(roomID, userID string) error <span class="cov0" title="0">{
        // Check if user is a member of the room
        isMember, err := s.isRoomMember(roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                return fmt.Errorf("user is not a member of this chat room")
        }</span>

        // We'll implement this as updating the user's last_read_at to current time
        // and add a flag to indicate messages before this time should be hidden
        // For now, we'll just update the last_read_at
        <span class="cov0" title="0">now := time.Now()
        query := `
                UPDATE chat_room_members
                SET last_read_at = ?
                WHERE room_id = ? AND user_id = ?
        `

        _, err = s.db.Exec(query, now, roomID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear chat room: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package services

import (
        "os"
)

// LiveKitConfig holds LiveKit configuration
type LiveKitConfig struct {
        WSURL     string
        APIKey    string
        APISecret string
}

// GetLiveKitConfig returns LiveKit configuration from environment variables
func GetLiveKitConfig() *LiveKitConfig <span class="cov0" title="0">{
        return &amp;LiveKitConfig{
                WSURL:     getEnvOrDefault("LIVEKIT_WS_URL", "ws://localhost:7880"),
                APIKey:    getEnvOrDefault("LIVEKIT_API_KEY", ""),
                APISecret: getEnvOrDefault("LIVEKIT_API_SECRET", ""),
        }
}</span>

func getEnvOrDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package services

import (
        "database/sql"
        "fmt"
        "log"
        "time"

        "vaultke-backend/internal/models"

        "github.com/google/uuid"
)

// DividendsService handles dividend-related business logic
type DividendsService struct {
        db *sql.DB
}

// NewDividendsService creates a new dividends service
func NewDividendsService(db *sql.DB) *DividendsService <span class="cov0" title="0">{
        return &amp;DividendsService{db: db}
}</span>

// DeclareDividend creates a new dividend declaration
func (s *DividendsService) DeclareDividend(chamaID, declaredBy string, req *models.CreateDividendDeclarationRequest) (*models.DividendDeclaration, error) <span class="cov0" title="0">{
        // Validate that the user has permission to declare dividends (should be chama official)
        if !s.canDeclareDividends(declaredBy, chamaID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user does not have permission to declare dividends")
        }</span>

        // Generate unique ID
        <span class="cov0" title="0">declarationID := uuid.New().String()
        now := time.Now()

        declaration := &amp;models.DividendDeclaration{
                ID:                  declarationID,
                ChamaID:             chamaID,
                DeclarationDate:     now,
                DividendPerShare:    req.DividendPerShare,
                TotalDividendAmount: req.TotalDividendAmount,
                PaymentDate:         req.PaymentDate,
                Status:              models.DividendStatusDeclared,
                DeclaredBy:          declaredBy,
                Description:         req.Description,
                CreatedAt:           now,
                UpdatedAt:           now,
        }

        // Insert into database
        query := `
                INSERT INTO dividend_declarations (
                        id, chama_id, declaration_date, dividend_per_share, total_dividend_amount,
                        payment_date, status, declared_by, description, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.Exec(
                query,
                declaration.ID,
                declaration.ChamaID,
                declaration.DeclarationDate,
                declaration.DividendPerShare,
                declaration.TotalDividendAmount,
                declaration.PaymentDate,
                declaration.Status,
                declaration.DeclaredBy,
                declaration.Description,
                declaration.CreatedAt,
                declaration.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to declare dividend: %w", err)
        }</span>

        // Create individual dividend payments for eligible members
        <span class="cov0" title="0">err = s.createDividendPayments(declarationID, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to create dividend payments: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Declared dividend %s for chama %s by user %s", declarationID, chamaID, declaredBy)
        return declaration, nil</span>
}

// GetChamaDividendDeclarations retrieves dividend declarations for a chama
func (s *DividendsService) GetChamaDividendDeclarations(chamaID string, limit, offset int) ([]models.DividendDeclarationWithDetails, error) <span class="cov0" title="0">{
        query := `
                SELECT dd.id, dd.chama_id, dd.declaration_date, dd.dividend_per_share, 
                           dd.total_dividend_amount, dd.payment_date, dd.status, dd.declared_by,
                           dd.approved_by, dd.description, dd.created_at, dd.updated_at,
                           u1.first_name, u1.last_name, u2.first_name, u2.last_name
                FROM dividend_declarations dd
                JOIN users u1 ON dd.declared_by = u1.id
                LEFT JOIN users u2 ON dd.approved_by = u2.id
                WHERE dd.chama_id = ?
                ORDER BY dd.declaration_date DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dividend declarations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var declarations []models.DividendDeclarationWithDetails
        for rows.Next() </span><span class="cov0" title="0">{
                var declaration models.DividendDeclarationWithDetails
                var declaredByFirstName, declaredByLastName string
                var approvedByFirstName, approvedByLastName sql.NullString

                err := rows.Scan(
                        &amp;declaration.ID,
                        &amp;declaration.ChamaID,
                        &amp;declaration.DeclarationDate,
                        &amp;declaration.DividendPerShare,
                        &amp;declaration.TotalDividendAmount,
                        &amp;declaration.PaymentDate,
                        &amp;declaration.Status,
                        &amp;declaration.DeclaredBy,
                        &amp;declaration.ApprovedBy,
                        &amp;declaration.Description,
                        &amp;declaration.CreatedAt,
                        &amp;declaration.UpdatedAt,
                        &amp;declaredByFirstName,
                        &amp;declaredByLastName,
                        &amp;approvedByFirstName,
                        &amp;approvedByLastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan dividend declaration: %w", err)
                }</span>

                <span class="cov0" title="0">declaration.DeclaredByName = declaredByFirstName + " " + declaredByLastName
                if approvedByFirstName.Valid &amp;&amp; approvedByLastName.Valid </span><span class="cov0" title="0">{
                        approvedByName := approvedByFirstName.String + " " + approvedByLastName.String
                        declaration.ApprovedByName = &amp;approvedByName
                }</span>

                // Get payment statistics
                <span class="cov0" title="0">stats, err := s.getDividendPaymentStats(declaration.ID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to get payment stats for dividend %s: %v", declaration.ID, err)
                }</span> else<span class="cov0" title="0"> {
                        declaration.TotalEligibleShares = stats.TotalShares
                        declaration.TotalRecipients = stats.TotalRecipients
                        declaration.PaidAmount = stats.PaidAmount
                        declaration.PendingAmount = stats.PendingAmount
                }</span>

                <span class="cov0" title="0">declarations = append(declarations, declaration)</span>
        }

        <span class="cov0" title="0">return declarations, nil</span>
}

// ApproveDividend approves a dividend declaration
func (s *DividendsService) ApproveDividend(declarationID, approvedBy string) (*models.DividendDeclaration, error) <span class="cov0" title="0">{
        // Get existing declaration
        declaration, err := s.getDividendDeclarationByID(declarationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if can be approved
        <span class="cov0" title="0">if !declaration.CanApprove() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dividend declaration cannot be approved in current status: %s", declaration.Status)
        }</span>

        // Validate that the user has permission to approve dividends
        <span class="cov0" title="0">if !s.canApproveDividends(approvedBy, declaration.ChamaID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user does not have permission to approve dividends")
        }</span>

        // Update status
        <span class="cov0" title="0">now := time.Now()
        query := `
                UPDATE dividend_declarations 
                SET status = ?, approved_by = ?, updated_at = ?
                WHERE id = ?
        `

        _, err = s.db.Exec(query, models.DividendStatusApproved, approvedBy, now, declarationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to approve dividend: %w", err)
        }</span>

        <span class="cov0" title="0">declaration.Status = models.DividendStatusApproved
        declaration.ApprovedBy = &amp;approvedBy
        declaration.UpdatedAt = now

        log.Printf("Approved dividend %s by user %s", declarationID, approvedBy)
        return declaration, nil</span>
}

// ProcessDividendPayments processes dividend payments for a declaration
func (s *DividendsService) ProcessDividendPayments(declarationID string, req *models.ProcessDividendPaymentsRequest) error <span class="cov0" title="0">{
        // Get declaration
        declaration, err := s.getDividendDeclarationByID(declarationID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if can be processed
        <span class="cov0" title="0">if !declaration.CanProcess() </span><span class="cov0" title="0">{
                return fmt.Errorf("dividend declaration cannot be processed in current status: %s", declaration.Status)
        }</span>

        // Get pending payments
        <span class="cov0" title="0">payments, err := s.getPendingDividendPayments(declarationID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get pending payments: %w", err)
        }</span>

        <span class="cov0" title="0">if len(payments) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no pending payments found")
        }</span>

        // Process each payment
        <span class="cov0" title="0">successCount := 0
        paymentDate := time.Now()
        if req.PaymentDate != nil </span><span class="cov0" title="0">{
                paymentDate = *req.PaymentDate
        }</span>

        <span class="cov0" title="0">for _, payment := range payments </span><span class="cov0" title="0">{
                err := s.processSingleDividendPayment(&amp;payment, req.PaymentMethod, paymentDate)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to process payment %s: %v", payment.ID, err)
                }</span> else<span class="cov0" title="0"> {
                        successCount++
                }</span>
        }

        // Update declaration status if all payments processed
        <span class="cov0" title="0">if successCount == len(payments) </span><span class="cov0" title="0">{
                err = s.updateDividendDeclarationStatus(declarationID, models.DividendStatusPaid)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to update declaration status: %v", err)
                }</span>
        }

        <span class="cov0" title="0">log.Printf("Processed %d/%d dividend payments for declaration %s", successCount, len(payments), declarationID)
        return nil</span>
}

// GetMemberDividendHistory retrieves dividend history for a member
func (s *DividendsService) GetMemberDividendHistory(chamaID, memberID string, limit, offset int) ([]models.DividendPaymentWithMemberInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT dp.id, dp.dividend_declaration_id, dp.member_id, dp.shares_eligible,
                           dp.dividend_amount, dp.payment_status, dp.payment_date, dp.payment_method,
                           dp.transaction_reference, dp.created_at, dp.updated_at,
                           u.first_name, u.last_name, u.email, u.phone
                FROM dividend_payments dp
                JOIN dividend_declarations dd ON dp.dividend_declaration_id = dd.id
                JOIN users u ON dp.member_id = u.id
                WHERE dd.chama_id = ? AND dp.member_id = ?
                ORDER BY dp.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, chamaID, memberID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get member dividend history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var payments []models.DividendPaymentWithMemberInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var payment models.DividendPaymentWithMemberInfo
                var firstName, lastName string

                err := rows.Scan(
                        &amp;payment.ID,
                        &amp;payment.DividendDeclarationID,
                        &amp;payment.MemberID,
                        &amp;payment.SharesEligible,
                        &amp;payment.DividendAmount,
                        &amp;payment.PaymentStatus,
                        &amp;payment.PaymentDate,
                        &amp;payment.PaymentMethod,
                        &amp;payment.TransactionReference,
                        &amp;payment.CreatedAt,
                        &amp;payment.UpdatedAt,
                        &amp;firstName,
                        &amp;lastName,
                        &amp;payment.MemberEmail,
                        &amp;payment.MemberPhone,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan dividend payment: %w", err)
                }</span>

                <span class="cov0" title="0">payment.MemberName = firstName + " " + lastName
                payments = append(payments, payment)</span>
        }

        <span class="cov0" title="0">return payments, nil</span>
}

// Helper methods
func (s *DividendsService) getDividendDeclarationByID(declarationID string) (*models.DividendDeclaration, error) <span class="cov0" title="0">{
        query := `
                SELECT id, chama_id, declaration_date, dividend_per_share, total_dividend_amount,
                           payment_date, status, declared_by, approved_by, description, created_at, updated_at
                FROM dividend_declarations WHERE id = ?
        `

        var declaration models.DividendDeclaration
        err := s.db.QueryRow(query, declarationID).Scan(
                &amp;declaration.ID,
                &amp;declaration.ChamaID,
                &amp;declaration.DeclarationDate,
                &amp;declaration.DividendPerShare,
                &amp;declaration.TotalDividendAmount,
                &amp;declaration.PaymentDate,
                &amp;declaration.Status,
                &amp;declaration.DeclaredBy,
                &amp;declaration.ApprovedBy,
                &amp;declaration.Description,
                &amp;declaration.CreatedAt,
                &amp;declaration.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("dividend declaration not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get dividend declaration: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;declaration, nil</span>
}

func (s *DividendsService) createDividendPayments(declarationID, chamaID string) error <span class="cov0" title="0">{
        // Get all active shareholders in the chama
        query := `
                SELECT s.member_id, SUM(s.shares_owned) as total_shares
                FROM shares s
                WHERE s.chama_id = ? AND s.status = 'active'
                GROUP BY s.member_id
        `

        rows, err := s.db.Query(query, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get shareholders: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Get dividend per share
        declaration, err := s.getDividendDeclarationByID(declarationID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create payment records for each shareholder
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var memberID string
                var totalShares int

                err := rows.Scan(&amp;memberID, &amp;totalShares)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning shareholder: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">dividendAmount := declaration.CalculateDividendAmount(totalShares)
                if dividendAmount &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">paymentID := uuid.New().String()
                now := time.Now()

                insertQuery := `
                        INSERT INTO dividend_payments (
                                id, dividend_declaration_id, member_id, shares_eligible,
                                dividend_amount, payment_status, created_at, updated_at
                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                `

                _, err = s.db.Exec(
                        insertQuery,
                        paymentID,
                        declarationID,
                        memberID,
                        totalShares,
                        dividendAmount,
                        models.DividendPaymentPending,
                        now,
                        now,
                )

                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to create dividend payment for member %s: %v", memberID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type dividendPaymentStats struct {
        TotalShares     int
        TotalRecipients int
        PaidAmount      float64
        PendingAmount   float64
}

func (s *DividendsService) getDividendPaymentStats(declarationID string) (*dividendPaymentStats, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        SUM(shares_eligible) as total_shares,
                        COUNT(*) as total_recipients,
                        SUM(CASE WHEN payment_status = 'paid' THEN dividend_amount ELSE 0 END) as paid_amount,
                        SUM(CASE WHEN payment_status = 'pending' THEN dividend_amount ELSE 0 END) as pending_amount
                FROM dividend_payments
                WHERE dividend_declaration_id = ?
        `

        var stats dividendPaymentStats
        err := s.db.QueryRow(query, declarationID).Scan(
                &amp;stats.TotalShares,
                &amp;stats.TotalRecipients,
                &amp;stats.PaidAmount,
                &amp;stats.PendingAmount,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get payment stats: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;stats, nil</span>
}

func (s *DividendsService) getPendingDividendPayments(declarationID string) ([]models.DividendPayment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, dividend_declaration_id, member_id, shares_eligible, dividend_amount,
                           payment_status, payment_date, payment_method, transaction_reference,
                           created_at, updated_at
                FROM dividend_payments
                WHERE dividend_declaration_id = ? AND payment_status = 'pending'
                ORDER BY created_at ASC
        `

        rows, err := s.db.Query(query, declarationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pending payments: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var payments []models.DividendPayment
        for rows.Next() </span><span class="cov0" title="0">{
                var payment models.DividendPayment
                err := rows.Scan(
                        &amp;payment.ID,
                        &amp;payment.DividendDeclarationID,
                        &amp;payment.MemberID,
                        &amp;payment.SharesEligible,
                        &amp;payment.DividendAmount,
                        &amp;payment.PaymentStatus,
                        &amp;payment.PaymentDate,
                        &amp;payment.PaymentMethod,
                        &amp;payment.TransactionReference,
                        &amp;payment.CreatedAt,
                        &amp;payment.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan payment: %w", err)
                }</span>
                <span class="cov0" title="0">payments = append(payments, payment)</span>
        }

        <span class="cov0" title="0">return payments, nil</span>
}

func (s *DividendsService) processSingleDividendPayment(payment *models.DividendPayment, paymentMethod string, paymentDate time.Time) error <span class="cov0" title="0">{
        // Generate transaction reference
        transactionRef := fmt.Sprintf("DIV-%s-%d", payment.ID[:8], time.Now().Unix())

        // Update payment record
        query := `
                UPDATE dividend_payments
                SET payment_status = ?, payment_date = ?, payment_method = ?,
                        transaction_reference = ?, updated_at = ?
                WHERE id = ?
        `

        _, err := s.db.Exec(
                query,
                models.DividendPaymentPaid,
                paymentDate,
                paymentMethod,
                transactionRef,
                time.Now(),
                payment.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update payment: %w", err)
        }</span>

        // Here you would integrate with actual payment processing
        // For now, we'll just mark as paid
        <span class="cov0" title="0">log.Printf("Processed dividend payment %s for member %s: %f", payment.ID, payment.MemberID, payment.DividendAmount)
        return nil</span>
}

func (s *DividendsService) updateDividendDeclarationStatus(declarationID string, status models.DividendDeclarationStatus) error <span class="cov0" title="0">{
        query := `UPDATE dividend_declarations SET status = ?, updated_at = ? WHERE id = ?`
        _, err := s.db.Exec(query, status, time.Now(), declarationID)
        return err
}</span>

func (s *DividendsService) canDeclareDividends(userID, chamaID string) bool <span class="cov0" title="0">{
        // Check if user is a chama official (chairperson, secretary, or treasurer)
        query := `
                SELECT 1 FROM chama_members
                WHERE user_id = ? AND chama_id = ? AND is_active = TRUE
                AND role IN ('chairperson', 'secretary', 'treasurer')
        `
        var exists int
        err := s.db.QueryRow(query, userID, chamaID).Scan(&amp;exists)
        return err == nil
}</span>

func (s *DividendsService) canApproveDividends(userID, chamaID string) bool <span class="cov0" title="0">{
        // Check if user is a chama official (chairperson or treasurer)
        query := `
                SELECT 1 FROM chama_members
                WHERE user_id = ? AND chama_id = ? AND is_active = TRUE
                AND role IN ('chairperson', 'treasurer')
        `
        var exists int
        err := s.db.QueryRow(query, userID, chamaID).Scan(&amp;exists)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package services

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/hmac"
        "crypto/rand"
        "crypto/sha256"
        "crypto/subtle"
        "database/sql"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "time"

        "golang.org/x/crypto/curve25519"
        "golang.org/x/crypto/hkdf"
)

// MilitaryGradeE2EEService provides military-grade end-to-end encryption
// Features:
// - Perfect Forward Secrecy (PFS)
// - Post-Compromise Security
// - Authenticated Encryption (AES-256-GCM)
// - Curve25519 key exchange
// - HKDF key derivation
// - Constant-time operations
// - Side-channel attack resistance
type MilitaryGradeE2EEService struct {
        db *sql.DB
}

// EncryptedMessage represents a military-grade encrypted message
type EncryptedMessage struct {
        Version       string    `json:"version"`
        SenderID      string    `json:"senderId"`
        RecipientID   string    `json:"recipientId"`
        Ciphertext    string    `json:"ciphertext"`
        AuthTag       string    `json:"authTag"`
        IV            string    `json:"iv"`
        SessionID     string    `json:"sessionId"`
        MessageNumber int64     `json:"messageNumber"`
        Timestamp     time.Time `json:"timestamp"`
        SecurityLevel string    `json:"securityLevel"`
        IntegrityHash string    `json:"integrityHash"`
}

// KeyBundle represents a user's cryptographic key bundle
type KeyBundle struct {
        UserID          string    `json:"userId"`
        IdentityKey     string    `json:"identityKey"`
        SignedPreKey    string    `json:"signedPreKey"`
        PreKeySignature string    `json:"preKeySignature"`
        OneTimePreKeys  []string  `json:"oneTimePreKeys"`
        RegistrationID  int64     `json:"registrationId"`
        CreatedAt       time.Time `json:"createdAt"`
}

// Session represents a cryptographic session between two users
type Session struct {
        ID             string    `json:"id"`
        UserAID        string    `json:"userAId"`
        UserBID        string    `json:"userBId"`
        SharedSecret   string    `json:"sharedSecret"`
        SendingChain   string    `json:"sendingChain"`
        ReceivingChain string    `json:"receivingChain"`
        MessageNumber  int64     `json:"messageNumber"`
        CreatedAt      time.Time `json:"createdAt"`
        LastUsed       time.Time `json:"lastUsed"`
}

// NewMilitaryGradeE2EEService creates a new military-grade E2EE service
func NewMilitaryGradeE2EEService(db *sql.DB) *MilitaryGradeE2EEService <span class="cov0" title="0">{
        return &amp;MilitaryGradeE2EEService{
                db: db,
        }
}</span>

// InitializeUserKeys initializes cryptographic keys for a user
func (s *MilitaryGradeE2EEService) InitializeUserKeys(userID string) (*KeyBundle, error) <span class="cov0" title="0">{
        fmt.Printf("🔐 Initializing military-grade keys for user: %s\n", userID)

        // Generate identity key pair using Curve25519
        identityPrivate := make([]byte, 32)
        if _, err := rand.Read(identityPrivate); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate identity private key: %w", err)
        }</span>

        <span class="cov0" title="0">var identityPublic [32]byte
        curve25519.ScalarBaseMult(&amp;identityPublic, (*[32]byte)(identityPrivate))

        // Generate signed pre-key
        signedPreKeyPrivate := make([]byte, 32)
        if _, err := rand.Read(signedPreKeyPrivate); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate signed pre-key: %w", err)
        }</span>

        <span class="cov0" title="0">var signedPreKeyPublic [32]byte
        curve25519.ScalarBaseMult(&amp;signedPreKeyPublic, (*[32]byte)(signedPreKeyPrivate))

        // Sign the pre-key with identity key
        signature := s.signData(signedPreKeyPublic[:], identityPrivate)

        // Generate one-time pre-keys
        oneTimePreKeys := make([]string, 100)
        for i := 0; i &lt; 100; i++ </span><span class="cov0" title="0">{
                preKeyPrivate := make([]byte, 32)
                if _, err := rand.Read(preKeyPrivate); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate one-time pre-key %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">var preKeyPublic [32]byte
                curve25519.ScalarBaseMult(&amp;preKeyPublic, (*[32]byte)(preKeyPrivate))
                oneTimePreKeys[i] = base64.StdEncoding.EncodeToString(preKeyPublic[:])</span>
        }

        // Generate registration ID
        <span class="cov0" title="0">regIDBytes := make([]byte, 4)
        if _, err := rand.Read(regIDBytes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate registration ID: %w", err)
        }</span>
        <span class="cov0" title="0">registrationID := int64(regIDBytes[0])&lt;&lt;24 | int64(regIDBytes[1])&lt;&lt;16 | int64(regIDBytes[2])&lt;&lt;8 | int64(regIDBytes[3])

        keyBundle := &amp;KeyBundle{
                UserID:          userID,
                IdentityKey:     base64.StdEncoding.EncodeToString(identityPublic[:]),
                SignedPreKey:    base64.StdEncoding.EncodeToString(signedPreKeyPublic[:]),
                PreKeySignature: base64.StdEncoding.EncodeToString(signature),
                OneTimePreKeys:  oneTimePreKeys,
                RegistrationID:  registrationID,
                CreatedAt:       time.Now(),
        }

        // Store key bundle in database
        if err := s.storeKeyBundle(keyBundle); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store key bundle: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Military-grade keys initialized for user: %s\n", userID)
        return keyBundle, nil</span>
}

// EncryptMessage encrypts a message with military-grade security
func (s *MilitaryGradeE2EEService) EncryptMessage(senderID, recipientID, plaintext string, metadata map[string]interface{}) (*EncryptedMessage, error) <span class="cov0" title="0">{
        fmt.Printf("🔐 Encrypting message with military-grade security: %s -&gt; %s\n", senderID, recipientID)

        // Get or create session
        session, err := s.getOrCreateSession(senderID, recipientID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session: %w", err)
        }</span>

        // Derive message keys using HKDF
        <span class="cov0" title="0">messageKeys, err := s.deriveMessageKeys(session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to derive message keys: %w", err)
        }</span>

        // Prepare message data with metadata protection
        <span class="cov0" title="0">messageData := map[string]interface{}{
                "content":   plaintext,
                "timestamp": time.Now().Unix(),
                "messageId": s.generateSecureMessageID(),
                "metadata":  s.protectMetadata(metadata),
        }

        serializedMessage, err := json.Marshal(messageData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to serialize message: %w", err)
        }</span>

        // Encrypt with AES-256-GCM
        <span class="cov0" title="0">encryptedData, iv, err := s.performAESGCMEncryption(serializedMessage, messageKeys.EncryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt message: %w", err)
        }</span>

        // Generate authentication tag
        <span class="cov0" title="0">authTag := s.generateAuthenticationTag(encryptedData, messageKeys.MACKey, recipientID)

        // Calculate integrity hash
        integrityHash := s.calculateIntegrityHash(encryptedData, authTag, iv)

        // Update session state for perfect forward secrecy
        if err := s.updateSessionState(session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update session state: %w", err)
        }</span>

        <span class="cov0" title="0">encryptedMessage := &amp;EncryptedMessage{
                Version:       "1.0",
                SenderID:      senderID,
                RecipientID:   recipientID,
                Ciphertext:    base64.StdEncoding.EncodeToString(encryptedData),
                AuthTag:       base64.StdEncoding.EncodeToString(authTag),
                IV:            base64.StdEncoding.EncodeToString(iv),
                SessionID:     session.ID,
                MessageNumber: session.MessageNumber,
                Timestamp:     time.Now(),
                SecurityLevel: "MILITARY_GRADE",
                IntegrityHash: integrityHash,
        }

        fmt.Printf("✅ Message encrypted with military-grade security\n")
        return encryptedMessage, nil</span>
}

// DecryptMessage decrypts a military-grade encrypted message
func (s *MilitaryGradeE2EEService) DecryptMessage(encryptedMessage *EncryptedMessage) (string, map[string]interface{}, error) <span class="cov0" title="0">{
        fmt.Printf("🔓 Decrypting military-grade encrypted message\n")

        // Validate message structure
        if err := s.validateEncryptedMessage(encryptedMessage); err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("invalid message structure: %w", err)
        }</span>

        // Get session
        <span class="cov0" title="0">session, err := s.getSession(encryptedMessage.SenderID, encryptedMessage.RecipientID)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to get session: %w", err)
        }</span>

        // Verify integrity hash
        <span class="cov0" title="0">ciphertext, _ := base64.StdEncoding.DecodeString(encryptedMessage.Ciphertext)
        authTag, _ := base64.StdEncoding.DecodeString(encryptedMessage.AuthTag)
        iv, _ := base64.StdEncoding.DecodeString(encryptedMessage.IV)

        expectedHash := s.calculateIntegrityHash(ciphertext, authTag, iv)
        if !s.constantTimeCompare([]byte(expectedHash), []byte(encryptedMessage.IntegrityHash)) </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("message integrity verification failed")
        }</span>

        // Derive message keys
        <span class="cov0" title="0">messageKeys, err := s.deriveDecryptionKeys(session, encryptedMessage.MessageNumber)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to derive decryption keys: %w", err)
        }</span>

        // Verify authentication tag
        <span class="cov0" title="0">expectedAuthTag := s.generateAuthenticationTag(ciphertext, messageKeys.MACKey, encryptedMessage.RecipientID)
        if !s.constantTimeCompare(authTag, expectedAuthTag) </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("message authentication failed - possible tampering")
        }</span>

        // Decrypt with AES-256-GCM
        <span class="cov0" title="0">decryptedData, err := s.performAESGCMDecryption(ciphertext, messageKeys.EncryptionKey, iv)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to decrypt message: %w", err)
        }</span>

        // Parse decrypted message
        <span class="cov0" title="0">var messageData map[string]interface{}
        if err := json.Unmarshal(decryptedData, &amp;messageData); err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to parse decrypted message: %w", err)
        }</span>

        // Update session state
        <span class="cov0" title="0">if err := s.updateSessionStateForDecryption(session); err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to update session state: %w", err)
        }</span>

        <span class="cov0" title="0">content, _ := messageData["content"].(string)
        metadata := s.unprotectMetadata(messageData["metadata"])

        fmt.Printf("✅ Message decrypted successfully\n")
        return content, metadata, nil</span>
}

// MessageKeys represents derived encryption and MAC keys
type MessageKeys struct {
        EncryptionKey []byte
        MACKey        []byte
}

// deriveMessageKeys derives encryption and MAC keys using HKDF
func (s *MilitaryGradeE2EEService) deriveMessageKeys(session *Session) (*MessageKeys, error) <span class="cov0" title="0">{
        sharedSecret, err := base64.StdEncoding.DecodeString(session.SharedSecret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode shared secret: %w", err)
        }</span>

        // Use HKDF to derive keys
        <span class="cov0" title="0">hkdf := hkdf.New(sha256.New, sharedSecret, nil, []byte("VaultKe-E2EE-v1.0"))

        encryptionKey := make([]byte, 32) // AES-256
        if _, err := hkdf.Read(encryptionKey); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to derive encryption key: %w", err)
        }</span>

        <span class="cov0" title="0">macKey := make([]byte, 32) // HMAC-SHA-256
        if _, err := hkdf.Read(macKey); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to derive MAC key: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;MessageKeys{
                EncryptionKey: encryptionKey,
                MACKey:        macKey,
        }, nil</span>
}

// performAESGCMEncryption encrypts data using AES-256-GCM
func (s *MilitaryGradeE2EEService) performAESGCMEncryption(plaintext, key []byte) ([]byte, []byte, error) <span class="cov0" title="0">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create AES cipher: %w", err)
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        // Generate random IV
        <span class="cov0" title="0">iv := make([]byte, gcm.NonceSize())
        if _, err := rand.Read(iv); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to generate IV: %w", err)
        }</span>

        <span class="cov0" title="0">ciphertext := gcm.Seal(nil, iv, plaintext, nil)
        return ciphertext, iv, nil</span>
}

// performAESGCMDecryption decrypts data using AES-256-GCM
func (s *MilitaryGradeE2EEService) performAESGCMDecryption(ciphertext, key, iv []byte) ([]byte, error) <span class="cov0" title="0">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create AES cipher: %w", err)
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        <span class="cov0" title="0">plaintext, err := gcm.Open(nil, iv, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt: %w", err)
        }</span>

        <span class="cov0" title="0">return plaintext, nil</span>
}

// generateAuthenticationTag generates HMAC-SHA-256 authentication tag
func (s *MilitaryGradeE2EEService) generateAuthenticationTag(data, macKey []byte, recipientID string) []byte <span class="cov0" title="0">{
        h := hmac.New(sha256.New, macKey)
        h.Write(data)
        h.Write([]byte(recipientID))
        h.Write([]byte(fmt.Sprintf("%d", time.Now().Unix())))
        return h.Sum(nil)
}</span>

// constantTimeCompare performs constant-time comparison to prevent timing attacks
func (s *MilitaryGradeE2EEService) constantTimeCompare(a, b []byte) bool <span class="cov0" title="0">{
        return subtle.ConstantTimeCompare(a, b) == 1
}</span>

// signData signs data using Ed25519 (simplified implementation)
func (s *MilitaryGradeE2EEService) signData(data, privateKey []byte) []byte <span class="cov0" title="0">{
        h := hmac.New(sha256.New, privateKey)
        h.Write(data)
        return h.Sum(nil)
}</span>

// generateSecureMessageID generates a cryptographically secure message ID
func (s *MilitaryGradeE2EEService) generateSecureMessageID() string <span class="cov0" title="0">{
        randomBytes := make([]byte, 16)
        rand.Read(randomBytes)
        return fmt.Sprintf("mil_msg_%d_%x", time.Now().Unix(), randomBytes)
}</span>

// calculateIntegrityHash calculates integrity hash for message
func (s *MilitaryGradeE2EEService) calculateIntegrityHash(ciphertext, authTag, iv []byte) string <span class="cov0" title="0">{
        h := sha256.New()
        h.Write(ciphertext)
        h.Write(authTag)
        h.Write(iv)
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// protectMetadata adds padding to metadata to prevent traffic analysis
func (s *MilitaryGradeE2EEService) protectMetadata(metadata map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        if metadata == nil </span><span class="cov0" title="0">{
                metadata = make(map[string]interface{})
        }</span>

        // Add random padding
        <span class="cov0" title="0">paddingSize := 32 + (time.Now().Unix() % 64)
        padding := make([]byte, paddingSize)
        rand.Read(padding)

        metadata["_padding"] = base64.StdEncoding.EncodeToString(padding)
        metadata["_timestamp"] = time.Now().Unix()
        metadata["_version"] = "1.0"

        return metadata</span>
}

// unprotectMetadata removes padding from metadata
func (s *MilitaryGradeE2EEService) unprotectMetadata(metadata interface{}) map[string]interface{} <span class="cov0" title="0">{
        if metadata == nil </span><span class="cov0" title="0">{
                return make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">metadataMap, ok := metadata.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return make(map[string]interface{})
        }</span>

        // Remove padding fields
        <span class="cov0" title="0">delete(metadataMap, "_padding")
        delete(metadataMap, "_timestamp")
        delete(metadataMap, "_version")

        return metadataMap</span>
}

// validateEncryptedMessage validates the structure of an encrypted message
func (s *MilitaryGradeE2EEService) validateEncryptedMessage(msg *EncryptedMessage) error <span class="cov0" title="0">{
        if msg.Version != "1.0" </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported message version: %s", msg.Version)
        }</span>

        <span class="cov0" title="0">if msg.SenderID == "" || msg.RecipientID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing sender or recipient ID")
        }</span>

        <span class="cov0" title="0">if msg.Ciphertext == "" || msg.AuthTag == "" || msg.IV == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing cryptographic components")
        }</span>

        <span class="cov0" title="0">if msg.SecurityLevel != "MILITARY_GRADE" </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported security level: %s", msg.SecurityLevel)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Database operations for key management and session storage

// storeKeyBundle stores a user's key bundle in the database
func (s *MilitaryGradeE2EEService) storeKeyBundle(keyBundle *KeyBundle) error <span class="cov0" title="0">{
        query := `
                INSERT INTO e2ee_key_bundles (
                        user_id, identity_key, signed_pre_key, pre_key_signature,
                        one_time_pre_keys, registration_id, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
                ON DUPLICATE KEY UPDATE
                        identity_key = VALUES(identity_key),
                        signed_pre_key = VALUES(signed_pre_key),
                        pre_key_signature = VALUES(pre_key_signature),
                        one_time_pre_keys = VALUES(one_time_pre_keys),
                        registration_id = VALUES(registration_id),
                        created_at = VALUES(created_at)
        `

        oneTimePreKeysJSON, err := json.Marshal(keyBundle.OneTimePreKeys)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal one-time pre-keys: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = s.db.Exec(query,
                keyBundle.UserID,
                keyBundle.IdentityKey,
                keyBundle.SignedPreKey,
                keyBundle.PreKeySignature,
                string(oneTimePreKeysJSON),
                keyBundle.RegistrationID,
                keyBundle.CreatedAt,
        )

        return err</span>
}

// getKeyBundle retrieves a user's key bundle from the database
func (s *MilitaryGradeE2EEService) getKeyBundle(userID string) (*KeyBundle, error) <span class="cov0" title="0">{
        query := `
                SELECT user_id, identity_key, signed_pre_key, pre_key_signature,
                           one_time_pre_keys, registration_id, created_at
                FROM e2ee_key_bundles
                WHERE user_id = ?
        `

        var keyBundle KeyBundle
        var oneTimePreKeysJSON string

        err := s.db.QueryRow(query, userID).Scan(
                &amp;keyBundle.UserID,
                &amp;keyBundle.IdentityKey,
                &amp;keyBundle.SignedPreKey,
                &amp;keyBundle.PreKeySignature,
                &amp;oneTimePreKeysJSON,
                &amp;keyBundle.RegistrationID,
                &amp;keyBundle.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get key bundle: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(oneTimePreKeysJSON), &amp;keyBundle.OneTimePreKeys); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal one-time pre-keys: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;keyBundle, nil</span>
}

// getOrCreateSession gets an existing session or creates a new one
func (s *MilitaryGradeE2EEService) getOrCreateSession(userAID, userBID string) (*Session, error) <span class="cov0" title="0">{
        // Try to get existing session
        session, err := s.getSession(userAID, userBID)
        if err == nil </span><span class="cov0" title="0">{
                return session, nil
        }</span>

        // Create new session
        <span class="cov0" title="0">return s.createSession(userAID, userBID)</span>
}

// getSession retrieves an existing session
func (s *MilitaryGradeE2EEService) getSession(userAID, userBID string) (*Session, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_a_id, user_b_id, shared_secret, sending_chain,
                           receiving_chain, message_number, created_at, last_used
                FROM e2ee_sessions
                WHERE (user_a_id = ? AND user_b_id = ?) OR (user_a_id = ? AND user_b_id = ?)
                ORDER BY last_used DESC
                LIMIT 1
        `

        var session Session
        err := s.db.QueryRow(query, userAID, userBID, userBID, userAID).Scan(
                &amp;session.ID,
                &amp;session.UserAID,
                &amp;session.UserBID,
                &amp;session.SharedSecret,
                &amp;session.SendingChain,
                &amp;session.ReceivingChain,
                &amp;session.MessageNumber,
                &amp;session.CreatedAt,
                &amp;session.LastUsed,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;session, nil</span>
}

// createSession creates a new cryptographic session
func (s *MilitaryGradeE2EEService) createSession(userAID, userBID string) (*Session, error) <span class="cov0" title="0">{
        // Generate shared secret using key exchange
        sharedSecret := make([]byte, 32)
        if _, err := rand.Read(sharedSecret); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate shared secret: %w", err)
        }</span>

        // Generate chain keys
        <span class="cov0" title="0">sendingChain := make([]byte, 32)
        receivingChain := make([]byte, 32)
        if _, err := rand.Read(sendingChain); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate sending chain: %w", err)
        }</span>
        <span class="cov0" title="0">if _, err := rand.Read(receivingChain); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate receiving chain: %w", err)
        }</span>

        <span class="cov0" title="0">sessionID := fmt.Sprintf("session_%d_%x", time.Now().Unix(), sharedSecret[:8])

        session := &amp;Session{
                ID:             sessionID,
                UserAID:        userAID,
                UserBID:        userBID,
                SharedSecret:   base64.StdEncoding.EncodeToString(sharedSecret),
                SendingChain:   base64.StdEncoding.EncodeToString(sendingChain),
                ReceivingChain: base64.StdEncoding.EncodeToString(receivingChain),
                MessageNumber:  0,
                CreatedAt:      time.Now(),
                LastUsed:       time.Now(),
        }

        // Store session in database
        if err := s.storeSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// storeSession stores a session in the database
func (s *MilitaryGradeE2EEService) storeSession(session *Session) error <span class="cov0" title="0">{
        query := `
                INSERT INTO e2ee_sessions (
                        id, user_a_id, user_b_id, shared_secret, sending_chain,
                        receiving_chain, message_number, created_at, last_used
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                ON DUPLICATE KEY UPDATE
                        shared_secret = VALUES(shared_secret),
                        sending_chain = VALUES(sending_chain),
                        receiving_chain = VALUES(receiving_chain),
                        message_number = VALUES(message_number),
                        last_used = VALUES(last_used)
        `

        _, err := s.db.Exec(query,
                session.ID,
                session.UserAID,
                session.UserBID,
                session.SharedSecret,
                session.SendingChain,
                session.ReceivingChain,
                session.MessageNumber,
                session.CreatedAt,
                session.LastUsed,
        )

        return err
}</span>

// updateSessionState updates session state for perfect forward secrecy
func (s *MilitaryGradeE2EEService) updateSessionState(session *Session) error <span class="cov0" title="0">{
        session.MessageNumber++
        session.LastUsed = time.Now()

        // Rotate chain keys for perfect forward secrecy
        sendingChain, _ := base64.StdEncoding.DecodeString(session.SendingChain)
        newSendingChain := sha256.Sum256(sendingChain)
        session.SendingChain = base64.StdEncoding.EncodeToString(newSendingChain[:])

        return s.storeSession(session)
}</span>

// updateSessionStateForDecryption updates session state for decryption
func (s *MilitaryGradeE2EEService) updateSessionStateForDecryption(session *Session) error <span class="cov0" title="0">{
        session.LastUsed = time.Now()

        // Rotate receiving chain for perfect forward secrecy
        receivingChain, _ := base64.StdEncoding.DecodeString(session.ReceivingChain)
        newReceivingChain := sha256.Sum256(receivingChain)
        session.ReceivingChain = base64.StdEncoding.EncodeToString(newReceivingChain[:])

        return s.storeSession(session)
}</span>

// deriveDecryptionKeys derives keys for message decryption
func (s *MilitaryGradeE2EEService) deriveDecryptionKeys(session *Session, messageNumber int64) (*MessageKeys, error) <span class="cov0" title="0">{
        // For simplicity, using the same derivation as encryption
        // In a full implementation, this would handle out-of-order messages
        return s.deriveMessageKeys(session)
}</span>

// GetKeyBundle retrieves a user's key bundle (public method for API)
func (s *MilitaryGradeE2EEService) GetKeyBundle(userID string) (*KeyBundle, error) <span class="cov0" title="0">{
        return s.getKeyBundle(userID)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package services

import (
        "fmt"
        "net/smtp"
        "os"
        "time"
)

// EmailService handles email sending functionality
type EmailService struct {
        smtpHost     string
        smtpPort     string
        smtpUsername string
        smtpPassword string
        fromEmail    string
}

// NewEmailService creates a new email service
func NewEmailService() *EmailService <span class="cov8" title="1">{
        // Get password and trim quotes if present
        password := os.Getenv("SMTP_PASSWORD")
        fmt.Printf("Raw password from env: '%s' (length: %d)\n", password, len(password))

        if len(password) &gt;= 2 &amp;&amp; password[0] == '"' &amp;&amp; password[len(password)-1] == '"' </span><span class="cov0" title="0">{
                password = password[1 : len(password)-1]
                fmt.Printf("Trimmed quotes from password: '%s' (length: %d)\n", password, len(password))
        }</span>

        <span class="cov8" title="1">return &amp;EmailService{
                smtpHost:     os.Getenv("SMTP_HOST"),
                smtpPort:     os.Getenv("SMTP_PORT"),
                smtpUsername: os.Getenv("SMTP_USERNAME"),
                smtpPassword: password,
                fromEmail:    os.Getenv("SMTP_USERNAME"), // Use SMTP username as from email
        }</span>
}

// SendPasswordResetEmail sends a password reset email to the user
func (s *EmailService) SendPasswordResetEmail(toEmail, resetToken, userName string) error <span class="cov0" title="0">{
        // Validate configuration
        if s.smtpHost == "" || s.smtpPort == "" || s.smtpUsername == "" || s.smtpPassword == "" </span><span class="cov0" title="0">{
                fmt.Printf("Email service configuration missing: host=%s, port=%s, username=%s, password_set=%t\n",
                        s.smtpHost, s.smtpPort, s.smtpUsername, s.smtpPassword != "")
                return fmt.Errorf("email service not configured properly")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Email service configuration loaded:\n")
        fmt.Printf("  Host: %s\n", s.smtpHost)
        fmt.Printf("  Port: %s\n", s.smtpPort)
        fmt.Printf("  Username: %s\n", s.smtpUsername)
        fmt.Printf("  Password: '%s' (length: %d)\n", s.smtpPassword, len(s.smtpPassword))
        fmt.Printf("Sending password reset email to: %s with token: %s\n", toEmail, resetToken)

        // Create reset URL (you can customize this based on your frontend)
        resetURL := fmt.Sprintf("https://vaultke.com/reset-password?token=%s", resetToken)

        // Email subject and body
        subject := "VaultKe - Password Reset Request"
        body := s.generatePasswordResetEmailBody(userName, resetURL, resetToken)

        // Create email message in the exact format as your working app
        message := fmt.Sprintf("To: %s\r\nSubject: %s\r\nContent-Type: text/html; charset=UTF-8\r\n\r\n%s",
                toEmail, subject, body)

        // Send email
        err := s.sendEmail(toEmail, message)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to send email: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("Email sent successfully to: %s\n", toEmail)
        return nil</span>
}

// sendEmail sends an email using SMTP - exact same approach as your working code
func (s *EmailService) sendEmail(toEmail, message string) error <span class="cov0" title="0">{
        // Set up authentication - exact same as your working code
        auth := smtp.PlainAuth("", s.smtpUsername, s.smtpPassword, s.smtpHost)

        // SMTP server address
        addr := fmt.Sprintf("%s:%s", s.smtpHost, s.smtpPort)

        fmt.Printf("Attempting to send email via SMTP server: %s\n", addr)
        fmt.Printf("From: %s, To: %s\n", s.fromEmail, toEmail)
        fmt.Printf("Auth details - Username: %s, Password: '%s' (length: %d)\n", s.smtpUsername, s.smtpPassword, len(s.smtpPassword))

        // Send email - exact same method as your working code
        err := smtp.SendMail(addr, auth, s.fromEmail, []string{toEmail}, []byte(message))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("SMTP error: %v\n", err)
                return fmt.Errorf("failed to send email: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Email sent successfully!\n")
        return nil</span>
}

// SendChamaInvitationEmail sends a chama invitation email to the invitee
func (s *EmailService) SendChamaInvitationEmail(toEmail, chamaName, inviterName, message, invitationToken string) error <span class="cov0" title="0">{
        // Validate configuration
        if s.smtpHost == "" || s.smtpPort == "" || s.smtpUsername == "" || s.smtpPassword == "" </span><span class="cov0" title="0">{
                fmt.Printf("Email service configuration missing for chama invitation\n")
                return fmt.Errorf("email service not configured properly")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Sending chama invitation email to: %s for chama: %s\n", toEmail, chamaName)

        // Create invitation URL
        invitationURL := fmt.Sprintf("https://vaultke.com/chama-invitation?token=%s", invitationToken)

        // Email subject and body
        subject := fmt.Sprintf("VaultKe - Invitation to Join %s Chama", chamaName)
        body := s.generateChamaInvitationEmailBody(chamaName, inviterName, message, invitationURL, invitationToken)

        // Create email message in the exact format as your working app
        emailMessage := fmt.Sprintf("To: %s\r\nSubject: %s\r\nContent-Type: text/html; charset=UTF-8\r\n\r\n%s",
                toEmail, subject, body)

        // Send email
        err := s.sendEmail(toEmail, emailMessage)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to send chama invitation email: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("Chama invitation email sent successfully to: %s\n", toEmail)
        return nil</span>
}

// generatePasswordResetEmailBody generates the HTML email body for password reset
func (s *EmailService) generatePasswordResetEmailBody(userName, resetURL, resetToken string) string <span class="cov0" title="0">{
        // If userName is empty, use a generic greeting
        if userName == "" </span><span class="cov0" title="0">{
                userName = "VaultKe User"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;VaultKe - Password Reset&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: #2563eb; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }
        .content { background: #f8fafc; padding: 30px; border-radius: 0 0 8px 8px; }
        .button { display: inline-block; background: #2563eb; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 20px 0; }
        .token { background: #e2e8f0; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 18px; text-align: center; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #64748b; font-size: 14px; }
        .warning { background: #fef3c7; border: 1px solid #f59e0b; padding: 15px; border-radius: 6px; margin: 20px 0; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;🔐 VaultKe Password Reset&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;h2&gt;Hello %s,&lt;/h2&gt;
            &lt;p&gt;We received a request to reset your VaultKe account password. If you made this request, you can reset your password using the button below:&lt;/p&gt;
            
            &lt;div style="text-align: center;"&gt;
                &lt;a href="%s" class="button"&gt;Reset Your Password&lt;/a&gt;
            &lt;/div&gt;
            
            &lt;p&gt;Or copy and paste this reset code in the VaultKe app:&lt;/p&gt;
            &lt;div class="token"&gt;%s&lt;/div&gt;
            
            &lt;div class="warning"&gt;
                &lt;strong&gt;⚠️ Important Security Information:&lt;/strong&gt;
                &lt;ul&gt;
                    &lt;li&gt;This reset link will expire in 1 hour for security&lt;/li&gt;
                    &lt;li&gt;If you didn't request this reset, please ignore this email&lt;/li&gt;
                    &lt;li&gt;Never share this reset code with anyone&lt;/li&gt;
                    &lt;li&gt;VaultKe will never ask for your password via email&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            
            &lt;p&gt;If you're having trouble with the button above, you can also reset your password by:&lt;/p&gt;
            &lt;ol&gt;
                &lt;li&gt;Opening the VaultKe app&lt;/li&gt;
                &lt;li&gt;Going to "Forgot Password"&lt;/li&gt;
                &lt;li&gt;Entering the reset code: &lt;strong&gt;%s&lt;/strong&gt;&lt;/li&gt;
            &lt;/ol&gt;
            
            &lt;p&gt;If you didn't request a password reset, you can safely ignore this email. Your password will remain unchanged.&lt;/p&gt;
            
            &lt;p&gt;Best regards,&lt;br&gt;The VaultKe Team&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt;This email was sent by VaultKe - Your trusted chama finance companion&lt;/p&gt;
            &lt;p&gt;© %d VaultKe. All rights reserved.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`, userName, resetURL, resetToken, resetToken, time.Now().Year())</span>
}

// generateChamaInvitationEmailBody generates the HTML email body for chama invitation
func (s *EmailService) generateChamaInvitationEmailBody(chamaName, inviterName, message, invitationURL, invitationToken string) string <span class="cov0" title="0">{
        // If message is empty, use a default message
        if message == "" </span><span class="cov0" title="0">{
                message = fmt.Sprintf("You have been invited to join %s chama. Join us to start saving and investing together!", chamaName)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;VaultKe - Chama Invitation&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: #2563eb; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }
        .content { background: #f8fafc; padding: 30px; border-radius: 0 0 8px 8px; }
        .button { display: inline-block; background: #2563eb; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 20px 0; }
        .chama-info { background: #e2e8f0; padding: 20px; border-radius: 6px; margin: 20px 0; }
        .token { background: #e2e8f0; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 16px; text-align: center; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #64748b; font-size: 14px; }
        .warning { background: #fef3c7; border: 1px solid #f59e0b; padding: 15px; border-radius: 6px; margin: 20px 0; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;🏦 VaultKe Chama Invitation&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;h2&gt;You're Invited to Join %s!&lt;/h2&gt;
            &lt;p&gt;&lt;strong&gt;%s&lt;/strong&gt; has invited you to join their chama on VaultKe.&lt;/p&gt;

            &lt;div class="chama-info"&gt;
                &lt;h3&gt;📋 Invitation Details:&lt;/h3&gt;
                &lt;p&gt;&lt;strong&gt;Chama Name:&lt;/strong&gt; %s&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Invited by:&lt;/strong&gt; %s&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Message:&lt;/strong&gt; %s&lt;/p&gt;
            &lt;/div&gt;

            &lt;div style="text-align: center;"&gt;
                &lt;a href="%s" class="button"&gt;Accept Invitation&lt;/a&gt;
            &lt;/div&gt;

            &lt;p&gt;Or copy and paste this invitation code in the VaultKe app:&lt;/p&gt;
            &lt;div class="token"&gt;%s&lt;/div&gt;

            &lt;div class="warning"&gt;
                &lt;strong&gt;⚠️ Important Information:&lt;/strong&gt;
                &lt;ul&gt;
                    &lt;li&gt;This invitation will expire in 7 days&lt;/li&gt;
                    &lt;li&gt;You need a VaultKe account to join the chama&lt;/li&gt;
                    &lt;li&gt;If you don't have an account, download the VaultKe app first&lt;/li&gt;
                    &lt;li&gt;Only accept invitations from people you trust&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;

            &lt;h3&gt;🤔 What is a Chama?&lt;/h3&gt;
            &lt;p&gt;A chama is a group savings and investment club where members contribute money regularly and support each other financially. VaultKe makes it easy to:&lt;/p&gt;
            &lt;ul&gt;
                &lt;li&gt;💰 Track contributions and payments&lt;/li&gt;
                &lt;li&gt;📊 Monitor group finances&lt;/li&gt;
                &lt;li&gt;🤝 Manage loans and investments&lt;/li&gt;
                &lt;li&gt;📱 Communicate with members&lt;/li&gt;
            &lt;/ul&gt;

            &lt;p&gt;If you didn't expect this invitation, you can safely ignore this email.&lt;/p&gt;

            &lt;p&gt;Best regards,&lt;br&gt;The VaultKe Team&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt;This email was sent by VaultKe - Your trusted chama finance companion&lt;/p&gt;
            &lt;p&gt;© %d VaultKe. All rights reserved.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`, chamaName, inviterName, chamaName, inviterName, message, invitationURL, invitationToken, time.Now().Year())</span>
}

// SendTestEmail sends a test email to verify configuration
func (s *EmailService) SendTestEmail(toEmail string) error <span class="cov0" title="0">{
        subject := "VaultKe - Email Service Test"
        body := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;VaultKe Email Test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;✅ Email Service Working!&lt;/h2&gt;
    &lt;p&gt;This is a test email from VaultKe to verify that the email service is configured correctly.&lt;/p&gt;
    &lt;p&gt;If you received this email, the SMTP configuration is working properly.&lt;/p&gt;
    &lt;p&gt;Best regards,&lt;br&gt;The VaultKe Team&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;`

        message := fmt.Sprintf("From: %s\r\n", s.fromEmail)
        message += fmt.Sprintf("To: %s\r\n", toEmail)
        message += fmt.Sprintf("Subject: %s\r\n", subject)
        message += "MIME-Version: 1.0\r\n"
        message += "Content-Type: text/html; charset=UTF-8\r\n"
        message += "\r\n"
        message += body

        return s.sendEmail(toEmail, message)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package services

import (
        "fmt"
        "time"

        "github.com/livekit/protocol/auth"
        "github.com/livekit/protocol/livekit"
)

type LiveKitService struct {
        apiKey    string
        apiSecret string
        wsURL     string
}

func NewLiveKitService(wsURL, apiKey, apiSecret string) *LiveKitService <span class="cov0" title="0">{
        // Debug logging to verify credentials
        fmt.Printf("🔍 LiveKit Service initialized with:\n")
        fmt.Printf("  - WS URL: %s\n", wsURL)
        fmt.Printf("  - API Key: %s\n", apiKey)
        fmt.Printf("  - API Secret length: %d\n", len(apiSecret))

        return &amp;LiveKitService{
                apiKey:    apiKey,
                apiSecret: apiSecret,
                wsURL:     wsURL,
        }
}</span>

// GenerateAccessToken creates a LiveKit access token for a user
func (s *LiveKitService) GenerateAccessToken(roomName, participantName, userRole string) (string, error) <span class="cov0" title="0">{
        fmt.Printf("🔍 Generating token with credentials:\n")
        fmt.Printf("  - API Key: %s\n", s.apiKey)
        fmt.Printf("  - API Secret length: %d\n", len(s.apiSecret))
        fmt.Printf("  - Room: %s\n", roomName)
        fmt.Printf("  - Participant: %s\n", participantName)
        fmt.Printf("  - Role: %s\n", userRole)

        if s.apiKey == "" || s.apiSecret == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("missing API key or secret key")
        }</span>

        // Create access token
        <span class="cov0" title="0">at := auth.NewAccessToken(s.apiKey, s.apiSecret)

        // Set token validity (24 hours)
        at.SetValidFor(24 * time.Hour)

        // Set participant identity and name
        at.SetIdentity(participantName)
        at.SetName(participantName)

        // Set permissions based on user role
        grant := &amp;auth.VideoGrant{
                RoomJoin: true,
                Room:     roomName,
        }

        // Helper function to create bool pointers
        boolPtr := func(b bool) *bool </span><span class="cov0" title="0">{ return &amp;b }</span>

        // Role-based permissions
        <span class="cov0" title="0">switch userRole </span>{
        case "chairperson":<span class="cov0" title="0">
                grant.RoomAdmin = true
                grant.CanPublish = boolPtr(true)
                grant.CanSubscribe = boolPtr(true)
                grant.CanPublishData = boolPtr(true)</span>
        case "secretary":<span class="cov0" title="0">
                grant.CanPublish = boolPtr(true)
                grant.CanSubscribe = boolPtr(true)
                grant.CanPublishData = boolPtr(true)</span>
        case "treasurer":<span class="cov0" title="0">
                grant.CanPublish = boolPtr(true)
                grant.CanSubscribe = boolPtr(true)
                grant.CanPublishData = boolPtr(true)</span>
        case "member":<span class="cov0" title="0">
                grant.CanPublish = boolPtr(true)
                grant.CanSubscribe = boolPtr(true)
                grant.CanPublishData = boolPtr(false)</span>
        default:<span class="cov0" title="0">
                grant.CanPublish = boolPtr(false)
                grant.CanSubscribe = boolPtr(true)
                grant.CanPublishData = boolPtr(false)</span>
        }

        <span class="cov0" title="0">at.SetVideoGrant(grant)

        // Generate the token
        token, err := at.ToJWT()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate token: %w", err)
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

// CreateRoom creates a new LiveKit room
func (s *LiveKitService) CreateRoom(roomName string, maxParticipants uint32) (*livekit.Room, error) <span class="cov0" title="0">{
        if s.apiKey == "" || s.apiSecret == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing API key or secret key")
        }</span>

        // For now, we'll return a mock room since we don't have the LiveKit server SDK
        // In a real implementation, you would use the LiveKit server SDK to create the room
        <span class="cov0" title="0">room := &amp;livekit.Room{
                Sid:             fmt.Sprintf("room_%s_%d", roomName, time.Now().Unix()),
                Name:            roomName,
                EmptyTimeout:    300, // 5 minutes
                MaxParticipants: maxParticipants,
                CreationTime:    time.Now().Unix(),
                TurnPassword:    "",
                EnabledCodecs:   []*livekit.Codec{},
                Metadata:        "",
                NumParticipants: 0,
                NumPublishers:   0,
                ActiveRecording: false,
        }

        return room, nil</span>
}

// GetRoomInfo gets information about a LiveKit room
func (s *LiveKitService) GetRoomInfo(roomName string) (*livekit.Room, error) <span class="cov0" title="0">{
        if s.apiKey == "" || s.apiSecret == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing API key or secret key")
        }</span>

        // Mock implementation - in real scenario, you'd query the LiveKit server
        <span class="cov0" title="0">room := &amp;livekit.Room{
                Sid:             fmt.Sprintf("room_%s", roomName),
                Name:            roomName,
                EmptyTimeout:    300,
                MaxParticipants: 50,
                CreationTime:    time.Now().Unix(),
                NumParticipants: 0,
                NumPublishers:   0,
                ActiveRecording: false,
        }

        return room, nil</span>
}

// DeleteRoom deletes a LiveKit room
func (s *LiveKitService) DeleteRoom(roomName string) error <span class="cov0" title="0">{
        if s.apiKey == "" || s.apiSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing API key or secret key")
        }</span>

        // Mock implementation - in real scenario, you'd delete the room from LiveKit server
        <span class="cov0" title="0">fmt.Printf("Room %s would be deleted\n", roomName)
        return nil</span>
}

// GetWSURL returns the WebSocket URL for LiveKit
func (s *LiveKitService) GetWSURL() string <span class="cov0" title="0">{
        return s.wsURL
}</span>

// ValidateConfig checks if the LiveKit configuration is valid
func (s *LiveKitService) ValidateConfig() error <span class="cov0" title="0">{
        if s.apiKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("LIVEKIT_API_KEY environment variable is required")
        }</span>
        <span class="cov0" title="0">if s.apiSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("LIVEKIT_API_SECRET environment variable is required")
        }</span>
        <span class="cov0" title="0">if s.wsURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("LIVEKIT_WS_URL environment variable is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package services

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/google/uuid"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/utils"
)

// LoanService handles loan-related business logic
type LoanService struct {
        db *sql.DB
}

// NewLoanService creates a new loan service
func NewLoanService(db *sql.DB) *LoanService <span class="cov0" title="0">{
        return &amp;LoanService{db: db}
}</span>

// ApplyForLoan creates a new loan application
func (s *LoanService) ApplyForLoan(application *models.LoanApplication, borrowerID, chamaID string) (*models.Loan, error) <span class="cov0" title="0">{
        // Validate input
        if err := utils.ValidateStruct(application); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        // Check if user is a member of the chama
        <span class="cov0" title="0">chamaService := NewChamaService(s.db)
        isMember, err := chamaService.IsUserMember(chamaID, borrowerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user is not a member of this chama")
        }</span>

        // Check if user has any active loans
        <span class="cov0" title="0">hasActiveLoan, err := s.hasActiveLoan(borrowerID, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if hasActiveLoan </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user already has an active loan in this chama")
        }</span>

        // Create loan
        <span class="cov0" title="0">loan := &amp;models.Loan{
                ID:                 uuid.New().String(),
                BorrowerID:         borrowerID,
                ChamaID:            chamaID,
                Type:               application.Type,
                Amount:             application.Amount,
                InterestRate:       0, // Will be set during approval
                Duration:           application.Duration,
                Purpose:            application.Purpose,
                Status:             models.LoanStatusPending,
                TotalAmount:        0, // Will be calculated during approval
                PaidAmount:         0,
                RemainingAmount:    0,
                RequiredGuarantors: application.RequiredGuarantors,
                ApprovedGuarantors: 0,
                CreatedAt:          time.Now(),
                UpdatedAt:          time.Now(),
        }

        // Start transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Insert loan
        loanQuery := `
                INSERT INTO loans (
                        id, borrower_id, chama_id, type, amount, interest_rate, duration,
                        purpose, status, total_amount, paid_amount, remaining_amount,
                        required_guarantors, approved_guarantors, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = tx.Exec(loanQuery,
                loan.ID, loan.BorrowerID, loan.ChamaID, loan.Type, loan.Amount,
                loan.InterestRate, loan.Duration, loan.Purpose, loan.Status,
                loan.TotalAmount, loan.PaidAmount, loan.RemainingAmount,
                loan.RequiredGuarantors, loan.ApprovedGuarantors,
                loan.CreatedAt, loan.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create loan: %w", err)
        }</span>

        // Add guarantors
        <span class="cov0" title="0">for _, guarantorUserID := range application.GuarantorUserIDs </span><span class="cov0" title="0">{
                // Check if guarantor is a chama member
                isGuarantorMember, err := chamaService.IsUserMember(chamaID, guarantorUserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if !isGuarantorMember </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("guarantor %s is not a member of this chama", guarantorUserID)
                }</span>

                <span class="cov0" title="0">guarantor := &amp;models.Guarantor{
                        ID:        uuid.New().String(),
                        LoanID:    loan.ID,
                        UserID:    guarantorUserID,
                        Amount:    application.Amount / float64(len(application.GuarantorUserIDs)),
                        Status:    models.GuarantorStatusPending,
                        CreatedAt: time.Now(),
                }

                guarantorQuery := `
                        INSERT INTO guarantors (id, loan_id, user_id, amount, status, created_at)
                        VALUES (?, ?, ?, ?, ?, ?)
                `

                _, err = tx.Exec(guarantorQuery,
                        guarantor.ID, guarantor.LoanID, guarantor.UserID,
                        guarantor.Amount, guarantor.Status, guarantor.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add guarantor: %w", err)
                }</span>
        }

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        // Send notifications to guarantors
        <span class="cov0" title="0">notificationService := NewNotificationService(s.db, nil)
        for _, guarantorUserID := range application.GuarantorUserIDs </span><span class="cov0" title="0">{
                go func(userID string) </span><span class="cov0" title="0">{
                        title := "Loan Guarantee Request"
                        message := fmt.Sprintf("You have been requested to guarantee a loan of KSh %.2f", application.Amount)
                        data := map[string]interface{}{
                                "type":   "loan_guarantee_request",
                                "loanId": loan.ID,
                                "amount": application.Amount,
                        }
                        notificationService.CreateNotification(userID, "loan", title, message, data, true, true, false)
                }</span>(guarantorUserID)
        }

        <span class="cov0" title="0">return loan, nil</span>
}

// RespondToGuaranteeRequest handles guarantor response
func (s *LoanService) RespondToGuaranteeRequest(loanID, guarantorUserID string, response *models.GuarantorResponse) error <span class="cov0" title="0">{
        // Get guarantor record
        guarantor, err := s.getGuarantor(loanID, guarantorUserID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if guarantor.HasResponded() </span><span class="cov0" title="0">{
                return fmt.Errorf("guarantor has already responded")
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Update guarantor status
        now := time.Now()
        status := models.GuarantorStatusRejected
        if response.Accept </span><span class="cov0" title="0">{
                status = models.GuarantorStatusAccepted
        }</span>

        <span class="cov0" title="0">updateQuery := `
                UPDATE guarantors
                SET status = ?, message = ?, responded_at = ?
                WHERE id = ?
        `

        _, err = tx.Exec(updateQuery, status, response.Message, now, guarantor.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update guarantor: %w", err)
        }</span>

        // Update loan's approved guarantors count if accepted
        <span class="cov0" title="0">if response.Accept </span><span class="cov0" title="0">{
                _, err = tx.Exec(
                        "UPDATE loans SET approved_guarantors = approved_guarantors + 1, updated_at = ? WHERE id = ?",
                        now, loanID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update loan guarantors count: %w", err)
                }</span>
        }

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        // Check if loan now has sufficient guarantors
        <span class="cov0" title="0">loan, err := s.GetLoanByID(loanID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if loan.CanBeApproved() </span><span class="cov0" title="0">{
                // Notify chama leaders that loan is ready for approval
                s.notifyLoanReadyForApproval(loan)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ApproveLoan approves or rejects a loan
func (s *LoanService) ApproveLoan(loanID, approverID string, approval *models.LoanApproval) error <span class="cov0" title="0">{
        // Get loan
        loan, err := s.GetLoanByID(loanID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !loan.IsPending() </span><span class="cov0" title="0">{
                return fmt.Errorf("loan is not pending approval")
        }</span>

        // Check if approver has permission (chairperson or treasurer)
        <span class="cov0" title="0">chamaService := NewChamaService(s.db)
        member, err := chamaService.GetChamaMember(loan.ChamaID, approverID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !member.CanManageFinances() </span><span class="cov0" title="0">{
                return fmt.Errorf("user does not have permission to approve loans")
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        now := time.Now()
        var newStatus models.LoanStatus
        var totalAmount, remainingAmount float64

        if approval.Approved </span><span class="cov0" title="0">{
                newStatus = models.LoanStatusApproved
                loan.InterestRate = approval.InterestRate
                totalAmount = loan.CalculateTotalAmount()
                remainingAmount = totalAmount
        }</span> else<span class="cov0" title="0"> {
                newStatus = models.LoanStatusRejected
                totalAmount = 0
                remainingAmount = 0
        }</span>

        // Update loan
        <span class="cov0" title="0">updateQuery := `
                UPDATE loans
                SET status = ?, interest_rate = ?, total_amount = ?, remaining_amount = ?,
                        approved_by = ?, approved_at = ?, updated_at = ?
                WHERE id = ?
        `

        _, err = tx.Exec(updateQuery,
                newStatus, loan.InterestRate, totalAmount, remainingAmount,
                approverID, now, now, loanID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update loan: %w", err)
        }</span>

        // If approved, disburse funds
        <span class="cov0" title="0">if approval.Approved </span><span class="cov0" title="0">{
                err = s.disburseLoan(tx, loan, totalAmount)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to disburse loan: %w", err)
                }</span>
        }

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        // Send notification to borrower
        <span class="cov0" title="0">notificationService := NewNotificationService(s.db, nil)
        go notificationService.NotifyLoanApproval(loan.BorrowerID, loan.Amount, approval.Approved)

        return nil</span>
}

// MakeLoanPayment processes a loan payment
func (s *LoanService) MakeLoanPayment(loanID, payerID string, amount float64, paymentMethod string) (*models.LoanPayment, error) <span class="cov0" title="0">{
        // Get loan
        loan, err := s.GetLoanByID(loanID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !loan.IsActive() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("loan is not active")
        }</span>

        <span class="cov0" title="0">if loan.BorrowerID != payerID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("only the borrower can make payments")
        }</span>

        <span class="cov0" title="0">if amount &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("payment amount must be positive")
        }</span>

        <span class="cov0" title="0">if amount &gt; loan.RemainingAmount </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("payment amount exceeds remaining balance")
        }</span>

        // Calculate principal and interest portions
        <span class="cov0" title="0">interestPortion := (loan.TotalAmount - loan.Amount) * (amount / loan.TotalAmount)
        principalPortion := amount - interestPortion

        payment := &amp;models.LoanPayment{
                ID:              uuid.New().String(),
                LoanID:          loanID,
                Amount:          amount,
                PrincipalAmount: principalPortion,
                InterestAmount:  interestPortion,
                PaymentMethod:   paymentMethod,
                PaidAt:          time.Now(),
                CreatedAt:       time.Now(),
        }

        // Start transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Insert payment
        paymentQuery := `
                INSERT INTO loan_payments (
                        id, loan_id, amount, principal_amount, interest_amount,
                        payment_method, reference, paid_at, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = tx.Exec(paymentQuery,
                payment.ID, payment.LoanID, payment.Amount, payment.PrincipalAmount,
                payment.InterestAmount, payment.PaymentMethod, payment.Reference,
                payment.PaidAt, payment.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to record payment: %w", err)
        }</span>

        // Update loan
        <span class="cov0" title="0">newPaidAmount := loan.PaidAmount + amount
        newRemainingAmount := loan.RemainingAmount - amount
        newStatus := loan.Status

        if newRemainingAmount &lt;= 0 </span><span class="cov0" title="0">{
                newStatus = models.LoanStatusCompleted
                newRemainingAmount = 0
        }</span>

        <span class="cov0" title="0">updateLoanQuery := `
                UPDATE loans
                SET paid_amount = ?, remaining_amount = ?, status = ?, updated_at = ?
                WHERE id = ?
        `

        _, err = tx.Exec(updateLoanQuery,
                newPaidAmount, newRemainingAmount, newStatus, time.Now(), loanID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update loan: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return payment, nil</span>
}

// GetLoanByID retrieves a loan by ID
func (s *LoanService) GetLoanByID(loanID string) (*models.Loan, error) <span class="cov0" title="0">{
        query := `
                SELECT id, borrower_id, chama_id, type, amount, interest_rate, duration,
                           purpose, status, approved_by, approved_at, disbursed_at, due_date,
                           total_amount, paid_amount, remaining_amount, required_guarantors,
                           approved_guarantors, created_at, updated_at
                FROM loans WHERE id = ?
        `

        loan := &amp;models.Loan{}
        err := s.db.QueryRow(query, loanID).Scan(
                &amp;loan.ID, &amp;loan.BorrowerID, &amp;loan.ChamaID, &amp;loan.Type, &amp;loan.Amount,
                &amp;loan.InterestRate, &amp;loan.Duration, &amp;loan.Purpose, &amp;loan.Status,
                &amp;loan.ApprovedBy, &amp;loan.ApprovedAt, &amp;loan.DisbursedAt, &amp;loan.DueDate,
                &amp;loan.TotalAmount, &amp;loan.PaidAmount, &amp;loan.RemainingAmount,
                &amp;loan.RequiredGuarantors, &amp;loan.ApprovedGuarantors,
                &amp;loan.CreatedAt, &amp;loan.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("loan not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get loan: %w", err)</span>
        }

        <span class="cov0" title="0">return loan, nil</span>
}

// GetChamaLoans retrieves loans for a chama
func (s *LoanService) GetChamaLoans(chamaID string, status *models.LoanStatus, limit, offset int) ([]*models.Loan, error) <span class="cov0" title="0">{
        query := `
                SELECT l.id, l.borrower_id, l.chama_id, l.type, l.amount, l.interest_rate,
                           l.duration, l.purpose, l.status, l.approved_by, l.approved_at,
                           l.disbursed_at, l.due_date, l.total_amount, l.paid_amount,
                           l.remaining_amount, l.required_guarantors, l.approved_guarantors,
                           l.created_at, l.updated_at,
                           u.first_name, u.last_name, u.avatar
                FROM loans l
                INNER JOIN users u ON l.borrower_id = u.id
                WHERE l.chama_id = ?
        `
        args := []interface{}{chamaID}

        if status != nil </span><span class="cov0" title="0">{
                query += " AND l.status = ?"
                args = append(args, *status)
        }</span>

        <span class="cov0" title="0">query += " ORDER BY l.created_at DESC LIMIT ? OFFSET ?"
        args = append(args, limit, offset)

        rows, err := s.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get chama loans: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var loans []*models.Loan
        for rows.Next() </span><span class="cov0" title="0">{
                loan := &amp;models.Loan{}
                borrower := &amp;models.User{}

                err := rows.Scan(
                        &amp;loan.ID, &amp;loan.BorrowerID, &amp;loan.ChamaID, &amp;loan.Type, &amp;loan.Amount,
                        &amp;loan.InterestRate, &amp;loan.Duration, &amp;loan.Purpose, &amp;loan.Status,
                        &amp;loan.ApprovedBy, &amp;loan.ApprovedAt, &amp;loan.DisbursedAt, &amp;loan.DueDate,
                        &amp;loan.TotalAmount, &amp;loan.PaidAmount, &amp;loan.RemainingAmount,
                        &amp;loan.RequiredGuarantors, &amp;loan.ApprovedGuarantors,
                        &amp;loan.CreatedAt, &amp;loan.UpdatedAt,
                        &amp;borrower.FirstName, &amp;borrower.LastName, &amp;borrower.Avatar,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan loan: %w", err)
                }</span>

                <span class="cov0" title="0">borrower.ID = loan.BorrowerID
                loan.Borrower = borrower
                loans = append(loans, loan)</span>
        }

        <span class="cov0" title="0">return loans, nil</span>
}

// Helper methods

func (s *LoanService) hasActiveLoan(borrowerID, chamaID string) (bool, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*) FROM loans
                WHERE borrower_id = ? AND chama_id = ? AND status IN (?, ?)
        `
        var count int
        err := s.db.QueryRow(query, borrowerID, chamaID, models.LoanStatusApproved, models.LoanStatusActive).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check active loans: %w", err)
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (s *LoanService) getGuarantor(loanID, userID string) (*models.Guarantor, error) <span class="cov0" title="0">{
        query := `
                SELECT id, loan_id, user_id, amount, status, message, responded_at, created_at
                FROM guarantors WHERE loan_id = ? AND user_id = ?
        `

        guarantor := &amp;models.Guarantor{}
        err := s.db.QueryRow(query, loanID, userID).Scan(
                &amp;guarantor.ID, &amp;guarantor.LoanID, &amp;guarantor.UserID, &amp;guarantor.Amount,
                &amp;guarantor.Status, &amp;guarantor.Message, &amp;guarantor.RespondedAt, &amp;guarantor.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("guarantor not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get guarantor: %w", err)</span>
        }

        <span class="cov0" title="0">return guarantor, nil</span>
}

func (s *LoanService) disburseLoan(tx *sql.Tx, loan *models.Loan, _ float64) error <span class="cov0" title="0">{
        now := time.Now()
        dueDate := now.AddDate(0, loan.Duration, 0)

        // Update loan with disbursement details
        _, err := tx.Exec(
                "UPDATE loans SET status = ?, disbursed_at = ?, due_date = ? WHERE id = ?",
                models.LoanStatusActive, now, dueDate, loan.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update loan disbursement: %w", err)
        }</span>

        // Transfer funds from chama wallet to borrower's wallet
        // This would integrate with the wallet service
        // For now, we'll just log the transaction

        <span class="cov0" title="0">return nil</span>
}

func (s *LoanService) notifyLoanReadyForApproval(loan *models.Loan) <span class="cov0" title="0">{
        // Get chama leaders
        query := `
                SELECT user_id FROM chama_members
                WHERE chama_id = ? AND role IN (?, ?) AND is_active = true
        `

        rows, err := s.db.Query(query, loan.ChamaID, models.ChamaRoleChairperson, models.ChamaRoleTreasurer)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        notificationService := NewNotificationService(s.db, nil)
        for rows.Next() </span><span class="cov0" title="0">{
                var userID string
                if err := rows.Scan(&amp;userID); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">go func(uid string) </span><span class="cov0" title="0">{
                        title := "Loan Ready for Approval"
                        message := fmt.Sprintf("A loan application for KSh %.2f is ready for your approval", loan.Amount)
                        data := map[string]interface{}{
                                "type":   "loan_approval_needed",
                                "loanId": loan.ID,
                                "amount": loan.Amount,
                        }
                        notificationService.CreateNotification(uid, "loan", title, message, data, true, true, false)
                }</span>(userID)
        }
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "database/sql"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/google/uuid"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/utils"
)

// Cache structure for products
type ProductCache struct {
        Products  []*models.Product `json:"products"`
        Timestamp time.Time         `json:"timestamp"`
        Filters   string            `json:"filters"`
}

// Cache storage
type CacheStore struct {
        mu    sync.RWMutex
        cache map[string]*ProductCache
}

func NewCacheStore() *CacheStore <span class="cov8" title="1">{
        return &amp;CacheStore{
                cache: make(map[string]*ProductCache),
        }
}</span>

func (cs *CacheStore) Get(key string) (*ProductCache, bool) <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()

        cached, exists := cs.cache[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if cache is still valid (5 minutes)
        <span class="cov0" title="0">if time.Since(cached.Timestamp) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return cached, true</span>
}

func (cs *CacheStore) Set(key string, products []*models.Product, filters string) <span class="cov0" title="0">{
        cs.mu.Lock()
        defer cs.mu.Unlock()

        cs.cache[key] = &amp;ProductCache{
                Products:  products,
                Timestamp: time.Now(),
                Filters:   filters,
        }
}</span>

func (cs *CacheStore) Clear() <span class="cov0" title="0">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.cache = make(map[string]*ProductCache)
}</span>

// MarketplaceService handles marketplace-related business logic
type MarketplaceService struct {
        db    *sql.DB
        cache *CacheStore
}

// Global cache instance
var globalCache = NewCacheStore()

// NewMarketplaceService creates a new marketplace service
func NewMarketplaceService(db *sql.DB) *MarketplaceService <span class="cov0" title="0">{
        service := &amp;MarketplaceService{
                db:    db,
                cache: globalCache,
        }

        // Create performance indexes on first initialization
        service.createPerformanceIndexes()

        return service
}</span>

// createPerformanceIndexes creates database indexes for fast product queries
func (s *MarketplaceService) createPerformanceIndexes() <span class="cov0" title="0">{
        indexes := []string{
                "CREATE INDEX IF NOT EXISTS idx_products_status_stock ON products(status, stock)",
                "CREATE INDEX IF NOT EXISTS idx_products_category ON products(category)",
                "CREATE INDEX IF NOT EXISTS idx_products_county ON products(county)",
                "CREATE INDEX IF NOT EXISTS idx_products_chama_id ON products(chama_id)",
                "CREATE INDEX IF NOT EXISTS idx_products_seller_id ON products(seller_id)",
                "CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at DESC)",
                "CREATE INDEX IF NOT EXISTS idx_products_search ON products(name, description)",
                "CREATE INDEX IF NOT EXISTS idx_products_promoted ON products(is_promoted, created_at DESC)",
        }

        for _, indexSQL := range indexes </span><span class="cov0" title="0">{
                if _, err := s.db.Exec(indexSQL); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️ Failed to create index: %v\n", err)
                }</span>
        }
        <span class="cov0" title="0">fmt.Println("✅ Database indexes created for marketplace performance")</span>
}

// CreateProduct creates a new product
func (s *MarketplaceService) CreateProduct(creation *models.ProductCreation, sellerID string, chamaID *string) (*models.Product, error) <span class="cov0" title="0">{
        // Validate input
        if err := utils.ValidateStruct(creation); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        <span class="cov0" title="0">product := &amp;models.Product{
                ID:           uuid.New().String(),
                Name:         creation.Name,
                Description:  creation.Description,
                Category:     creation.Category,
                Price:        creation.Price,
                Currency:     "KES",
                Images:       creation.Images,
                Status:       models.ProductStatusActive,
                Stock:        creation.Stock,
                MinOrder:     creation.MinOrder,
                MaxOrder:     creation.MaxOrder,
                SellerID:     sellerID,
                ChamaID:      chamaID,
                County:       creation.County,
                Town:         creation.Town,
                Address:      creation.Address,
                Tags:         creation.Tags,
                Rating:       0,
                TotalRatings: 0,
                TotalSales:   0,
                IsPromoted:   false,
                CreatedAt:    utils.NowEAT(),
                UpdatedAt:    utils.NowEAT(),
        }

        // Serialize JSON fields
        imagesJSON, err := product.GetImagesJSON()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to serialize images: %w", err)
        }</span>

        <span class="cov0" title="0">tagsJSON, err := product.GetTagsJSON()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to serialize tags: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO products (
                        id, name, description, category, price, currency, images, status,
                        stock, min_order, max_order, seller_id, chama_id, county, town,
                        address, tags, rating, total_ratings, total_sales, is_promoted,
                        created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.Exec(query,
                product.ID, product.Name, product.Description, product.Category,
                product.Price, product.Currency, imagesJSON, product.Status,
                product.Stock, product.MinOrder, product.MaxOrder, product.SellerID,
                product.ChamaID, product.County, product.Town, product.Address,
                tagsJSON, product.Rating, product.TotalRatings, product.TotalSales,
                product.IsPromoted, product.CreatedAt, product.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create product: %w", err)
        }</span>

        <span class="cov0" title="0">return product, nil</span>
}

// GetProductByID retrieves a product by ID with seller information
func (s *MarketplaceService) GetProductByID(productID string) (*models.Product, error) <span class="cov0" title="0">{
        query := `
                SELECT p.id, p.name, p.description, p.category, p.price, p.currency, p.images, p.status,
                           p.stock, p.min_order, p.max_order, p.seller_id, p.chama_id, p.county, p.town,
                           p.address, p.tags, p.rating, p.total_ratings, p.total_sales, p.is_promoted,
                           p.created_at, p.updated_at,
                           u.first_name, u.last_name, u.avatar
                FROM products p
                INNER JOIN users u ON p.seller_id = u.id
                WHERE p.id = ?
        `

        product := &amp;models.Product{}
        seller := &amp;models.User{}
        var imagesJSON, tagsJSON string

        err := s.db.QueryRow(query, productID).Scan(
                &amp;product.ID, &amp;product.Name, &amp;product.Description, &amp;product.Category,
                &amp;product.Price, &amp;product.Currency, &amp;imagesJSON, &amp;product.Status,
                &amp;product.Stock, &amp;product.MinOrder, &amp;product.MaxOrder, &amp;product.SellerID,
                &amp;product.ChamaID, &amp;product.County, &amp;product.Town, &amp;product.Address,
                &amp;tagsJSON, &amp;product.Rating, &amp;product.TotalRatings, &amp;product.TotalSales,
                &amp;product.IsPromoted, &amp;product.CreatedAt, &amp;product.UpdatedAt,
                &amp;seller.FirstName, &amp;seller.LastName, &amp;seller.Avatar,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("product not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get product: %w", err)</span>
        }

        // Parse JSON fields
        <span class="cov0" title="0">if err = product.SetImagesFromJSON(imagesJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse images: %w", err)
        }</span>
        <span class="cov0" title="0">if err = product.SetTagsFromJSON(tagsJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse tags: %w", err)
        }</span>

        // Set seller information
        <span class="cov0" title="0">seller.ID = product.SellerID
        product.Seller = seller

        return product, nil</span>
}

// generateCacheKey creates a unique cache key for the given filters
func (s *MarketplaceService) generateCacheKey(filters map[string]interface{}, limit, offset int) string <span class="cov0" title="0">{
        // Convert filters to JSON for consistent key generation
        filtersJSON, _ := json.Marshal(filters)
        keyData := fmt.Sprintf("%s_%d_%d", string(filtersJSON), limit, offset)
        return fmt.Sprintf("%x", md5.Sum([]byte(keyData)))
}</span>

// GetProducts retrieves products with filters (only in-stock products) with caching
func (s *MarketplaceService) GetProducts(filters map[string]interface{}, limit, offset int) ([]*models.Product, error) <span class="cov0" title="0">{
        // Generate cache key
        cacheKey := s.generateCacheKey(filters, limit, offset)

        // Try to get from cache first
        if cached, found := s.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                fmt.Printf("🚀 Cache HIT for products query: %s\n", cacheKey[:8])
                return cached.Products, nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("💾 Cache MISS for products query: %s\n", cacheKey[:8])

        // Ultra-optimized query for billion-scale database
        query := `
                SELECT p.id, p.name, p.category, p.price, p.currency,
                           COALESCE(p.images, '[]') as images, p.stock, p.seller_id,
                           u.first_name, u.last_name
                FROM products p
                INNER JOIN users u ON p.seller_id = u.id
                WHERE p.status = ? AND p.stock &gt; 0
        `
        args := []interface{}{models.ProductStatusActive}

        // Add filters
        if category, ok := filters["category"]; ok </span><span class="cov0" title="0">{
                query += " AND p.category = ?"
                args = append(args, category)
        }</span>
        <span class="cov0" title="0">if county, ok := filters["county"]; ok </span><span class="cov0" title="0">{
                query += " AND p.county = ?"
                args = append(args, county)
        }</span>
        <span class="cov0" title="0">if chamaID, ok := filters["chamaId"]; ok </span><span class="cov0" title="0">{
                query += " AND p.chama_id = ?"
                args = append(args, chamaID)
        }</span>
        <span class="cov0" title="0">if search, ok := filters["search"]; ok </span><span class="cov0" title="0">{
                query += " AND (p.name LIKE ? OR p.description LIKE ?)"
                searchTerm := "%" + search.(string) + "%"
                args = append(args, searchTerm, searchTerm)
        }</span>

        <span class="cov0" title="0">query += " ORDER BY p.created_at DESC LIMIT ? OFFSET ?"
        args = append(args, limit, offset)

        // Add query timeout to prevent hanging (reduced for billion-scale)
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()

        // Log query performance
        startTime := time.Now()
        rows, err := s.db.QueryContext(ctx, query, args...)
        queryTime := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                if err == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️ Query timeout after 2s - query too slow for billion-scale\n")
                        return nil, fmt.Errorf("query timeout: products query took too long")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get products: %w", err)</span>
        }
        <span class="cov0" title="0">defer rows.Close()

        fmt.Printf("⚡ Query executed in %v\n", queryTime)

        var products []*models.Product
        for rows.Next() </span><span class="cov0" title="0">{
                product := &amp;models.Product{}
                seller := &amp;models.User{}
                var imagesJSON, tagsJSON string

                err := rows.Scan(
                        &amp;product.ID, &amp;product.Name, &amp;product.Category, &amp;product.Price,
                        &amp;product.Currency, &amp;imagesJSON, &amp;product.Stock, &amp;product.SellerID,
                        &amp;seller.FirstName, &amp;seller.LastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan product: %w", err)
                }</span>

                // Parse JSON fields
                <span class="cov0" title="0">if err = product.SetImagesFromJSON(imagesJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse images: %w", err)
                }</span>
                <span class="cov0" title="0">if err = product.SetTagsFromJSON(tagsJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse tags: %w", err)
                }</span>

                <span class="cov0" title="0">seller.ID = product.SellerID
                product.Seller = seller
                products = append(products, product)</span>
        }

        // Store in cache for future requests
        <span class="cov0" title="0">filtersJSON, _ := json.Marshal(filters)
        s.cache.Set(cacheKey, products, string(filtersJSON))
        fmt.Printf("💾 Cached %d products for key: %s\n", len(products), cacheKey[:8])

        return products, nil</span>
}

// GetAllProducts retrieves all products including out of stock (for admin/seller use)
func (s *MarketplaceService) GetAllProducts(filters map[string]interface{}, limit, offset int) ([]*models.Product, error) <span class="cov0" title="0">{
        query := `
                SELECT p.id, p.name, p.description, p.category, p.price, p.currency, p.images, p.status,
                           p.stock, p.min_order, p.max_order, p.seller_id, p.chama_id, p.county, p.town,
                           p.address, p.tags, p.rating, p.total_ratings, p.total_sales, p.is_promoted,
                           p.created_at, p.updated_at,
                           u.first_name, u.last_name, u.avatar
                FROM products p
                INNER JOIN users u ON p.seller_id = u.id
                WHERE p.status = ?
        `
        args := []interface{}{models.ProductStatusActive}

        // Add filters (same as GetProducts but without stock filter)
        if category, ok := filters["category"]; ok </span><span class="cov0" title="0">{
                query += " AND p.category = ?"
                args = append(args, category)
        }</span>
        <span class="cov0" title="0">if county, ok := filters["county"]; ok </span><span class="cov0" title="0">{
                query += " AND p.county = ?"
                args = append(args, county)
        }</span>
        <span class="cov0" title="0">if chamaID, ok := filters["chamaId"]; ok </span><span class="cov0" title="0">{
                query += " AND p.chama_id = ?"
                args = append(args, chamaID)
        }</span>
        <span class="cov0" title="0">if sellerID, ok := filters["sellerId"]; ok </span><span class="cov0" title="0">{
                query += " AND p.seller_id = ?"
                args = append(args, sellerID)
        }</span>
        <span class="cov0" title="0">if search, ok := filters["search"]; ok </span><span class="cov0" title="0">{
                query += " AND (p.name LIKE ? OR p.description LIKE ?)"
                searchTerm := "%" + search.(string) + "%"
                args = append(args, searchTerm, searchTerm)
        }</span>

        <span class="cov0" title="0">query += " ORDER BY p.created_at DESC LIMIT ? OFFSET ?"
        args = append(args, limit, offset)

        rows, err := s.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all products: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var products []*models.Product
        for rows.Next() </span><span class="cov0" title="0">{
                product := &amp;models.Product{}
                seller := &amp;models.User{}
                var imagesJSON, tagsJSON string

                err := rows.Scan(
                        &amp;product.ID, &amp;product.Name, &amp;product.Description, &amp;product.Category,
                        &amp;product.Price, &amp;product.Currency, &amp;imagesJSON, &amp;product.Status,
                        &amp;product.Stock, &amp;product.MinOrder, &amp;product.MaxOrder, &amp;product.SellerID,
                        &amp;product.ChamaID, &amp;product.County, &amp;product.Town, &amp;product.Address,
                        &amp;tagsJSON, &amp;product.Rating, &amp;product.TotalRatings, &amp;product.TotalSales,
                        &amp;product.IsPromoted, &amp;product.CreatedAt, &amp;product.UpdatedAt,
                        &amp;seller.FirstName, &amp;seller.LastName, &amp;seller.Avatar,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan product: %w", err)
                }</span>

                // Parse JSON fields
                <span class="cov0" title="0">if err := product.SetImagesFromJSON(imagesJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse images: %w", err)
                }</span>
                <span class="cov0" title="0">if err := product.SetTagsFromJSON(tagsJSON); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse tags: %w", err)
                }</span>

                // Set seller information
                <span class="cov0" title="0">seller.ID = product.SellerID
                product.Seller = seller

                products = append(products, product)</span>
        }

        <span class="cov0" title="0">return products, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package services

import (
        "crypto/rand"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "fmt"
        "log"
        "net/url"
        "os"
        "regexp"
        "strings"
        "time"

        "github.com/google/uuid"
)

// MeetingService handles meeting-related operations
type MeetingService struct {
        db              *sql.DB
        livekitService  *LiveKitService
        calendarService *CalendarService
        roomGenerator   *RoomNameGenerator
}

// RoomNameGenerator provides methods for generating consistent room names
type RoomNameGenerator struct{}

// NewRoomNameGenerator creates a new room name generator
func NewRoomNameGenerator() *RoomNameGenerator <span class="cov0" title="0">{
        return &amp;RoomNameGenerator{}
}</span>

// GenerateRoomName generates a consistent room name for a meeting
func (g *RoomNameGenerator) GenerateRoomName(chamaID, meetingID string) string <span class="cov0" title="0">{
        // Clean the IDs to ensure they're safe for room names
        cleanChamaID := g.cleanID(chamaID)
        cleanMeetingID := g.cleanID(meetingID)

        roomName := fmt.Sprintf("chama_%s_meeting_%s", cleanChamaID, cleanMeetingID)

        // Ensure the room name is valid (alphanumeric, hyphens, underscores only)
        return g.sanitizeRoomName(roomName)
}</span>

// cleanID removes special characters and keeps only alphanumeric and safe characters
func (g *RoomNameGenerator) cleanID(id string) string <span class="cov0" title="0">{
        // Remove common prefixes
        id = strings.TrimPrefix(id, "meeting-")
        id = strings.TrimPrefix(id, "chama-")

        // Keep only alphanumeric characters and hyphens
        reg := regexp.MustCompile(`[^a-zA-Z0-9\-]`)
        cleaned := reg.ReplaceAllString(id, "")

        // Remove consecutive hyphens
        reg = regexp.MustCompile(`-+`)
        cleaned = reg.ReplaceAllString(cleaned, "-")

        // Trim hyphens from start and end
        cleaned = strings.Trim(cleaned, "-")

        return cleaned
}</span>

// sanitizeRoomName ensures the room name meets LiveKit requirements
func (g *RoomNameGenerator) sanitizeRoomName(roomName string) string <span class="cov0" title="0">{
        // LiveKit room names should be alphanumeric with underscores and hyphens
        reg := regexp.MustCompile(`[^a-zA-Z0-9_\-]`)
        sanitized := reg.ReplaceAllString(roomName, "_")

        // Remove consecutive underscores
        reg = regexp.MustCompile(`_+`)
        sanitized = reg.ReplaceAllString(sanitized, "_")

        // Trim underscores from start and end
        sanitized = strings.Trim(sanitized, "_-")

        // Ensure minimum length
        if len(sanitized) &lt; 3 </span><span class="cov0" title="0">{
                sanitized = sanitized + "_room"
        }</span>

        // Ensure maximum length (LiveKit has limits)
        <span class="cov0" title="0">if len(sanitized) &gt; 63 </span><span class="cov0" title="0">{
                sanitized = sanitized[:63]
        }</span>

        <span class="cov0" title="0">return sanitized</span>
}

// NewMeetingService creates a new meeting service instance
func NewMeetingService(db *sql.DB, livekitService *LiveKitService, calendarService *CalendarService) *MeetingService <span class="cov0" title="0">{
        return &amp;MeetingService{
                db:              db,
                livekitService:  livekitService,
                calendarService: calendarService,
                roomGenerator:   NewRoomNameGenerator(),
        }
}</span>

// Meeting represents a meeting with LiveKit integration
type Meeting struct {
        ID               string     `json:"id"`
        ChamaID          string     `json:"chamaId"`
        Title            string     `json:"title"`
        Description      string     `json:"description"`
        ScheduledAt      time.Time  `json:"scheduledAt"`
        Duration         int        `json:"duration"`
        Location         string     `json:"location"`
        MeetingURL       string     `json:"meetingUrl"`
        MeetingType      string     `json:"meetingType"`
        LiveKitRoomName  string     `json:"livekitRoomName"`
        LiveKitRoomID    string     `json:"livekitRoomId"`
        Status           string     `json:"status"`
        StartedAt        *time.Time `json:"startedAt"`
        EndedAt          *time.Time `json:"endedAt"`
        RecordingEnabled bool       `json:"recordingEnabled"`
        RecordingURL     *string    `json:"recordingUrl"`
        TranscriptURL    *string    `json:"transcriptUrl"`
        CreatedBy        string     `json:"createdBy"`
        CreatedAt        time.Time  `json:"createdAt"`
        UpdatedAt        time.Time  `json:"updatedAt"`
}

// MeetingAttendance represents attendance tracking
type MeetingAttendance struct {
        ID              string     `json:"id"`
        MeetingID       string     `json:"meetingId"`
        UserID          string     `json:"userId"`
        AttendanceType  string     `json:"attendanceType"`
        JoinedAt        *time.Time `json:"joinedAt"`
        LeftAt          *time.Time `json:"leftAt"`
        DurationMinutes int        `json:"durationMinutes"`
        IsPresent       bool       `json:"isPresent"`
        Notes           string     `json:"notes"`
        CreatedAt       time.Time  `json:"createdAt"`
        UpdatedAt       time.Time  `json:"updatedAt"`
}

// CreateVirtualMeeting creates a new virtual meeting with LiveKit room
func (s *MeetingService) CreateVirtualMeeting(meeting *Meeting) error <span class="cov0" title="0">{
        // Generate unique room name using the room generator
        roomName := s.roomGenerator.GenerateRoomName(meeting.ChamaID, meeting.ID)
        meeting.LiveKitRoomName = roomName

        log.Printf("Generated room name for meeting %s: %s", meeting.ID, roomName)

        // Create LiveKit room if it's a virtual or hybrid meeting
        if meeting.MeetingType == "virtual" || meeting.MeetingType == "hybrid" </span><span class="cov0" title="0">{
                room, err := s.livekitService.CreateRoom(roomName, 50) // Max 50 participants
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create LiveKit room: %w", err)
                }</span>
                <span class="cov0" title="0">meeting.LiveKitRoomID = room.Sid</span>
        }

        // Save meeting to database
        <span class="cov0" title="0">query := `
                INSERT INTO meetings (
                        id, chama_id, title, description, scheduled_at, duration, location,
                        meeting_url, meeting_type, livekit_room_name, livekit_room_id,
                        status, recording_enabled, created_by, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `

        _, err := s.db.Exec(query,
                meeting.ID, meeting.ChamaID, meeting.Title, meeting.Description,
                meeting.ScheduledAt, meeting.Duration, meeting.Location,
                meeting.MeetingURL, meeting.MeetingType, meeting.LiveKitRoomName,
                meeting.LiveKitRoomID, meeting.Status, meeting.RecordingEnabled,
                meeting.CreatedBy,
        )
        if err != nil </span><span class="cov0" title="0">{
                // Clean up LiveKit room if database insert fails
                if meeting.LiveKitRoomName != "" </span><span class="cov0" title="0">{
                        s.livekitService.DeleteRoom(meeting.LiveKitRoomName)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to save meeting: %w", err)</span>
        }

        <span class="cov0" title="0">log.Printf("Created meeting: %s with LiveKit room: %s", meeting.ID, meeting.LiveKitRoomName)
        return nil</span>
}

// CreateMeetingWithCalendar creates a new meeting with LiveKit room and Google Calendar integration
func (s *MeetingService) CreateMeetingWithCalendar(meeting *Meeting, attendeeEmails []string, calendarID string) error <span class="cov0" title="0">{
        // First create the virtual meeting
        err := s.CreateVirtualMeeting(meeting)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create Google Calendar event if calendar service is available
        <span class="cov0" title="0">if s.calendarService != nil &amp;&amp; calendarID != "" &amp;&amp; len(attendeeEmails) &gt; 0 </span><span class="cov0" title="0">{
                calendarEvent, err := s.calendarService.CreateMeetingEvent(calendarID, meeting, attendeeEmails)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the meeting creation
                        log.Printf("Failed to create calendar event: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Created calendar event: %s for meeting: %s", calendarEvent.Id, meeting.ID)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// StartMeeting starts a meeting and updates its status
func (s *MeetingService) StartMeeting(meetingID string) error <span class="cov0" title="0">{
        now := time.Now()

        query := `
                UPDATE meetings 
                SET status = 'active', started_at = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ? AND status = 'scheduled'
        `

        result, err := s.db.Exec(query, now, meetingID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start meeting: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("meeting not found or already started")
        }</span>

        <span class="cov0" title="0">log.Printf("Started meeting: %s", meetingID)
        return nil</span>
}

// EndMeeting ends a meeting and updates its status
func (s *MeetingService) EndMeeting(meetingID string) error <span class="cov0" title="0">{
        now := time.Now()

        // Get meeting details first
        meeting, err := s.GetMeeting(meetingID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get meeting: %w", err)
        }</span>

        // Update meeting status
        <span class="cov0" title="0">query := `
                UPDATE meetings 
                SET status = 'ended', ended_at = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ? AND status = 'active'
        `

        result, err := s.db.Exec(query, now, meetingID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to end meeting: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("meeting not found or not active")
        }</span>

        // Delete LiveKit room if it exists
        <span class="cov0" title="0">if meeting.LiveKitRoomName != "" </span><span class="cov0" title="0">{
                err = s.livekitService.DeleteRoom(meeting.LiveKitRoomName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to delete LiveKit room %s: %v", meeting.LiveKitRoomName, err)
                }</span>
        }

        <span class="cov0" title="0">log.Printf("Ended meeting: %s", meetingID)
        return nil</span>
}

// GetMeeting retrieves a meeting by ID
func (s *MeetingService) GetMeeting(meetingID string) (*Meeting, error) <span class="cov0" title="0">{
        log.Printf("Attempting to get meeting with ID: %s", meetingID)

        query := `
                SELECT id, chama_id, title, description, scheduled_at, duration, location,
                           meeting_url, meeting_type, livekit_room_name, livekit_room_id,
                           status, started_at, ended_at, recording_enabled, recording_url,
                           transcript_url, created_by, created_at, updated_at
                FROM meetings
                WHERE id = ?
        `

        row := s.db.QueryRow(query, meetingID)

        meeting := &amp;Meeting{}
        var startedAt, endedAt sql.NullTime
        var recordingURL, transcriptURL, livekitRoomName, livekitRoomID sql.NullString

        err := row.Scan(
                &amp;meeting.ID, &amp;meeting.ChamaID, &amp;meeting.Title, &amp;meeting.Description,
                &amp;meeting.ScheduledAt, &amp;meeting.Duration, &amp;meeting.Location,
                &amp;meeting.MeetingURL, &amp;meeting.MeetingType, &amp;livekitRoomName,
                &amp;livekitRoomID, &amp;meeting.Status, &amp;startedAt, &amp;endedAt,
                &amp;meeting.RecordingEnabled, &amp;recordingURL, &amp;transcriptURL,
                &amp;meeting.CreatedBy, &amp;meeting.CreatedAt, &amp;meeting.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error scanning meeting %s: %v", meetingID, err)
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("meeting not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get meeting: %w", err)</span>
        }

        <span class="cov0" title="0">log.Printf("Successfully retrieved meeting %s: type=%s, title=%s", meetingID, meeting.MeetingType, meeting.Title)

        if startedAt.Valid </span><span class="cov0" title="0">{
                meeting.StartedAt = &amp;startedAt.Time
        }</span>
        <span class="cov0" title="0">if endedAt.Valid </span><span class="cov0" title="0">{
                meeting.EndedAt = &amp;endedAt.Time
        }</span>

        // Handle nullable string fields
        <span class="cov0" title="0">if recordingURL.Valid </span><span class="cov0" title="0">{
                meeting.RecordingURL = &amp;recordingURL.String
        }</span>
        <span class="cov0" title="0">if transcriptURL.Valid </span><span class="cov0" title="0">{
                meeting.TranscriptURL = &amp;transcriptURL.String
        }</span>
        <span class="cov0" title="0">if livekitRoomName.Valid </span><span class="cov0" title="0">{
                meeting.LiveKitRoomName = livekitRoomName.String
        }</span>
        <span class="cov0" title="0">if livekitRoomID.Valid </span><span class="cov0" title="0">{
                meeting.LiveKitRoomID = livekitRoomID.String
        }</span>

        <span class="cov0" title="0">return meeting, nil</span>
}

// GenerateJoinToken generates a LiveKit access token for a user to join a meeting
func (s *MeetingService) GenerateJoinToken(meetingID, userID, userRole string) (string, error) <span class="cov0" title="0">{
        meeting, err := s.GetMeeting(meetingID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if meeting.LiveKitRoomName == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("meeting does not have a LiveKit room")
        }</span>

        // Generate participant name (you might want to get actual user name from database)
        <span class="cov0" title="0">participantName := fmt.Sprintf("user_%s", userID)

        token, err := s.livekitService.GenerateAccessToken(
                meeting.LiveKitRoomName,
                participantName,
                userRole,
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate join token: %w", err)
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

// GeneratePreviewToken generates a special preview token for chairpersons and secretaries
func (s *MeetingService) GeneratePreviewToken(meetingID, userID, userRole string) (string, error) <span class="cov0" title="0">{
        meeting, err := s.GetMeeting(meetingID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Only allow chairpersons and secretaries to preview
        <span class="cov0" title="0">if userRole != "chairperson" &amp;&amp; userRole != "secretary" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("only chairpersons and secretaries can preview meetings")
        }</span>

        // For physical meetings, we don't need LiveKit tokens
        <span class="cov0" title="0">if meeting.MeetingType == "physical" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("physical meetings do not require LiveKit tokens")
        }</span>

        <span class="cov0" title="0">if meeting.LiveKitRoomName == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("meeting does not have a LiveKit room")
        }</span>

        // Generate preview token with admin privileges
        <span class="cov0" title="0">token, err := s.livekitService.GenerateAccessToken(meeting.LiveKitRoomName, userID, userRole)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate preview token: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Generated preview token for user %s (role: %s) in meeting %s", userID, userRole, meetingID)
        return token, nil</span>
}

// GetMeetingPreviewInfo returns information needed for meeting preview
func (s *MeetingService) GetMeetingPreviewInfo(meetingID, userID, userRole string) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Only allow chairpersons, secretaries, and treasurers to preview
        if userRole != "chairperson" &amp;&amp; userRole != "secretary" &amp;&amp; userRole != "treasurer" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("only chairpersons, secretaries, and treasurers can preview meetings")
        }</span>

        <span class="cov0" title="0">meeting, err := s.GetMeeting(meetingID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">previewInfo := map[string]interface{}{
                "meeting":   meeting,
                "isPreview": true,
                "userRole":  userRole,
                "canRecord": userRole == "chairperson",
                "canMute":   true,
                "canKick":   userRole == "chairperson",
        }

        // Handle different meeting types
        switch meeting.MeetingType </span>{
        case "virtual", "hybrid":<span class="cov0" title="0">
                // For virtual/hybrid meetings, check if LiveKit room exists
                if meeting.LiveKitRoomName == "" </span><span class="cov0" title="0">{
                        // Create LiveKit room on-demand for preview using room generator
                        roomName := s.roomGenerator.GenerateRoomName(meeting.ChamaID, meeting.ID)
                        log.Printf("Generating room name for preview: %s", roomName)
                        room, err := s.livekitService.CreateRoom(roomName, 50)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: Failed to create LiveKit room for preview: %v", err)
                                // Fallback to basic virtual meeting preview without LiveKit
                                previewInfo["meetingType"] = "virtual"
                                previewInfo["previewMessage"] = "This is a virtual meeting. LiveKit room will be created when the meeting starts."
                                previewInfo["meetingUrl"] = meeting.MeetingURL
                                previewInfo["fallbackMode"] = true
                        }</span> else<span class="cov0" title="0"> {
                                // Update meeting with LiveKit room info
                                meeting.LiveKitRoomName = roomName
                                meeting.LiveKitRoomID = room.Sid

                                // Update database with LiveKit room info
                                updateQuery := `
                                        UPDATE meetings
                                        SET livekit_room_name = ?, livekit_room_id = ?, updated_at = CURRENT_TIMESTAMP
                                        WHERE id = ?
                                `
                                _, err = s.db.Exec(updateQuery, roomName, room.Sid, meeting.ID)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Warning: Failed to update meeting with LiveKit room info: %v", err)
                                }</span>

                                // Generate preview token using the room name directly
                                <span class="cov0" title="0">token, err := s.livekitService.GenerateAccessToken(roomName, userID, userRole)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Warning: Failed to generate preview token: %v", err)
                                        return nil, fmt.Errorf("failed to generate preview token: %w", err)
                                }</span>

                                // Get LiveKit WebSocket URL
                                <span class="cov0" title="0">wsURL := s.livekitService.GetWSURL()

                                previewInfo["accessToken"] = token
                                previewInfo["wsURL"] = wsURL
                                previewInfo["roomName"] = meeting.LiveKitRoomName
                                previewInfo["meetingType"] = "virtual"</span>
                        }
                } else<span class="cov0" title="0"> {
                        // LiveKit room already exists
                        // Generate preview token using the existing room name
                        token, err := s.livekitService.GenerateAccessToken(meeting.LiveKitRoomName, userID, userRole)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: Failed to generate preview token for existing room: %v", err)
                                return nil, fmt.Errorf("failed to generate preview token: %w", err)
                        }</span>

                        // Get LiveKit WebSocket URL
                        <span class="cov0" title="0">wsURL := s.livekitService.GetWSURL()

                        previewInfo["accessToken"] = token
                        previewInfo["wsURL"] = wsURL
                        previewInfo["roomName"] = meeting.LiveKitRoomName
                        previewInfo["meetingType"] = "virtual"</span>
                }

        case "physical":<span class="cov0" title="0">
                // For physical meetings, provide location and setup info
                previewInfo["meetingType"] = "physical"
                previewInfo["location"] = meeting.Location
                previewInfo["previewMessage"] = "This is a physical meeting. Use this preview to review meeting details and prepare for the session."
                previewInfo["setupInstructions"] = []string{
                        "Ensure the meeting venue is properly set up",
                        "Check that all necessary materials are available",
                        "Verify attendance tracking is ready",
                        "Prepare meeting agenda and documents",
                }</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported meeting type: %s", meeting.MeetingType)</span>
        }

        <span class="cov0" title="0">return previewInfo, nil</span>
}

// MarkAttendance marks a user's attendance for a meeting
func (s *MeetingService) MarkAttendance(meetingID, userID, attendanceType string, isPresent bool) error <span class="cov0" title="0">{
        attendanceID := uuid.New().String()
        now := time.Now()

        query := `
                INSERT OR REPLACE INTO meeting_attendance (
                        id, meeting_id, user_id, attendance_type, joined_at, is_present,
                        created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `

        _, err := s.db.Exec(query, attendanceID, meetingID, userID, attendanceType, now, isPresent)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark attendance: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Marked attendance for user %s in meeting %s", userID, meetingID)
        return nil</span>
}

// GetMeetingAttendance retrieves attendance records for a meeting
func (s *MeetingService) GetMeetingAttendance(meetingID string) ([]*MeetingAttendance, error) <span class="cov0" title="0">{
        query := `
                SELECT id, meeting_id, user_id, attendance_type, joined_at, left_at,
                           duration_minutes, is_present, notes, created_at, updated_at
                FROM meeting_attendance
                WHERE meeting_id = ?
                ORDER BY joined_at DESC
        `

        rows, err := s.db.Query(query, meetingID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get meeting attendance: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var attendances []*MeetingAttendance

        for rows.Next() </span><span class="cov0" title="0">{
                attendance := &amp;MeetingAttendance{}
                var joinedAt, leftAt sql.NullTime

                err := rows.Scan(
                        &amp;attendance.ID, &amp;attendance.MeetingID, &amp;attendance.UserID,
                        &amp;attendance.AttendanceType, &amp;joinedAt, &amp;leftAt,
                        &amp;attendance.DurationMinutes, &amp;attendance.IsPresent, &amp;attendance.Notes,
                        &amp;attendance.CreatedAt, &amp;attendance.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan attendance: %w", err)
                }</span>

                <span class="cov0" title="0">if joinedAt.Valid </span><span class="cov0" title="0">{
                        attendance.JoinedAt = &amp;joinedAt.Time
                }</span>
                <span class="cov0" title="0">if leftAt.Valid </span><span class="cov0" title="0">{
                        attendance.LeftAt = &amp;leftAt.Time
                }</span>

                <span class="cov0" title="0">attendances = append(attendances, attendance)</span>
        }

        <span class="cov0" title="0">return attendances, nil</span>
}

// EnsureVirtualMeetingsHaveRoomNames ensures all virtual meetings have proper room names
func (s *MeetingService) EnsureVirtualMeetingsHaveRoomNames() error <span class="cov0" title="0">{
        log.Printf("Ensuring all virtual meetings have room names...")

        // Find all virtual/hybrid meetings without room names
        query := `
                SELECT id, chama_id, title, meeting_type
                FROM meetings
                WHERE (meeting_type = 'virtual' OR meeting_type = 'hybrid')
                AND (livekit_room_name IS NULL OR livekit_room_name = '')
        `

        rows, err := s.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query meetings without room names: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        updateCount := 0
        for rows.Next() </span><span class="cov0" title="0">{
                var meetingID, chamaID, title, meetingType string
                err := rows.Scan(&amp;meetingID, &amp;chamaID, &amp;title, &amp;meetingType)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning meeting: %v", err)
                        continue</span>
                }

                // Generate room name
                <span class="cov0" title="0">roomName := s.roomGenerator.GenerateRoomName(chamaID, meetingID)

                // Update the meeting with the room name
                updateQuery := `
                        UPDATE meetings
                        SET livekit_room_name = ?, updated_at = CURRENT_TIMESTAMP
                        WHERE id = ?
                `

                _, err = s.db.Exec(updateQuery, roomName, meetingID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to update room name for meeting %s: %v", meetingID, err)
                        continue</span>
                }

                <span class="cov0" title="0">log.Printf("Updated meeting %s (%s) with room name: %s", meetingID, title, roomName)
                updateCount++</span>
        }

        <span class="cov0" title="0">log.Printf("Updated %d meetings with room names", updateCount)
        return nil</span>
}

// JitsiRoomData represents the data needed to join a Jitsi Meet room
type JitsiRoomData struct {
        RoomName     string `json:"roomName"`
        JoinURL      string `json:"joinUrl"`
        RoomPassword string `json:"roomPassword"`
        IsModerator  bool   `json:"isModerator"`
        DisplayName  string `json:"displayName"`
        UserEmail    string `json:"userEmail"`
}

// GenerateJitsiRoomData generates Jitsi Meet room data for a user to join a meeting
func (s *MeetingService) GenerateJitsiRoomData(meetingID, userID, userRole string) (*JitsiRoomData, error) <span class="cov0" title="0">{
        meeting, err := s.GetMeeting(meetingID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // SECURITY CHECK: Verify user is a member of the chama that owns this meeting
        <span class="cov0" title="0">isMember, err := s.verifyUserChamaMembership(userID, meeting.ChamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify chama membership: %w", err)
        }</span>
        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied: user is not a member of this chama")
        }</span>

        // Get actual user information from database
        <span class="cov0" title="0">var displayName, userEmail string

        userQuery := `
                SELECT first_name, last_name, username, email
                FROM users
                WHERE id = ?
        `
        var firstName, lastName, username, email sql.NullString
        err = s.db.QueryRow(userQuery, userID).Scan(&amp;firstName, &amp;lastName, &amp;username, &amp;email)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not fetch user details for %s: %v", userID, err)
                // Fallback to basic user data
                displayName = fmt.Sprintf("User_%s", userID)
                userEmail = fmt.Sprintf("user_%s@vaultke.app", userID)
        }</span> else<span class="cov0" title="0"> {
                // Build proper display name from user data
                displayName = buildUserDisplayName(firstName.String, lastName.String, username.String)
                userEmail = email.String
                if userEmail == "" </span><span class="cov0" title="0">{
                        userEmail = fmt.Sprintf("user_%s@vaultke.app", userID)
                }</span>
        }

        // Generate secure room name if not already set
        <span class="cov0" title="0">roomName := meeting.LiveKitRoomName // Reuse the room name field
        if roomName == "" </span><span class="cov0" title="0">{
                // Generate highly secure room name with chama isolation
                timestamp := time.Now().Unix()
                randomSuffix := generateSecureRandomString(8)
                roomName = fmt.Sprintf("vaultke_chama_%s_meeting_%s_%d_%s",
                        meeting.ChamaID, meeting.ID, timestamp, randomSuffix)

                // Update the meeting with the room name
                updateQuery := `UPDATE meetings SET livekit_room_name = ? WHERE id = ?`
                _, err = s.db.Exec(updateQuery, roomName, meetingID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to update meeting with room name: %v", err)
                }</span>
        }

        // Generate room password using a deterministic method
        <span class="cov0" title="0">roomPassword := s.generateJitsiRoomPassword(roomName, userRole)

        // Determine if user should be a moderator (chairperson, secretary, treasurer)
        isModerator := userRole == "chairperson" || userRole == "secretary" || userRole == "treasurer"

        // Build Jitsi Meet URL
        joinURL := s.buildJitsiMeetURL(roomName, displayName, userEmail, roomPassword, isModerator)

        jitsiData := &amp;JitsiRoomData{
                RoomName:     roomName,
                JoinURL:      joinURL,
                RoomPassword: roomPassword,
                IsModerator:  isModerator,
                DisplayName:  displayName,
                UserEmail:    userEmail,
        }

        log.Printf("Generated Jitsi room data for user %s (role: %s) in meeting %s", userID, userRole, meetingID)
        return jitsiData, nil</span>
}

// generateJitsiRoomPassword generates a secure room password
func (s *MeetingService) generateJitsiRoomPassword(roomName, userRole string) string <span class="cov0" title="0">{
        // Create a deterministic but secure password
        // In production, you might want to use a more sophisticated method
        hash := fmt.Sprintf("%x", sha256.Sum256([]byte(roomName+userRole+"vaultke-secret")))
        return hash[:12] // Use first 12 characters
}</span>

// buildJitsiMeetURL builds the complete Jitsi Meet URL with parameters
func (s *MeetingService) buildJitsiMeetURL(roomName, displayName, userEmail, roomPassword string, isModerator bool) string <span class="cov0" title="0">{
        // Use Jitsi as a Service (JaaS) for full control
        jitsiAppID := os.Getenv("JITSI_APP_ID")
        jitsiDomain := os.Getenv("JITSI_DOMAIN")

        if jitsiAppID != "" &amp;&amp; jitsiDomain != "" </span><span class="cov0" title="0">{
                // Use JaaS with your App ID for complete control
                return s.buildJaaSURL(roomName, displayName, userEmail, isModerator)
        }</span>

        // Fallback to public Jitsi Meet (not recommended for production)
        <span class="cov0" title="0">baseURL := "https://meet.jit.si"
        encodedRoomName := url.QueryEscape(roomName)

        // Build URL with query parameters
        params := url.Values{}

        // USER IDENTITY - Pre-populate with system data
        params.Add("userInfo.displayName", displayName)
        params.Add("userInfo.email", userEmail)

        // MEETING BEHAVIOR
        params.Add("config.startWithAudioMuted", "false")
        params.Add("config.startWithVideoMuted", "false")
        params.Add("config.requireDisplayName", "true")
        params.Add("config.enableWelcomePage", "false")
        params.Add("config.enableClosePage", "false")
        params.Add("config.prejoinPageEnabled", "false") // Skip pre-join screen

        // CRITICAL: Remove authentication prompts
        params.Add("config.disableDeepLinking", "true")     // Remove mobile app prompts
        params.Add("config.hideDisplayName", "false")       // Keep display names visible
        params.Add("config.hideEmailInSettings", "true")    // Hide email from settings
        params.Add("config.hideInviteMoreHeader", "true")   // Remove "invite more" header
        params.Add("config.disableInviteFunctions", "true") // Disable invite functions
        params.Add("config.doNotStoreRoom", "true")         // Don't store room in browser

        // FORCE ANONYMOUS MODE - This removes login prompts
        params.Add("config.enableUserRolesBasedOnToken", "false") // Disable token-based auth
        params.Add("config.enableFeaturesBasedOnToken", "false")  // Disable feature tokens
        params.Add("config.disableProfile", "true")               // Disable profile editing
        params.Add("config.readOnlyName", "true")                 // Make name read-only
        params.Add("config.enableClosePage", "false")             // No close page
        params.Add("config.enableWelcomePage", "false")           // No welcome page

        // TOOLBAR CUSTOMIZATION - Remove unwanted buttons
        params.Add("config.toolbarButtons", "["+
                "'microphone','camera','desktop','fullscreen',"+
                "'hangup','chat','recording','settings','raisehand',"+
                "'videoquality','filmstrip','tileview','mute-everyone'"+
                "]") // Removed: invite, feedback, stats, shortcuts, help, profile, etc.

        // HIDE/DISABLE UNWANTED FEATURES
        params.Add("config.disableRemoteMute", "false")        // Allow moderators to mute
        params.Add("config.enableEmailInStats", "false")       // Hide email in stats
        params.Add("config.disableThirdPartyRequests", "true") // Block external requests
        params.Add("config.disableLocalVideoFlip", "false")    // Allow video flip
        params.Add("config.disableSimulcast", "false")         // Keep simulcast for quality

        // BRANDING &amp; CUSTOMIZATION
        params.Add("config.defaultLanguage", "en")          // Set default language
        params.Add("config.disableGoogleAnalytics", "true") // No tracking
        params.Add("config.disableRtx", "false")            // Keep RTX for quality
        params.Add("config.channelLastN", "20")             // Limit video streams

        // CRITICAL INTERFACE CONTROLS
        params.Add("config.disableJoinLeaveSounds", "false") // Keep join/leave sounds
        params.Add("config.hideConferenceSubject", "true")   // Hide room name display
        params.Add("config.hideConferenceTimer", "false")    // Keep timer
        params.Add("config.hideParticipantsStats", "true")   // Hide participant stats
        params.Add("config.disableShortcuts", "true")        // Disable keyboard shortcuts overlay

        // FORCE ANONYMOUS ACCESS - Critical for removing login prompts
        params.Add("config.enableAuthenticationUI", "false")     // Hide authentication UI
        params.Add("config.disableAuthenticationPrompt", "true") // Disable auth prompts
        params.Add("config.enableGuestDomain", "true")           // Enable guest access
        params.Add("config.guestDomain", "guest.meet.jit.si")    // Use guest domain

        // SECURITY &amp; PRIVACY
        params.Add("config.enableNoAudioDetection", "true")
        params.Add("config.enableNoisyMicDetection", "true")
        params.Add("config.enableLayerSuspension", "true") // Better performance

        if roomPassword != "" </span><span class="cov0" title="0">{
                params.Add("config.roomPassword", roomPassword)
        }</span>

        <span class="cov0" title="0">if isModerator </span><span class="cov0" title="0">{
                // MODERATORS: Direct access, no waiting room
                params.Add("config.isModerator", "true")
                params.Add("config.enableLobby", "false")
                params.Add("config.enableLobbyChat", "false")
        }</span> else<span class="cov0" title="0"> {
                // NON-MODERATORS: Must wait for approval
                params.Add("config.enableLobby", "true")
                params.Add("config.enableLobbyChat", "true")
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s/%s?%s", baseURL, encodedRoomName, params.Encode())</span>
}

// buildJitsiURLWithJWT builds a Jitsi Meet URL with JWT token for full control
func (s *MeetingService) buildJitsiURLWithJWT(baseURL, roomName, displayName, userEmail string, isModerator bool) string <span class="cov0" title="0">{
        // For now, use your existing JWT token approach
        // You can implement JWT generation here later if needed

        // Build URL with minimal parameters for JWT-based auth
        params := url.Values{}
        params.Add("jwt", "YOUR_JWT_TOKEN_HERE") // You'll replace this with actual JWT

        // Essential user info
        params.Add("userInfo.displayName", displayName)
        params.Add("userInfo.email", userEmail)

        // Force clean interface
        params.Add("config.prejoinPageEnabled", "false")
        params.Add("config.enableWelcomePage", "false")
        params.Add("config.enableClosePage", "false")

        return fmt.Sprintf("%s/%s?%s", baseURL, roomName, params.Encode())
}</span>

// buildJaaSURL builds a Jitsi as a Service URL with proper configuration
// SECURITY: Each chama gets completely isolated meeting rooms with cryptographic separation
func (s *MeetingService) buildJaaSURL(roomName, displayName, userEmail string, isModerator bool) string <span class="cov0" title="0">{
        jitsiAppID := os.Getenv("JITSI_APP_ID")
        jitsiDomain := os.Getenv("JITSI_DOMAIN")

        // SECURITY ENHANCEMENT: Create cryptographically secure room isolation
        // Each chama gets a unique namespace that cannot be guessed or accessed by other chamas

        // Extract chama ID from room name (format: chama_&lt;chamaId&gt;_meeting_&lt;meetingId&gt;)
        chamaID := extractChamaIDFromRoomName(roomName)

        // Generate secure room identifier with multiple layers of isolation:
        // 1. App ID prefix (your JaaS account isolation)
        // 2. Chama-specific cryptographic hash (prevents cross-chama access)
        // 3. Meeting-specific identifier (prevents meeting collision)
        secureRoomName := generateSecureRoomName(jitsiAppID, chamaID, roomName)

        // Build the JaaS URL - this will be used by the frontend External API
        baseURL := fmt.Sprintf("https://%s", jitsiDomain)

        // For JaaS, we return a special URL that the frontend will use with External API
        // The frontend will handle the JWT and configuration
        return fmt.Sprintf("%s/jaas?room=%s&amp;name=%s&amp;email=%s&amp;moderator=%t",
                baseURL,
                url.QueryEscape(secureRoomName),
                url.QueryEscape(displayName),
                url.QueryEscape(userEmail),
                isModerator,
        )
}</span>

// extractChamaIDFromRoomName extracts the chama ID from the room name for security isolation
func extractChamaIDFromRoomName(roomName string) string <span class="cov0" title="0">{
        // Room name format: chama_&lt;chamaId&gt;_meeting_&lt;meetingId&gt;
        parts := strings.Split(roomName, "_")
        if len(parts) &gt;= 2 &amp;&amp; parts[0] == "chama" </span><span class="cov0" title="0">{
                return parts[1] // Return the chama ID
        }</span>
        // Fallback: use a hash of the room name if format is unexpected
        <span class="cov0" title="0">hash := sha256.Sum256([]byte(roomName))
        return hex.EncodeToString(hash[:8])</span> // Use first 8 bytes as fallback ID
}

// generateSecureRoomName creates a cryptographically secure room name that ensures complete isolation
func generateSecureRoomName(appID, chamaID, originalRoomName string) string <span class="cov0" title="0">{
        // SECURITY LAYERS:
        // 1. App ID prefix - isolates your organization from other JaaS users
        // 2. Chama-specific salt - ensures chamas cannot access each other's meetings
        // 3. Room-specific hash - prevents meeting name collisions

        // Create chama-specific salt using cryptographic hash
        chamaSalt := sha256.Sum256([]byte(fmt.Sprintf("VAULTKE_CHAMA_SALT_%s_%s", chamaID, appID)))
        chamaSaltHex := hex.EncodeToString(chamaSalt[:16]) // Use first 16 bytes

        // Create room-specific hash
        roomHash := sha256.Sum256([]byte(fmt.Sprintf("%s_%s_%s", originalRoomName, chamaID, chamaSaltHex)))
        roomHashHex := hex.EncodeToString(roomHash[:12]) // Use first 12 bytes

        // Combine all security layers
        secureRoomName := fmt.Sprintf("%s/CHAMA_%s_ROOM_%s", appID, chamaSaltHex, roomHashHex)

        log.Printf("🔒 Generated secure room: %s -&gt; %s", originalRoomName, secureRoomName[:50]+"...")
        return secureRoomName
}</span>

// buildUserDisplayName creates a proper display name from user data
func buildUserDisplayName(firstName, lastName, username string) string <span class="cov0" title="0">{
        // Priority: FirstName LastName &gt; FirstName &gt; Username &gt; fallback
        if firstName != "" &amp;&amp; lastName != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s %s", firstName, lastName)
        }</span>
        <span class="cov0" title="0">if firstName != "" </span><span class="cov0" title="0">{
                return firstName
        }</span>
        <span class="cov0" title="0">if username != "" </span><span class="cov0" title="0">{
                return username
        }</span>
        <span class="cov0" title="0">return "VaultKe User"</span>
}

// verifyUserChamaMembership checks if a user is a member of a specific chama
func (s *MeetingService) verifyUserChamaMembership(userID, chamaID string) (bool, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*)
                FROM chama_members
                WHERE user_id = ? AND chama_id = ? AND is_active = TRUE
        `

        var count int
        err := s.db.QueryRow(query, userID, chamaID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check chama membership: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// generateSecureRandomString generates a cryptographically secure random string
func generateSecureRandomString(length int) string <span class="cov0" title="0">{
        bytes := make([]byte, length)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based random if crypto/rand fails
                return fmt.Sprintf("%d", time.Now().UnixNano())[0:length]
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes)[:length]</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package services

import (
        "bytes"
        "crypto/rand"
        "database/sql"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "time"

        "vaultke-backend/internal/config"
        "vaultke-backend/internal/models"
        "vaultke-backend/internal/utils"
)

// MpesaService handles M-Pesa payment integration
type MpesaService struct {
        db     *sql.DB
        config *config.Config
        client *http.Client
}

// NewMpesaService creates a new M-Pesa service
func NewMpesaService(db *sql.DB, cfg *config.Config) *MpesaService <span class="cov0" title="0">{
        return &amp;MpesaService{
                db:     db,
                config: cfg,
                client: &amp;http.Client{Timeout: 30 * time.Second},
        }
}</span>

// MpesaTokenResponse represents M-Pesa access token response
type MpesaTokenResponse struct {
        AccessToken string `json:"access_token"`
        ExpiresIn   string `json:"expires_in"`
}

// MpesaSTKPushRequest represents STK push request
type MpesaSTKPushRequest struct {
        BusinessShortCode string `json:"BusinessShortCode"`
        Password          string `json:"Password"`
        Timestamp         string `json:"Timestamp"`
        TransactionType   string `json:"TransactionType"`
        Amount            string `json:"Amount"`
        PartyA            string `json:"PartyA"`
        PartyB            string `json:"PartyB"`
        PhoneNumber       string `json:"PhoneNumber"`
        CallBackURL       string `json:"CallBackURL"`
        AccountReference  string `json:"AccountReference"`
        TransactionDesc   string `json:"TransactionDesc"`
}

// MpesaSTKPushResponse represents STK push response
type MpesaSTKPushResponse struct {
        MerchantRequestID   string `json:"MerchantRequestID"`
        CheckoutRequestID   string `json:"CheckoutRequestID"`
        ResponseCode        string `json:"ResponseCode"`
        ResponseDescription string `json:"ResponseDescription"`
        CustomerMessage     string `json:"CustomerMessage"`
}

// GetAccessToken gets M-Pesa access token
func (s *MpesaService) GetAccessToken() (string, error) <span class="cov0" title="0">{
        // Create basic auth header
        auth := base64.StdEncoding.EncodeToString(
                []byte(s.config.MpesaConsumerKey + ":" + s.config.MpesaConsumerSecret),
        )

        // Create request
        req, err := http.NewRequest("GET", "https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create token request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Basic "+auth)
        req.Header.Set("Content-Type", "application/json")

        // Make request
        resp, err := s.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Parse response
        var tokenResp MpesaTokenResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;tokenResp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode token response: %w", err)
        }</span>

        <span class="cov0" title="0">if tokenResp.AccessToken == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("empty access token received")
        }</span>

        <span class="cov0" title="0">return tokenResp.AccessToken, nil</span>
}

// GeneratePassword generates M-Pesa password
func (s *MpesaService) GeneratePassword(timestamp string) string <span class="cov0" title="0">{
        password := s.config.MpesaShortcode + s.config.MpesaPasskey + timestamp
        return base64.StdEncoding.EncodeToString([]byte(password))
}</span>

// InitiateSTKPush initiates M-Pesa STK push
func (s *MpesaService) InitiateSTKPush(transaction *models.MpesaTransaction) (*MpesaSTKPushResponse, error) <span class="cov0" title="0">{
        // Get access token
        accessToken, err := s.GetAccessToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get access token: %w", err)
        }</span>

        // Generate timestamp and password
        <span class="cov0" title="0">timestamp := time.Now().Format("20060102150405")
        password := s.GeneratePassword(timestamp)

        // Create STK push request
        stkRequest := MpesaSTKPushRequest{
                BusinessShortCode: s.config.MpesaShortcode,
                Password:          password,
                Timestamp:         timestamp,
                TransactionType:   "CustomerPayBillOnline",
                Amount:            fmt.Sprintf("%.0f", transaction.Amount),
                PartyA:            transaction.PhoneNumber,
                PartyB:            s.config.MpesaShortcode,
                PhoneNumber:       transaction.PhoneNumber,
                CallBackURL:       s.config.MpesaCallbackURL,
                AccountReference:  transaction.AccountReference,
                TransactionDesc:   transaction.TransactionDesc,
        }

        // Convert to JSON
        jsonData, err := json.Marshal(stkRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal STK request: %w", err)
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">req, err := http.NewRequest("POST", "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create STK request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)
        req.Header.Set("Content-Type", "application/json")

        // Make request
        resp, err := s.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initiate STK push: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read STK response: %w", err)
        }</span>

        // Parse response
        <span class="cov0" title="0">var stkResp MpesaSTKPushResponse
        if err := json.Unmarshal(body, &amp;stkResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode STK response: %w", err)
        }</span>

        // Check if request was successful
        <span class="cov0" title="0">if stkResp.ResponseCode != "0" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("STK push failed: %s", stkResp.ResponseDescription)
        }</span>

        <span class="cov0" title="0">return &amp;stkResp, nil</span>
}

// ProcessMpesaCallback processes M-Pesa callback
func (s *MpesaService) ProcessMpesaCallback(callback *models.MpesaCallback) error <span class="cov0" title="0">{
        // Start transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Check if payment was successful
        if callback.ResultCode == 0 </span><span class="cov0" title="0">{
                // Payment successful
                amount := callback.GetMpesaAmount()
                receiptNumber := callback.GetMpesaReceiptNumber()
                phoneNumber := callback.GetMpesaPhoneNumber()

                // Find the pending transaction
                var transactionID string
                findQuery := `
                        SELECT id FROM transactions 
                        WHERE reference = ? AND status = ? AND payment_method = ?
                `
                err = tx.QueryRow(findQuery, callback.CheckoutRequestID, models.TransactionStatusPending, models.PaymentMethodMpesa).Scan(&amp;transactionID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                // Create new transaction if not found
                                transactionID, err = s.createMpesaTransaction(tx, callback, amount, receiptNumber, phoneNumber)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create M-Pesa transaction: %w", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return fmt.Errorf("failed to find transaction: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Update existing transaction
                        err = s.updateMpesaTransaction(tx, transactionID, receiptNumber, phoneNumber)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update M-Pesa transaction: %w", err)
                        }</span>
                }

                // Process the transaction (update wallet balance)
                // Note: ProcessTransaction will handle its own transaction context
                // We need to commit our transaction first, then process the wallet update
                <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to commit M-Pesa transaction: %w", err)
                }</span>

                // Now process the wallet transaction
                <span class="cov0" title="0">walletService := NewWalletService(s.db)
                err = walletService.ProcessTransaction(transactionID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to process transaction: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> {
                // Payment failed - find transaction by checkout request ID and update status
                var transactionID string
                err = tx.QueryRow("SELECT id FROM transactions WHERE reference = ? AND payment_method = ?",
                        callback.CheckoutRequestID, models.PaymentMethodMpesa).Scan(&amp;transactionID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find transaction for failed payment: %w", err)
                }</span>

                // Commit transaction first to release the lock
                <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to commit transaction: %w", err)
                }</span>

                // Update transaction status using centralized function
                <span class="cov0" title="0">err = s.updateTransactionStatus(transactionID, models.TransactionStatusFailed)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update failed transaction status: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

// createMpesaTransaction creates a new M-Pesa transaction
func (s *MpesaService) createMpesaTransaction(tx *sql.Tx, callback *models.MpesaCallback, amount float64, receiptNumber, phoneNumber string) (string, error) <span class="cov0" title="0">{
        // Find user by phone number
        var userID string
        userQuery := "SELECT id FROM users WHERE phone = ?"
        err := tx.QueryRow(userQuery, phoneNumber).Scan(&amp;userID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to find user by phone: %w", err)
        }</span>

        // Get user's personal wallet
        <span class="cov0" title="0">var walletID string
        walletQuery := "SELECT id FROM wallets WHERE owner_id = ? AND type = ?"
        err = tx.QueryRow(walletQuery, userID, models.WalletTypePersonal).Scan(&amp;walletID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to find user wallet: %w", err)
        }</span>

        // Create transaction
        <span class="cov0" title="0">transactionID := generateTransactionID()
        metadata := map[string]interface{}{
                "mpesa_receipt_number": receiptNumber,
                "mpesa_phone_number":   phoneNumber,
                "checkout_request_id":  callback.CheckoutRequestID,
                "merchant_request_id":  callback.MerchantRequestID,
        }

        metadataJSON, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">insertQuery := `
                INSERT INTO transactions (
                        id, to_wallet_id, type, status, amount, currency, description,
                        reference, payment_method, metadata, fees, initiated_by,
                        requires_approval, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = tx.Exec(insertQuery,
                transactionID, walletID, models.TransactionTypeDeposit, models.TransactionStatusCompleted,
                amount, "KES", "M-Pesa deposit", callback.CheckoutRequestID, models.PaymentMethodMpesa,
                string(metadataJSON), 0, userID, false, time.Now(), time.Now(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to insert transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return transactionID, nil</span>
}

// updateTransactionStatus updates transaction status
func (s *MpesaService) updateTransactionStatus(transactionID string, status models.TransactionStatus) error <span class="cov0" title="0">{
        updateQuery := "UPDATE transactions SET status = ?, updated_at = ? WHERE id = ?"
        result, err := s.db.Exec(updateQuery, status, utils.NowEAT(), transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update transaction status: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction not found: %s", transactionID)
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully updated transaction %s status to %s", transactionID, status)
        return nil</span>
}

// updateMpesaTransaction updates an existing M-Pesa transaction
func (s *MpesaService) updateMpesaTransaction(tx *sql.Tx, transactionID, receiptNumber, phoneNumber string) error <span class="cov0" title="0">{
        // Update transaction metadata
        metadata := map[string]interface{}{
                "mpesa_receipt_number": receiptNumber,
                "mpesa_phone_number":   phoneNumber,
        }

        metadataJSON, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">updateQuery := `
                UPDATE transactions
                SET status = ?, metadata = ?, updated_at = ?
                WHERE id = ?
        `

        _, err = tx.Exec(updateQuery, models.TransactionStatusCompleted, string(metadataJSON), time.Now(), transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateTransactionID generates a unique transaction ID
func generateTransactionID() string <span class="cov0" title="0">{
        // Generate random bytes
        bytes := make([]byte, 16)
        rand.Read(bytes)

        // Convert to hex string
        return fmt.Sprintf("TXN_%X", bytes)
}</span>

// GetTransactionStatus gets M-Pesa transaction status
func (s *MpesaService) GetTransactionStatus(checkoutRequestID string) (string, error) <span class="cov0" title="0">{
        // Get access token
        accessToken, err := s.GetAccessToken()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get access token: %w", err)
        }</span>

        // Generate timestamp and password
        <span class="cov0" title="0">timestamp := time.Now().Format("20060102150405")
        password := s.GeneratePassword(timestamp)

        // Create query request
        queryRequest := map[string]string{
                "BusinessShortCode": s.config.MpesaShortcode,
                "Password":          password,
                "Timestamp":         timestamp,
                "CheckoutRequestID": checkoutRequestID,
        }

        // Convert to JSON
        jsonData, err := json.Marshal(queryRequest)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal query request: %w", err)
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">req, err := http.NewRequest("POST", "https://sandbox.safaricom.co.ke/mpesa/stkpushquery/v1/query", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create query request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)
        req.Header.Set("Content-Type", "application/json")

        // Make request
        resp, err := s.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to query transaction status: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read query response: %w", err)
        }</span>

        // Parse response
        <span class="cov0" title="0">var queryResp map[string]interface{}
        if err := json.Unmarshal(body, &amp;queryResp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode query response: %w", err)
        }</span>

        // Extract status
        <span class="cov0" title="0">if resultCode, ok := queryResp["ResultCode"]; ok </span><span class="cov0" title="0">{
                if resultCode.(float64) == 0 </span><span class="cov0" title="0">{
                        return "completed", nil
                }</span> else<span class="cov0" title="0"> {
                        return "failed", nil
                }</span>
        }

        <span class="cov0" title="0">return "pending", nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package services

import (
        "database/sql"
        "log"
        "time"

        "vaultke-backend/internal/models"
)

// NotificationScheduler handles scheduling and sending reminder notifications
type NotificationScheduler struct {
        db              *sql.DB
        reminderService *ReminderService
        ticker          *time.Ticker
        stopChan        chan bool
}

// NewNotificationScheduler creates a new notification scheduler
func NewNotificationScheduler(db *sql.DB) *NotificationScheduler <span class="cov0" title="0">{
        return &amp;NotificationScheduler{
                db:              db,
                reminderService: NewReminderService(db),
                stopChan:        make(chan bool),
        }
}</span>

// Start begins the notification scheduling process
func (ns *NotificationScheduler) Start() <span class="cov0" title="0">{
        log.Println("Starting notification scheduler...")

        // Check for pending notifications every minute
        ns.ticker = time.NewTicker(1 * time.Minute)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ns.ticker.C:<span class="cov0" title="0">
                                ns.processPendingNotifications()</span>
                        case &lt;-ns.stopChan:<span class="cov0" title="0">
                                log.Println("Stopping notification scheduler...")
                                return</span>
                        }
                }
        }()
}

// Stop stops the notification scheduler
func (ns *NotificationScheduler) Stop() <span class="cov0" title="0">{
        if ns.ticker != nil </span><span class="cov0" title="0">{
                ns.ticker.Stop()
        }</span>
        <span class="cov0" title="0">ns.stopChan &lt;- true</span>
}

// processPendingNotifications checks for and processes pending reminder notifications
func (ns *NotificationScheduler) processPendingNotifications() <span class="cov0" title="0">{
        reminders, err := ns.reminderService.GetPendingReminders()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting pending reminders: %v", err)
                return
        }</span>

        <span class="cov0" title="0">if len(reminders) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Processing %d pending reminder notifications", len(reminders))

        for _, reminder := range reminders </span><span class="cov0" title="0">{
                if ns.shouldSendNotification(&amp;reminder) </span><span class="cov0" title="0">{
                        ns.sendNotification(&amp;reminder)
                }</span>
        }
}

// shouldSendNotification determines if a notification should be sent for a reminder
func (ns *NotificationScheduler) shouldSendNotification(reminder *models.Reminder) bool <span class="cov0" title="0">{
        if !reminder.IsEnabled || reminder.IsCompleted </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">now := time.Now()

        // For one-time reminders, check if the scheduled time has passed and notification hasn't been sent
        if reminder.ReminderType == models.ReminderTypeOnce </span><span class="cov0" title="0">{
                return now.After(reminder.ScheduledAt) &amp;&amp; !reminder.NotificationSent
        }</span>

        // For recurring reminders, check if it's time for the next occurrence
        <span class="cov0" title="0">nextTime := reminder.GetNextScheduledTime()
        if nextTime == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Send notification if we're within 1 minute of the scheduled time
        <span class="cov0" title="0">timeDiff := nextTime.Sub(now)
        return timeDiff &lt;= time.Minute &amp;&amp; timeDiff &gt;= -time.Minute</span>
}

// sendNotification sends a notification for a reminder
func (ns *NotificationScheduler) sendNotification(reminder *models.Reminder) <span class="cov0" title="0">{
        log.Printf("Sending notification for reminder: %s (User: %s)", reminder.Title, reminder.UserID)

        // Create notification record (this would integrate with your notification system)
        notification := &amp;models.ReminderNotification{
                ReminderID:  reminder.ID,
                UserID:      reminder.UserID,
                Title:       reminder.Title,
                Description: getNotificationDescription(reminder),
                ScheduledAt: reminder.ScheduledAt,
                Type:        "reminder",
        }

        // Here you would integrate with your notification service
        // For example: push notifications, email, SMS, etc.
        ns.processNotification(notification)

        // Mark notification as sent for one-time reminders
        if reminder.ReminderType == models.ReminderTypeOnce </span><span class="cov0" title="0">{
                err := ns.reminderService.MarkNotificationSent(reminder.ID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error marking notification as sent for reminder %s: %v", reminder.ID, err)
                }</span>
        }
}

// processNotification processes the actual notification sending
func (ns *NotificationScheduler) processNotification(notification *models.ReminderNotification) <span class="cov0" title="0">{
        // This is where you would integrate with your notification service
        // For now, we'll just log the notification
        log.Printf("📱 NOTIFICATION: %s - %s (User: %s)",
                notification.Title,
                notification.Description,
                notification.UserID)

        // TODO: Integrate with actual notification services:
        // - Push notifications (FCM, APNs)
        // - Email notifications
        // - SMS notifications
        // - In-app notifications

        // Example integration points:
        // - Send push notification via FCM/APNs
        // - Send email via SMTP or email service
        // - Send SMS via Twilio or similar service
        // - Store in-app notification in database
}</span>

// getNotificationDescription creates a description for the notification
func getNotificationDescription(reminder *models.Reminder) string <span class="cov0" title="0">{
        if reminder.Description != nil &amp;&amp; *reminder.Description != "" </span><span class="cov0" title="0">{
                return *reminder.Description
        }</span>

        <span class="cov0" title="0">switch reminder.ReminderType </span>{
        case models.ReminderTypeDaily:<span class="cov0" title="0">
                return "Daily reminder"</span>
        case models.ReminderTypeWeekly:<span class="cov0" title="0">
                return "Weekly reminder"</span>
        case models.ReminderTypeMonthly:<span class="cov0" title="0">
                return "Monthly reminder"</span>
        default:<span class="cov0" title="0">
                return "Reminder notification"</span>
        }
}

// GetNotificationStats returns statistics about notification processing
func (ns *NotificationScheduler) GetNotificationStats() map[string]interface{} <span class="cov0" title="0">{
        // Get pending reminders count
        pendingReminders, err := ns.reminderService.GetPendingReminders()
        pendingCount := 0
        if err == nil </span><span class="cov0" title="0">{
                pendingCount = len(pendingReminders)
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "pending_notifications": pendingCount,
                "scheduler_running":     ns.ticker != nil,
                "last_check":            time.Now().Format(time.RFC3339),
        }</span>
}

// ProcessImmediateNotification processes a notification immediately (for testing)
func (ns *NotificationScheduler) ProcessImmediateNotification(reminderID string) error <span class="cov0" title="0">{
        // This method can be used for testing or manual notification triggers
        reminder, err := ns.reminderService.GetReminderByID(reminderID, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ns.sendNotification(reminder)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package services

import (
        "bytes"
        "database/sql"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/google/uuid"

        "vaultke-backend/internal/config"
        "vaultke-backend/internal/models"
)

// NotificationService handles notifications
type NotificationService struct {
        db     *sql.DB
        config *config.Config
        client *http.Client
}

// NewNotificationService creates a new notification service
func NewNotificationService(db *sql.DB, cfg *config.Config) *NotificationService <span class="cov0" title="0">{
        return &amp;NotificationService{
                db:     db,
                config: cfg,
                client: &amp;http.Client{Timeout: 30 * time.Second},
        }
}</span>

// NotificationType represents notification types
type NotificationType string

const (
        NotificationTypeInfo        NotificationType = "info"
        NotificationTypeSuccess     NotificationType = "success"
        NotificationTypeWarning     NotificationType = "warning"
        NotificationTypeError       NotificationType = "error"
        NotificationTypeTransaction NotificationType = "transaction"
        NotificationTypeChama       NotificationType = "chama"
        NotificationTypeMarketplace NotificationType = "marketplace"
        NotificationTypeMeeting     NotificationType = "meeting"
        NotificationTypeVote        NotificationType = "vote"
        NotificationTypeLoan        NotificationType = "loan"
)

// Notification represents a notification
type Notification struct {
        ID          string           `json:"id" db:"id"`
        UserID      string           `json:"userId" db:"user_id"`
        Type        NotificationType `json:"type" db:"type"`
        Title       string           `json:"title" db:"title"`
        Message     string           `json:"message" db:"message"`
        Data        string           `json:"data" db:"data"`
        IsRead      bool             `json:"isRead" db:"is_read"`
        IsPush      bool             `json:"isPush" db:"is_push"`
        IsEmail     bool             `json:"isEmail" db:"is_email"`
        IsSMS       bool             `json:"isSMS" db:"is_sms"`
        CreatedAt   time.Time        `json:"createdAt" db:"created_at"`
        ReadAt      *time.Time       `json:"readAt,omitempty" db:"read_at"`
}

// FCMMessage represents Firebase Cloud Messaging message
type FCMMessage struct {
        To           string                 `json:"to,omitempty"`
        Registration []string               `json:"registration_ids,omitempty"`
        Notification FCMNotification        `json:"notification"`
        Data         map[string]interface{} `json:"data,omitempty"`
        Priority     string                 `json:"priority"`
}

// FCMNotification represents FCM notification payload
type FCMNotification struct {
        Title string `json:"title"`
        Body  string `json:"body"`
        Icon  string `json:"icon,omitempty"`
        Sound string `json:"sound,omitempty"`
}

// CreateNotification creates a new notification
func (s *NotificationService) CreateNotification(userID string, notifType NotificationType, title, message string, data map[string]interface{}, sendPush, sendEmail, sendSMS bool) (*Notification, error) <span class="cov0" title="0">{
        // Serialize data
        dataJSON := "{}"
        if data != nil </span><span class="cov0" title="0">{
                dataBytes, err := json.Marshal(data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to serialize notification data: %w", err)
                }</span>
                <span class="cov0" title="0">dataJSON = string(dataBytes)</span>
        }

        <span class="cov0" title="0">notification := &amp;Notification{
                ID:        uuid.New().String(),
                UserID:    userID,
                Type:      notifType,
                Title:     title,
                Message:   message,
                Data:      dataJSON,
                IsRead:    false,
                IsPush:    sendPush,
                IsEmail:   sendEmail,
                IsSMS:     sendSMS,
                CreatedAt: time.Now(),
        }

        // Insert notification
        query := `
                INSERT INTO notifications (
                        id, user_id, type, title, message, data, is_read, is_push, is_email, is_sms, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.Exec(query,
                notification.ID, notification.UserID, notification.Type, notification.Title,
                notification.Message, notification.Data, notification.IsRead, notification.IsPush,
                notification.IsEmail, notification.IsSMS, notification.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create notification: %w", err)
        }</span>

        // Send push notification if requested
        <span class="cov0" title="0">if sendPush </span><span class="cov0" title="0">{
                go s.sendPushNotification(userID, title, message, data)
        }</span>

        // Send email if requested
        <span class="cov0" title="0">if sendEmail </span><span class="cov0" title="0">{
                go s.sendEmailNotification(userID, title, message)
        }</span>

        // Send SMS if requested
        <span class="cov0" title="0">if sendSMS </span><span class="cov0" title="0">{
                go s.sendSMSNotification(userID, message)
        }</span>

        <span class="cov0" title="0">return notification, nil</span>
}

// GetUserNotifications retrieves notifications for a user
func (s *NotificationService) GetUserNotifications(userID string, limit, offset int) ([]*Notification, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, type, title, message, data, is_read, is_push, is_email, is_sms, created_at, read_at
                FROM notifications
                WHERE user_id = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get notifications: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notifications []*Notification
        for rows.Next() </span><span class="cov0" title="0">{
                notification := &amp;Notification{}
                err := rows.Scan(
                        &amp;notification.ID, &amp;notification.UserID, &amp;notification.Type,
                        &amp;notification.Title, &amp;notification.Message, &amp;notification.Data,
                        &amp;notification.IsRead, &amp;notification.IsPush, &amp;notification.IsEmail,
                        &amp;notification.IsSMS, &amp;notification.CreatedAt, &amp;notification.ReadAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan notification: %w", err)
                }</span>
                <span class="cov0" title="0">notifications = append(notifications, notification)</span>
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

// MarkAsRead marks a notification as read
func (s *NotificationService) MarkAsRead(userID, notificationID string) error <span class="cov0" title="0">{
        now := time.Now()
        query := "UPDATE notifications SET is_read = true, read_at = ? WHERE id = ? AND user_id = ?"
        
        result, err := s.db.Exec(query, now, notificationID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark notification as read: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check affected rows: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("notification not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MarkAllAsRead marks all notifications as read for a user
func (s *NotificationService) MarkAllAsRead(userID string) error <span class="cov0" title="0">{
        now := time.Now()
        query := "UPDATE notifications SET is_read = true, read_at = ? WHERE user_id = ? AND is_read = false"
        
        _, err := s.db.Exec(query, now, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark all notifications as read: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetUnreadCount gets the count of unread notifications for a user
func (s *NotificationService) GetUnreadCount(userID string) (int, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM notifications WHERE user_id = ? AND is_read = false"
        
        var count int
        err := s.db.QueryRow(query, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get unread count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// DeleteNotification deletes a notification
func (s *NotificationService) DeleteNotification(userID, notificationID string) error <span class="cov0" title="0">{
        query := "DELETE FROM notifications WHERE id = ? AND user_id = ?"
        
        result, err := s.db.Exec(query, notificationID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete notification: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check affected rows: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("notification not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// sendPushNotification sends a push notification via FCM
func (s *NotificationService) sendPushNotification(userID, title, message string, data map[string]interface{}) <span class="cov0" title="0">{
        // Get user's FCM token
        var fcmToken string
        query := "SELECT fcm_token FROM users WHERE id = ? AND fcm_token IS NOT NULL"
        err := s.db.QueryRow(query, userID).Scan(&amp;fcmToken)
        if err != nil </span><span class="cov0" title="0">{
                // User doesn't have FCM token, skip push notification
                return
        }</span>

        // Create FCM message
        <span class="cov0" title="0">fcmMessage := FCMMessage{
                To: fcmToken,
                Notification: FCMNotification{
                        Title: title,
                        Body:  message,
                        Icon:  "ic_notification",
                        Sound: "default",
                },
                Data:     data,
                Priority: "high",
        }

        // Convert to JSON
        jsonData, err := json.Marshal(fcmMessage)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to marshal FCM message: %v\n", err)
                return
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">req, err := http.NewRequest("POST", "https://fcm.googleapis.com/fcm/send", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create FCM request: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "key="+s.config.FirebaseServerKey)
        req.Header.Set("Content-Type", "application/json")

        // Send request
        resp, err := s.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to send FCM notification: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                fmt.Printf("FCM request failed with status: %d\n", resp.StatusCode)
        }</span>
}

// sendEmailNotification sends an email notification
func (s *NotificationService) sendEmailNotification(userID, title, message string) <span class="cov0" title="0">{
        // Get user's email
        var email string
        query := "SELECT email FROM users WHERE id = ?"
        err := s.db.QueryRow(query, userID).Scan(&amp;email)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get user email: %v\n", err)
                return
        }</span>

        // TODO: Implement email sending logic
        // This could use services like SendGrid, AWS SES, etc.
        <span class="cov0" title="0">fmt.Printf("Email notification to %s: %s - %s\n", email, title, message)</span>
}

// sendSMSNotification sends an SMS notification
func (s *NotificationService) sendSMSNotification(userID, message string) <span class="cov0" title="0">{
        // Get user's phone
        var phone string
        query := "SELECT phone FROM users WHERE id = ?"
        err := s.db.QueryRow(query, userID).Scan(&amp;phone)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get user phone: %v\n", err)
                return
        }</span>

        // TODO: Implement SMS sending logic using Africa's Talking
        <span class="cov0" title="0">fmt.Printf("SMS notification to %s: %s\n", phone, message)</span>
}

// NotifyTransactionComplete sends transaction completion notification
func (s *NotificationService) NotifyTransactionComplete(userID string, amount float64, transactionType string) error <span class="cov0" title="0">{
        title := "Transaction Complete"
        message := fmt.Sprintf("Your %s of KSh %.2f has been completed successfully", transactionType, amount)
        
        data := map[string]interface{}{
                "type":   "transaction",
                "amount": amount,
                "transactionType": transactionType,
        }

        _, err := s.CreateNotification(userID, NotificationTypeTransaction, title, message, data, true, false, false)
        return err
}</span>

// NotifyChamaInvitation sends chama invitation notification
func (s *NotificationService) NotifyChamaInvitation(userID, chamaName, inviterName string) error <span class="cov0" title="0">{
        title := "Chama Invitation"
        message := fmt.Sprintf("%s has invited you to join %s chama", inviterName, chamaName)
        
        data := map[string]interface{}{
                "type": "chama_invitation",
                "chamaName": chamaName,
                "inviterName": inviterName,
        }

        _, err := s.CreateNotification(userID, NotificationTypeChama, title, message, data, true, true, false)
        return err
}</span>

// NotifyMeetingReminder sends meeting reminder notification
func (s *NotificationService) NotifyMeetingReminder(userID, chamaName string, meetingTime time.Time) error <span class="cov0" title="0">{
        title := "Meeting Reminder"
        message := fmt.Sprintf("You have a %s chama meeting in 1 hour", chamaName)
        
        data := map[string]interface{}{
                "type": "meeting_reminder",
                "chamaName": chamaName,
                "meetingTime": meetingTime.Format(time.RFC3339),
        }

        _, err := s.CreateNotification(userID, NotificationTypeMeeting, title, message, data, true, false, true)
        return err
}</span>

// NotifyOrderStatusUpdate sends order status update notification
func (s *NotificationService) NotifyOrderStatusUpdate(userID, orderID string, status models.OrderStatus) error <span class="cov0" title="0">{
        title := "Order Update"
        message := fmt.Sprintf("Your order #%s is now %s", orderID[:8], status)
        
        data := map[string]interface{}{
                "type": "order_update",
                "orderId": orderID,
                "status": status,
        }

        _, err := s.CreateNotification(userID, NotificationTypeMarketplace, title, message, data, true, false, false)
        return err
}</span>

// NotifyLoanApproval sends loan approval notification
func (s *NotificationService) NotifyLoanApproval(userID string, amount float64, approved bool) error <span class="cov0" title="0">{
        var title, message string
        
        if approved </span><span class="cov0" title="0">{
                title = "Loan Approved"
                message = fmt.Sprintf("Your loan application for KSh %.2f has been approved", amount)
        }</span> else<span class="cov0" title="0"> {
                title = "Loan Declined"
                message = fmt.Sprintf("Your loan application for KSh %.2f has been declined", amount)
        }</span>
        
        <span class="cov0" title="0">data := map[string]interface{}{
                "type": "loan_decision",
                "amount": amount,
                "approved": approved,
        }

        _, err := s.CreateNotification(userID, NotificationTypeLoan, title, message, data, true, true, false)
        return err</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package services

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"
        "vaultke-backend/internal/models"
        "vaultke-backend/internal/utils"

        "github.com/google/uuid"
)

// GetOrders retrieves orders for a user (as buyer or seller)
func (s *MarketplaceService) GetOrders(userID string, filters map[string]interface{}, limit, offset int) ([]*models.Order, error) <span class="cov0" title="0">{
        role := filters["role"].(string)

        var query string
        var args []interface{}

        if role == "seller" </span><span class="cov0" title="0">{
                query = `
                        SELECT o.id, o.buyer_id, o.seller_id, o.chama_id, o.total_amount, o.currency,
                                   o.status, o.payment_method, o.payment_status, o.delivery_county, o.delivery_town,
                                   o.delivery_address, o.delivery_phone, o.delivery_fee, o.delivery_status,
                                   o.delivery_person_id, o.notes, o.created_at, o.updated_at,
                                   buyer.first_name as buyer_first_name, buyer.last_name as buyer_last_name,
                                   buyer.avatar as buyer_avatar
                        FROM orders o
                        INNER JOIN users buyer ON o.buyer_id = buyer.id
                        WHERE o.seller_id = ?
                `
                args = append(args, userID)
        }</span> else<span class="cov0" title="0"> {
                query = `
                        SELECT o.id, o.buyer_id, o.seller_id, o.chama_id, o.total_amount, o.currency,
                                   o.status, o.payment_method, o.payment_status, o.delivery_county, o.delivery_town,
                                   o.delivery_address, o.delivery_phone, o.delivery_fee, o.delivery_status,
                                   o.delivery_person_id, o.notes, o.created_at, o.updated_at,
                                   seller.first_name as seller_first_name, seller.last_name as seller_last_name,
                                   seller.avatar as seller_avatar
                        FROM orders o
                        INNER JOIN users seller ON o.seller_id = seller.id
                        WHERE o.buyer_id = ?
                `
                args = append(args, userID)
        }</span>

        // Add status filter
        <span class="cov0" title="0">if status, ok := filters["status"]; ok </span><span class="cov0" title="0">{
                query += " AND o.status = ?"
                args = append(args, status)
        }</span>

        <span class="cov0" title="0">query += " ORDER BY o.created_at DESC LIMIT ? OFFSET ?"
        args = append(args, limit, offset)

        rows, err := s.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query orders: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []*models.Order
        for rows.Next() </span><span class="cov0" title="0">{
                var order models.Order
                var otherUser models.User
                var chamaID sql.NullString
                var deliveryPersonID sql.NullString
                var otherUserAvatar sql.NullString

                err := rows.Scan(
                        &amp;order.ID, &amp;order.BuyerID, &amp;order.SellerID, &amp;chamaID, &amp;order.TotalAmount,
                        &amp;order.Currency, &amp;order.Status, &amp;order.PaymentMethod, &amp;order.PaymentStatus,
                        &amp;order.DeliveryCounty, &amp;order.DeliveryTown, &amp;order.DeliveryAddress,
                        &amp;order.DeliveryPhone, &amp;order.DeliveryFee, &amp;order.DeliveryStatus,
                        &amp;deliveryPersonID, &amp;order.Notes, &amp;order.CreatedAt, &amp;order.UpdatedAt,
                        &amp;otherUser.FirstName, &amp;otherUser.LastName, &amp;otherUserAvatar,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Set optional fields
                <span class="cov0" title="0">if chamaID.Valid </span><span class="cov0" title="0">{
                        order.ChamaID = &amp;chamaID.String
                }</span>
                <span class="cov0" title="0">if deliveryPersonID.Valid </span><span class="cov0" title="0">{
                        order.DeliveryPersonID = &amp;deliveryPersonID.String
                }</span>
                <span class="cov0" title="0">if otherUserAvatar.Valid </span><span class="cov0" title="0">{
                        otherUser.Avatar = &amp;otherUserAvatar.String
                }</span>

                // Set the other user (buyer for seller, seller for buyer)
                <span class="cov0" title="0">if role == "seller" </span><span class="cov0" title="0">{
                        otherUser.ID = order.BuyerID
                        order.Buyer = &amp;otherUser
                }</span> else<span class="cov0" title="0"> {
                        otherUser.ID = order.SellerID
                        order.Seller = &amp;otherUser
                }</span>

                <span class="cov0" title="0">orders = append(orders, &amp;order)</span>
        }

        <span class="cov0" title="0">return orders, nil</span>
}

// GetOrderByID retrieves a specific order by ID with full details
func (s *MarketplaceService) GetOrderByID(orderID string, userID string) (*models.Order, error) <span class="cov0" title="0">{
        // Query to get order with buyer, seller, and delivery person details
        query := `
                SELECT o.id, o.buyer_id, o.seller_id, o.chama_id, o.total_amount, o.currency,
                           o.status, o.payment_method, o.payment_status, o.delivery_county,
                           o.delivery_town, o.delivery_address, o.delivery_phone, o.delivery_fee,
                           o.delivery_status, o.delivery_person_id, o.estimated_delivery,
                           o.actual_delivery, o.notes, o.created_at, o.updated_at,
                           buyer.first_name as buyer_first_name, buyer.last_name as buyer_last_name,
                           buyer.avatar as buyer_avatar, buyer.phone as buyer_phone,
                           seller.first_name as seller_first_name, seller.last_name as seller_last_name,
                           seller.avatar as seller_avatar, seller.phone as seller_phone,
                           dp.first_name as dp_first_name, dp.last_name as dp_last_name,
                           dp.avatar as dp_avatar, dp.phone as dp_phone
                FROM orders o
                INNER JOIN users buyer ON o.buyer_id = buyer.id
                INNER JOIN users seller ON o.seller_id = seller.id
                LEFT JOIN users dp ON o.delivery_person_id = dp.id
                WHERE o.id = ? AND (o.buyer_id = ? OR o.seller_id = ?)
        `

        var order models.Order
        var buyer, seller, deliveryPerson models.User
        var chamaID, deliveryPersonID sql.NullString
        var estimatedDelivery, actualDelivery sql.NullTime
        var buyerAvatar, buyerPhone, sellerAvatar, sellerPhone sql.NullString
        var dpFirstName, dpLastName, dpAvatar, dpPhone sql.NullString

        err := s.db.QueryRow(query, orderID, userID, userID).Scan(
                &amp;order.ID, &amp;order.BuyerID, &amp;order.SellerID, &amp;chamaID, &amp;order.TotalAmount,
                &amp;order.Currency, &amp;order.Status, &amp;order.PaymentMethod, &amp;order.PaymentStatus,
                &amp;order.DeliveryCounty, &amp;order.DeliveryTown, &amp;order.DeliveryAddress,
                &amp;order.DeliveryPhone, &amp;order.DeliveryFee, &amp;order.DeliveryStatus,
                &amp;deliveryPersonID, &amp;estimatedDelivery, &amp;actualDelivery, &amp;order.Notes,
                &amp;order.CreatedAt, &amp;order.UpdatedAt,
                &amp;buyer.FirstName, &amp;buyer.LastName, &amp;buyerAvatar, &amp;buyerPhone,
                &amp;seller.FirstName, &amp;seller.LastName, &amp;sellerAvatar, &amp;sellerPhone,
                &amp;dpFirstName, &amp;dpLastName, &amp;dpAvatar, &amp;dpPhone,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("order not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get order: %w", err)</span>
        }

        // Set optional fields
        <span class="cov0" title="0">if chamaID.Valid </span><span class="cov0" title="0">{
                order.ChamaID = &amp;chamaID.String
        }</span>
        <span class="cov0" title="0">if deliveryPersonID.Valid </span><span class="cov0" title="0">{
                order.DeliveryPersonID = &amp;deliveryPersonID.String
        }</span>
        <span class="cov0" title="0">if estimatedDelivery.Valid </span><span class="cov0" title="0">{
                order.EstimatedDelivery = &amp;estimatedDelivery.Time
        }</span>
        <span class="cov0" title="0">if actualDelivery.Valid </span><span class="cov0" title="0">{
                order.ActualDelivery = &amp;actualDelivery.Time
        }</span>

        // Set buyer details
        <span class="cov0" title="0">buyer.ID = order.BuyerID
        if buyerAvatar.Valid </span><span class="cov0" title="0">{
                buyer.Avatar = &amp;buyerAvatar.String
        }</span>
        <span class="cov0" title="0">if buyerPhone.Valid </span><span class="cov0" title="0">{
                buyer.Phone = buyerPhone.String
        }</span>
        <span class="cov0" title="0">order.Buyer = &amp;buyer

        // Set seller details
        seller.ID = order.SellerID
        if sellerAvatar.Valid </span><span class="cov0" title="0">{
                seller.Avatar = &amp;sellerAvatar.String
        }</span>
        <span class="cov0" title="0">if sellerPhone.Valid </span><span class="cov0" title="0">{
                seller.Phone = sellerPhone.String
        }</span>
        <span class="cov0" title="0">order.Seller = &amp;seller

        // Set delivery person details if exists
        if deliveryPersonID.Valid </span><span class="cov0" title="0">{
                deliveryPerson.ID = deliveryPersonID.String
                if dpFirstName.Valid </span><span class="cov0" title="0">{
                        deliveryPerson.FirstName = dpFirstName.String
                }</span>
                <span class="cov0" title="0">if dpLastName.Valid </span><span class="cov0" title="0">{
                        deliveryPerson.LastName = dpLastName.String
                }</span>
                <span class="cov0" title="0">if dpAvatar.Valid </span><span class="cov0" title="0">{
                        deliveryPerson.Avatar = &amp;dpAvatar.String
                }</span>
                <span class="cov0" title="0">if dpPhone.Valid </span><span class="cov0" title="0">{
                        deliveryPerson.Phone = dpPhone.String
                }</span>
                <span class="cov0" title="0">order.DeliveryPerson = &amp;deliveryPerson</span>
        }

        // Get order items
        <span class="cov0" title="0">itemsQuery := `
                SELECT oi.id, oi.order_id, oi.product_id, oi.quantity, oi.price, oi.name,
                           p.images, p.category, p.seller_id
                FROM order_items oi
                LEFT JOIN products p ON oi.product_id = p.id
                WHERE oi.order_id = ?
        `

        rows, err := s.db.Query(itemsQuery, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order items: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var items []models.OrderItem
        for rows.Next() </span><span class="cov0" title="0">{
                var item models.OrderItem
                var product models.Product
                var imagesJSON sql.NullString

                err := rows.Scan(
                        &amp;item.ID, &amp;item.OrderID, &amp;item.ProductID, &amp;item.Quantity,
                        &amp;item.Price, &amp;item.Name, &amp;imagesJSON, &amp;product.Category, &amp;product.SellerID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse images
                <span class="cov0" title="0">if imagesJSON.Valid &amp;&amp; imagesJSON.String != "" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal([]byte(imagesJSON.String), &amp;product.Images); err == nil </span><span class="cov0" title="0">{
                                item.Product = &amp;product
                        }</span>
                }

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">order.Items = items
        return &amp;order, nil</span>
}

// CreateOrderFromCart creates an order from selected cart items
func (s *MarketplaceService) CreateOrderFromCart(userID string, cartItemIDs []string, orderData *models.OrderCreation) (*models.Order, error) <span class="cov0" title="0">{
        // Start transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Get cart items
        if len(cartItemIDs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cart items selected")
        }</span>

        // Build query to get cart items with product details
        <span class="cov0" title="0">placeholders := make([]string, len(cartItemIDs))
        args := make([]interface{}, len(cartItemIDs)+1)
        args[0] = userID
        for i, id := range cartItemIDs </span><span class="cov0" title="0">{
                placeholders[i] = "?"
                args[i+1] = id
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT ci.id, ci.product_id, ci.quantity, ci.price,
                           p.name, p.seller_id, p.chama_id, p.stock
                FROM cart_items ci
                INNER JOIN products p ON ci.product_id = p.id
                WHERE ci.user_id = ? AND ci.id IN (%s)
        `, strings.Join(placeholders, ","))

        rows, err := tx.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cart items: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var cartItems []struct {
                ID        string
                ProductID string
                Quantity  int
                Price     float64
                Name      string
                SellerID  string
                ChamaID   sql.NullString
                Stock     int
        }

        var totalAmount float64
        var sellerID string
        var chamaID *string

        for rows.Next() </span><span class="cov0" title="0">{
                var item struct {
                        ID        string
                        ProductID string
                        Quantity  int
                        Price     float64
                        Name      string
                        SellerID  string
                        ChamaID   sql.NullString
                        Stock     int
                }

                err := rows.Scan(&amp;item.ID, &amp;item.ProductID, &amp;item.Quantity, &amp;item.Price,
                        &amp;item.Name, &amp;item.SellerID, &amp;item.ChamaID, &amp;item.Stock)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check stock
                <span class="cov0" title="0">if item.Stock &lt; item.Quantity </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("insufficient stock for product %s", item.Name)
                }</span>

                // Ensure all items are from the same seller
                <span class="cov0" title="0">if sellerID == "" </span><span class="cov0" title="0">{
                        sellerID = item.SellerID
                        if item.ChamaID.Valid </span><span class="cov0" title="0">{
                                chamaID = &amp;item.ChamaID.String
                        }</span>
                } else<span class="cov0" title="0"> if sellerID != item.SellerID </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("all items must be from the same seller")
                }</span>

                <span class="cov0" title="0">totalAmount += item.Price * float64(item.Quantity)
                cartItems = append(cartItems, item)</span>
        }

        <span class="cov0" title="0">if len(cartItems) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid cart items found")
        }</span>

        // Create order
        <span class="cov0" title="0">order := &amp;models.Order{
                ID:              uuid.New().String(),
                BuyerID:         userID,
                SellerID:        sellerID,
                ChamaID:         chamaID,
                TotalAmount:     totalAmount,
                Currency:        "KES",
                Status:          models.OrderStatusPending,
                PaymentMethod:   orderData.PaymentMethod,
                PaymentStatus:   "pending",
                DeliveryCounty:  orderData.DeliveryCounty,
                DeliveryTown:    orderData.DeliveryTown,
                DeliveryAddress: orderData.DeliveryAddress,
                DeliveryPhone:   orderData.DeliveryPhone,
                DeliveryFee:     0, // Calculate based on location
                DeliveryStatus:  models.DeliveryStatusPending,
                Notes:           orderData.Notes,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }

        // Insert order
        orderQuery := `
                INSERT INTO orders (
                        id, buyer_id, seller_id, chama_id, total_amount, currency, status,
                        payment_method, payment_status, delivery_county, delivery_town,
                        delivery_address, delivery_phone, delivery_fee, delivery_status,
                        notes, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = tx.Exec(orderQuery,
                order.ID, order.BuyerID, order.SellerID, order.ChamaID,
                order.TotalAmount, order.Currency, order.Status, order.PaymentMethod,
                order.PaymentStatus, order.DeliveryCounty, order.DeliveryTown,
                order.DeliveryAddress, order.DeliveryPhone, order.DeliveryFee,
                order.DeliveryStatus, order.Notes, order.CreatedAt, order.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create order: %w", err)
        }</span>

        // Insert order items and update stock
        <span class="cov0" title="0">for _, item := range cartItems </span><span class="cov0" title="0">{
                orderItem := &amp;models.OrderItem{
                        ID:        uuid.New().String(),
                        OrderID:   order.ID,
                        ProductID: item.ProductID,
                        Quantity:  item.Quantity,
                        Price:     item.Price,
                        Name:      item.Name,
                }

                itemQuery := `
                        INSERT INTO order_items (id, order_id, product_id, quantity, price, name)
                        VALUES (?, ?, ?, ?, ?, ?)
                `

                _, err = tx.Exec(itemQuery,
                        orderItem.ID, orderItem.OrderID, orderItem.ProductID,
                        orderItem.Quantity, orderItem.Price, orderItem.Name,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create order item: %w", err)
                }</span>

                // Update product stock
                <span class="cov0" title="0">_, err = tx.Exec(
                        "UPDATE products SET stock = stock - ? WHERE id = ?",
                        item.Quantity, item.ProductID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update product stock: %w", err)
                }</span>

                // Remove from cart
                <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM cart_items WHERE id = ?", item.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to clear cart: %w", err)
                }</span>
        }

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return order, nil</span>
}

// CreateOrder creates a new order from cart items
func (s *MarketplaceService) CreateOrder(creation *models.OrderCreation, buyerID string) (*models.Order, error) <span class="cov0" title="0">{
        // Validate input
        if err := utils.ValidateStruct(creation); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Calculate total amount
        var totalAmount float64
        var sellerID string
        var chamaID *string

        for i, item := range creation.Items </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        sellerID = item.Product.SellerID
                        chamaID = item.Product.ChamaID
                }</span> else<span class="cov0" title="0"> {
                        // Ensure all items are from the same seller
                        if item.Product.SellerID != sellerID </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("all items must be from the same seller")
                        }</span>
                }
                <span class="cov0" title="0">totalAmount += item.GetTotalPrice()</span>
        }

        // Create order
        <span class="cov0" title="0">order := &amp;models.Order{
                ID:              uuid.New().String(),
                BuyerID:         buyerID,
                SellerID:        sellerID,
                ChamaID:         chamaID,
                TotalAmount:     totalAmount,
                Currency:        "KES",
                Status:          models.OrderStatusPending,
                PaymentMethod:   creation.PaymentMethod,
                PaymentStatus:   "pending",
                DeliveryCounty:  creation.DeliveryCounty,
                DeliveryTown:    creation.DeliveryTown,
                DeliveryAddress: creation.DeliveryAddress,
                DeliveryPhone:   creation.DeliveryPhone,
                DeliveryFee:     0, // Calculate based on location
                DeliveryStatus:  models.DeliveryStatusPending,
                Notes:           creation.Notes,
                CreatedAt:       utils.NowEAT(),
                UpdatedAt:       utils.NowEAT(),
        }

        // Insert order
        orderQuery := `
                INSERT INTO orders (
                        id, buyer_id, seller_id, chama_id, total_amount, currency, status,
                        payment_method, payment_status, delivery_county, delivery_town,
                        delivery_address, delivery_phone, delivery_fee, delivery_status,
                        notes, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = tx.Exec(orderQuery,
                order.ID, order.BuyerID, order.SellerID, order.ChamaID,
                order.TotalAmount, order.Currency, order.Status, order.PaymentMethod,
                order.PaymentStatus, order.DeliveryCounty, order.DeliveryTown,
                order.DeliveryAddress, order.DeliveryPhone, order.DeliveryFee,
                order.DeliveryStatus, order.Notes, order.CreatedAt, order.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create order: %w", err)
        }</span>

        // Insert order items
        <span class="cov0" title="0">for _, item := range creation.Items </span><span class="cov0" title="0">{
                orderItem := &amp;models.OrderItem{
                        ID:        uuid.New().String(),
                        OrderID:   order.ID,
                        ProductID: item.ProductID,
                        Quantity:  item.Quantity,
                        Price:     item.Price,
                        Name:      item.Product.Name,
                }

                itemQuery := `
                        INSERT INTO order_items (id, order_id, product_id, quantity, price, name)
                        VALUES (?, ?, ?, ?, ?, ?)
                `

                _, err = tx.Exec(itemQuery,
                        orderItem.ID, orderItem.OrderID, orderItem.ProductID,
                        orderItem.Quantity, orderItem.Price, orderItem.Name,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create order item: %w", err)
                }</span>

                // Update product stock
                <span class="cov0" title="0">_, err = tx.Exec(
                        "UPDATE products SET stock = stock - ? WHERE id = ?",
                        item.Quantity, item.ProductID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update product stock: %w", err)
                }</span>

                // Remove from cart
                <span class="cov0" title="0">_, err = tx.Exec(
                        "DELETE FROM cart_items WHERE user_id = ? AND product_id = ?",
                        buyerID, item.ProductID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to clear cart: %w", err)
                }</span>
        }

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return order, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package services

import (
        "crypto/rand"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "golang.org/x/crypto/bcrypt"
)

// PasswordResetService handles password reset functionality
type PasswordResetService struct {
        db           *sql.DB
        emailService *EmailService
}

// PasswordResetToken represents a password reset token
type PasswordResetToken struct {
        ID        string    `json:"id" db:"id"`
        UserID    string    `json:"userId" db:"user_id"`
        Token     string    `json:"token" db:"token"`
        ExpiresAt time.Time `json:"expiresAt" db:"expires_at"`
        Used      bool      `json:"used" db:"used"`
        CreatedAt time.Time `json:"createdAt" db:"created_at"`
}

// NewPasswordResetService creates a new password reset service
func NewPasswordResetService(db *sql.DB, emailService *EmailService) *PasswordResetService <span class="cov8" title="1">{
        return &amp;PasswordResetService{
                db:           db,
                emailService: emailService,
        }
}</span>

// InitializePasswordResetTable creates the password reset tokens table if it doesn't exist
func (s *PasswordResetService) InitializePasswordResetTable() error <span class="cov8" title="1">{
        query := `
        CREATE TABLE IF NOT EXISTS password_reset_tokens (
                id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
                user_id TEXT NOT NULL,
                token TEXT NOT NULL UNIQUE,
                expires_at DATETIME NOT NULL,
                used BOOLEAN DEFAULT FALSE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
        )`

        _, err := s.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create password_reset_tokens table: %w", err)
        }</span>

        // Create index for faster lookups
        <span class="cov8" title="1">indexQuery := `CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_token ON password_reset_tokens(token)`
        _, err = s.db.Exec(indexQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create password reset tokens index: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GenerateResetToken generates a secure random token
func (s *PasswordResetService) GenerateResetToken() (string, error) <span class="cov8" title="1">{
        // Generate 6-digit numeric code for user-friendly experience
        bytes := make([]byte, 3)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate random bytes: %w", err)
        }</span>

        // Convert to 6-digit number
        <span class="cov8" title="1">token := fmt.Sprintf("%06d", int(bytes[0])&lt;&lt;16|int(bytes[1])&lt;&lt;8|int(bytes[2]))
        return token[:6], nil</span>
}

// CreatePasswordResetToken creates a new password reset token for a user
func (s *PasswordResetService) CreatePasswordResetToken(userID string) (*PasswordResetToken, error) <span class="cov0" title="0">{
        // Generate token
        token, err := s.GenerateResetToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set expiry to 10 minutes from now
        <span class="cov0" title="0">expiresAt := time.Now().Add(10 * time.Minute)

        // Invalidate any existing tokens for this user
        _, err = s.db.Exec("UPDATE password_reset_tokens SET used = TRUE WHERE user_id = ? AND used = FALSE", userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to invalidate existing tokens: %w", err)
        }</span>

        // Insert new token
        <span class="cov0" title="0">query := `
        INSERT INTO password_reset_tokens (user_id, token, expires_at)
        VALUES (?, ?, ?)
        `

        result, err := s.db.Exec(query, userID, token, expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create password reset token: %w", err)
        }</span>

        // Get the inserted ID
        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get inserted token ID: %w", err)
        }</span>

        <span class="cov0" title="0">resetToken := &amp;PasswordResetToken{
                ID:        fmt.Sprintf("%d", id),
                UserID:    userID,
                Token:     token,
                ExpiresAt: expiresAt,
                Used:      false,
                CreatedAt: time.Now(),
        }

        return resetToken, nil</span>
}

// ValidateResetToken validates a password reset token
func (s *PasswordResetService) ValidateResetToken(token string) (*PasswordResetToken, error) <span class="cov0" title="0">{
        query := `
        SELECT id, user_id, token, expires_at, used, created_at
        FROM password_reset_tokens
        WHERE token = ? AND used = FALSE
        `

        var resetToken PasswordResetToken
        err := s.db.QueryRow(query, token).Scan(
                &amp;resetToken.ID,
                &amp;resetToken.UserID,
                &amp;resetToken.Token,
                &amp;resetToken.ExpiresAt,
                &amp;resetToken.Used,
                &amp;resetToken.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid or expired reset token")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to validate reset token: %w", err)</span>
        }

        // Check if token has expired
        <span class="cov0" title="0">if time.Now().After(resetToken.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reset token has expired")
        }</span>

        <span class="cov0" title="0">return &amp;resetToken, nil</span>
}

// UseResetToken marks a reset token as used
func (s *PasswordResetService) UseResetToken(token string) error <span class="cov0" title="0">{
        query := `UPDATE password_reset_tokens SET used = TRUE WHERE token = ?`
        result, err := s.db.Exec(query, token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark token as used: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get affected rows: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("token not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SendPasswordResetEmail sends a password reset email to the user
func (s *PasswordResetService) SendPasswordResetEmail(userEmail, userName, resetToken string) error <span class="cov0" title="0">{
        if s.emailService == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("email service not configured")
        }</span>

        <span class="cov0" title="0">return s.emailService.SendPasswordResetEmail(userEmail, resetToken, userName)</span>
}

// CleanupExpiredTokens removes expired password reset tokens
func (s *PasswordResetService) CleanupExpiredTokens() error <span class="cov0" title="0">{
        query := `DELETE FROM password_reset_tokens WHERE expires_at &lt; ? OR used = TRUE`
        _, err := s.db.Exec(query, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup expired tokens: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetUserByIdentifier finds a user by email or phone number
func (s *PasswordResetService) GetUserByIdentifier(identifier string) (string, string, string, error) <span class="cov0" title="0">{
        // Clean the identifier
        identifier = strings.TrimSpace(identifier)

        var userID, email, name string
        var query string

        // Check if identifier looks like an email
        if strings.Contains(identifier, "@") </span><span class="cov0" title="0">{
                query = `SELECT id, email, COALESCE(first_name || ' ' || last_name, first_name, email) as name FROM users WHERE email = ? AND status = 'active'`
        }</span> else<span class="cov0" title="0"> {
                // Assume it's a phone number
                query = `SELECT id, email, COALESCE(first_name || ' ' || last_name, first_name, phone) as name FROM users WHERE phone = ? AND status = 'active'`
        }</span>

        <span class="cov0" title="0">err := s.db.QueryRow(query, identifier).Scan(&amp;userID, &amp;email, &amp;name)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return "", "", "", fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return "", "", "", fmt.Errorf("failed to find user: %w", err)</span>
        }

        <span class="cov0" title="0">return userID, email, name, nil</span>
}

// RequestPasswordReset handles the complete password reset request process
func (s *PasswordResetService) RequestPasswordReset(identifier string) error <span class="cov0" title="0">{
        // Find user by email or phone
        userID, email, name, err := s.GetUserByIdentifier(identifier)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create reset token
        <span class="cov0" title="0">resetToken, err := s.CreatePasswordResetToken(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create reset token: %w", err)
        }</span>

        // Send email
        <span class="cov0" title="0">err = s.SendPasswordResetEmail(email, name, resetToken.Token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send reset email: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ResetPassword resets a user's password using a valid token
func (s *PasswordResetService) ResetPassword(token, newPassword string) error <span class="cov0" title="0">{
        // Validate token
        resetToken, err := s.ValidateResetToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Hash the new password using bcrypt
        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Update the password_hash column (not password)
        <span class="cov0" title="0">query := `UPDATE users SET password_hash = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`
        _, err = s.db.Exec(query, string(hashedPassword), resetToken.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        // Mark token as used
        <span class="cov0" title="0">err = s.UseResetToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark token as used: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package services

import (
        "database/sql"
        "fmt"
        "log"
        "time"

        "vaultke-backend/internal/models"

        "github.com/google/uuid"
)

// PollsService handles poll-related business logic
type PollsService struct {
        db *sql.DB
}

// NewPollsService creates a new polls service
func NewPollsService(db *sql.DB) *PollsService <span class="cov0" title="0">{
        return &amp;PollsService{db: db}
}</span>

// CreatePoll creates a new poll
func (s *PollsService) CreatePoll(chamaID, createdBy string, req *models.CreatePollRequest) (*models.Poll, error) <span class="cov0" title="0">{
        // Validate that the user has permission to create polls
        if !s.canCreatePolls(createdBy, chamaID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user does not have permission to create polls")
        }</span>

        // Validate end date is in the future
        <span class="cov0" title="0">if req.EndDate.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("end date must be in the future")
        }</span>

        // Generate unique ID
        <span class="cov0" title="0">pollID := uuid.New().String()
        now := time.Now()

        // Set defaults
        isAnonymous := true
        if req.IsAnonymous != nil </span><span class="cov0" title="0">{
                isAnonymous = *req.IsAnonymous
        }</span>

        <span class="cov0" title="0">requiresMajority := true
        if req.RequiresMajority != nil </span><span class="cov0" title="0">{
                requiresMajority = *req.RequiresMajority
        }</span>

        <span class="cov0" title="0">majorityPercentage := 50.0
        if req.MajorityPercentage != nil </span><span class="cov0" title="0">{
                majorityPercentage = *req.MajorityPercentage
        }</span>

        // Get total eligible voters
        <span class="cov0" title="0">totalVoters, err := s.getTotalEligibleVoters(chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get eligible voters: %w", err)
        }</span>

        <span class="cov0" title="0">poll := &amp;models.Poll{
                ID:                  pollID,
                ChamaID:             chamaID,
                Title:               req.Title,
                Description:         req.Description,
                PollType:            req.PollType,
                CreatedBy:           createdBy,
                StartDate:           now,
                EndDate:             req.EndDate,
                Status:              models.PollStatusActive,
                IsAnonymous:         isAnonymous,
                RequiresMajority:    requiresMajority,
                MajorityPercentage:  majorityPercentage,
                TotalEligibleVoters: totalVoters,
                TotalVotesCast:      0,
                Metadata:            req.Metadata,
                CreatedAt:           now,
                UpdatedAt:           now,
        }

        // Insert poll into database
        query := `
                INSERT INTO polls (
                        id, chama_id, title, description, poll_type, created_by, start_date, end_date,
                        status, is_anonymous, requires_majority, majority_percentage, total_eligible_voters,
                        total_votes_cast, metadata, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.Exec(
                query,
                poll.ID, poll.ChamaID, poll.Title, poll.Description, poll.PollType,
                poll.CreatedBy, poll.StartDate, poll.EndDate, poll.Status, poll.IsAnonymous,
                poll.RequiresMajority, poll.MajorityPercentage, poll.TotalEligibleVoters,
                poll.TotalVotesCast, poll.Metadata, poll.CreatedAt, poll.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create poll: %w", err)
        }</span>

        // Create poll options
        <span class="cov0" title="0">for i, optionReq := range req.Options </span><span class="cov0" title="0">{
                err = s.createPollOption(pollID, &amp;optionReq, i)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to create poll option: %v", err)
                }</span>
        }

        <span class="cov0" title="0">log.Printf("Created poll %s for chama %s by user %s", pollID, chamaID, createdBy)
        return poll, nil</span>
}

// GetChamaPolls retrieves polls for a chama
func (s *PollsService) GetChamaPolls(chamaID string, limit, offset int) ([]models.PollWithDetails, error) <span class="cov0" title="0">{
        query := `
                SELECT p.id, p.chama_id, p.title, p.description, p.poll_type, p.created_by,
                           p.start_date, p.end_date, p.status, p.is_anonymous, p.requires_majority,
                           p.majority_percentage, p.total_eligible_voters, p.total_votes_cast,
                           p.result, p.result_declared_at, p.metadata, p.created_at, p.updated_at,
                           u.first_name, u.last_name
                FROM polls p
                JOIN users u ON p.created_by = u.id
                WHERE p.chama_id = ?
                ORDER BY p.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get chama polls: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var polls []models.PollWithDetails
        for rows.Next() </span><span class="cov0" title="0">{
                var poll models.PollWithDetails
                var firstName, lastName string

                err := rows.Scan(
                        &amp;poll.ID, &amp;poll.ChamaID, &amp;poll.Title, &amp;poll.Description, &amp;poll.PollType,
                        &amp;poll.CreatedBy, &amp;poll.StartDate, &amp;poll.EndDate, &amp;poll.Status, &amp;poll.IsAnonymous,
                        &amp;poll.RequiresMajority, &amp;poll.MajorityPercentage, &amp;poll.TotalEligibleVoters,
                        &amp;poll.TotalVotesCast, &amp;poll.Result, &amp;poll.ResultDeclaredAt, &amp;poll.Metadata,
                        &amp;poll.CreatedAt, &amp;poll.UpdatedAt, &amp;firstName, &amp;lastName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan poll: %w", err)
                }</span>

                <span class="cov0" title="0">poll.CreatedByName = firstName + " " + lastName
                poll.TimeRemaining = poll.GetTimeRemaining()

                // Get poll options
                options, err := s.getPollOptions(poll.ID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to get options for poll %s: %v", poll.ID, err)
                }</span> else<span class="cov0" title="0"> {
                        poll.Options = options
                }</span>

                <span class="cov0" title="0">polls = append(polls, poll)</span>
        }

        <span class="cov0" title="0">return polls, nil</span>
}

// CastVote casts a vote in a poll
func (s *PollsService) CastVote(pollID, voterID string, req *models.CastVoteRequest) error <span class="cov0" title="0">{
        // Get poll
        poll, err := s.getPollByID(pollID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if poll is active and can accept votes
        <span class="cov0" title="0">if !poll.CanVote() </span><span class="cov0" title="0">{
                return fmt.Errorf("poll is not accepting votes")
        }</span>

        // Check if user is eligible to vote
        <span class="cov0" title="0">if !s.isEligibleToVote(voterID, poll.ChamaID) </span><span class="cov0" title="0">{
                return fmt.Errorf("user is not eligible to vote in this chama")
        }</span>

        // Check if user has already voted (using hash for anonymity)
        <span class="cov0" title="0">voterHash := models.GenerateVoterHash(voterID, pollID)
        if s.hasUserVoted(pollID, voterHash) </span><span class="cov0" title="0">{
                return fmt.Errorf("user has already voted in this poll")
        }</span>

        // Validate option exists
        <span class="cov0" title="0">if !s.isValidOption(pollID, req.OptionID) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid option selected")
        }</span>

        // Create vote record
        <span class="cov0" title="0">voteID := uuid.New().String()
        now := time.Now()

        voteQuery := `
                INSERT INTO votes (id, poll_id, option_id, voter_hash, vote_timestamp, is_valid)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.Exec(voteQuery, voteID, pollID, req.OptionID, voterHash, now, true)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cast vote: %w", err)
        }</span>

        // Update option vote count
        <span class="cov0" title="0">err = s.incrementOptionVoteCount(req.OptionID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to update option vote count: %v", err)
        }</span>

        // Update poll total votes cast
        <span class="cov0" title="0">err = s.incrementPollVoteCount(pollID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to update poll vote count: %v", err)
        }</span>

        // Check if result should be declared immediately
        <span class="cov0" title="0">options, err := s.getPollOptions(pollID)
        if err == nil &amp;&amp; poll.ShouldDeclareResult(options) </span><span class="cov0" title="0">{
                result := poll.CalculateResult(options)
                err = s.declarePollResult(pollID, result)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to declare poll result: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        // If this is a role escalation poll, process the role change
                        if poll.PollType == models.PollTypeRoleEscalation </span><span class="cov0" title="0">{
                                err = s.ProcessRoleEscalationResult(pollID, result)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Warning: Failed to process role escalation result: %v", err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">log.Printf("Vote cast in poll %s by user %s", pollID, voterID)
        return nil</span>
}

// GetPollDetails retrieves detailed information about a poll
func (s *PollsService) GetPollDetails(pollID, userID string) (*models.PollWithDetails, error) <span class="cov0" title="0">{
        poll, err := s.getPollByID(pollID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get creator name
        <span class="cov0" title="0">creatorName, err := s.getUserName(poll.CreatedBy)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to get creator name: %v", err)
                creatorName = "Unknown"
        }</span>

        // Get poll options
        <span class="cov0" title="0">options, err := s.getPollOptions(pollID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get poll options: %w", err)
        }</span>

        // Check if user has voted
        <span class="cov0" title="0">voterHash := models.GenerateVoterHash(userID, pollID)
        userVoted := s.hasUserVoted(pollID, voterHash)

        // Check if user can vote
        userCanVote := poll.CanVote() &amp;&amp; s.isEligibleToVote(userID, poll.ChamaID) &amp;&amp; !userVoted

        pollDetails := &amp;models.PollWithDetails{
                Poll:          *poll,
                CreatedByName: creatorName,
                Options:       options,
                UserVoted:     userVoted,
                UserCanVote:   userCanVote,
                TimeRemaining: poll.GetTimeRemaining(),
        }

        return pollDetails, nil</span>
}

// CreateRoleEscalationPoll creates a poll for role escalation
func (s *PollsService) CreateRoleEscalationPoll(chamaID, requestedBy string, req *models.CreateRoleEscalationRequest) (*models.RoleEscalationRequest, error) <span class="cov0" title="0">{
        // Validate that the candidate exists and is a member
        if !s.isEligibleToVote(req.CandidateID, chamaID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("candidate is not a member of this chama")
        }</span>

        // Get current role of candidate
        <span class="cov0" title="0">currentRole, err := s.getMemberRole(req.CandidateID, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get candidate's current role: %w", err)
        }</span>

        // Create role escalation request
        <span class="cov0" title="0">requestID := uuid.New().String()
        now := time.Now()

        escalationReq := &amp;models.RoleEscalationRequest{
                ID:            requestID,
                ChamaID:       chamaID,
                CandidateID:   req.CandidateID,
                CurrentRole:   currentRole,
                RequestedRole: req.RequestedRole,
                RequestedBy:   requestedBy,
                Status:        "voting",
                Justification: req.Justification,
                CreatedAt:     now,
                UpdatedAt:     now,
        }

        // Get candidate name for poll title
        candidateName, err := s.getUserName(req.CandidateID)
        if err != nil </span><span class="cov0" title="0">{
                candidateName = "Unknown"
        }</span>

        // Create poll for role escalation
        <span class="cov0" title="0">pollReq := &amp;models.CreatePollRequest{
                Title:       fmt.Sprintf("Role Change: %s to %s", candidateName, req.RequestedRole),
                Description: req.Justification,
                PollType:    models.PollTypeRoleEscalation,
                EndDate:     time.Now().Add(7 * 24 * time.Hour), // 7 days voting period
                Options: []models.PollOptionRequest{
                        {OptionText: "Approve"},
                        {OptionText: "Reject"},
                },
        }

        poll, err := s.CreatePoll(chamaID, requestedBy, pollReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create role escalation poll: %w", err)
        }</span>

        <span class="cov0" title="0">escalationReq.PollID = &amp;poll.ID

        // Insert role escalation request
        query := `
                INSERT INTO Election / Voting_requests (
                        id, chama_id, candidate_id, current_role, requested_role, requested_by,
                        poll_id, status, justification, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.Exec(
                query,
                escalationReq.ID, escalationReq.ChamaID, escalationReq.CandidateID,
                escalationReq.CurrentRole, escalationReq.RequestedRole, escalationReq.RequestedBy,
                escalationReq.PollID, escalationReq.Status, escalationReq.Justification,
                escalationReq.CreatedAt, escalationReq.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create role escalation request: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Created role escalation request %s for candidate %s", requestID, req.CandidateID)
        return escalationReq, nil</span>
}

// Helper methods
func (s *PollsService) getPollByID(pollID string) (*models.Poll, error) <span class="cov0" title="0">{
        query := `
                SELECT id, chama_id, title, description, poll_type, created_by, start_date, end_date,
                           status, is_anonymous, requires_majority, majority_percentage, total_eligible_voters,
                           total_votes_cast, result, result_declared_at, metadata, created_at, updated_at
                FROM polls WHERE id = ?
        `

        var poll models.Poll
        err := s.db.QueryRow(query, pollID).Scan(
                &amp;poll.ID, &amp;poll.ChamaID, &amp;poll.Title, &amp;poll.Description, &amp;poll.PollType,
                &amp;poll.CreatedBy, &amp;poll.StartDate, &amp;poll.EndDate, &amp;poll.Status, &amp;poll.IsAnonymous,
                &amp;poll.RequiresMajority, &amp;poll.MajorityPercentage, &amp;poll.TotalEligibleVoters,
                &amp;poll.TotalVotesCast, &amp;poll.Result, &amp;poll.ResultDeclaredAt, &amp;poll.Metadata,
                &amp;poll.CreatedAt, &amp;poll.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("poll not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get poll: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;poll, nil</span>
}

func (s *PollsService) createPollOption(pollID string, req *models.PollOptionRequest, order int) error <span class="cov0" title="0">{
        optionID := uuid.New().String()
        now := time.Now()

        query := `
                INSERT INTO poll_options (id, poll_id, option_text, option_order, vote_count, metadata, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.Exec(query, optionID, pollID, req.OptionText, order, 0, req.Metadata, now)
        return err
}</span>

func (s *PollsService) getPollOptions(pollID string) ([]models.PollOption, error) <span class="cov0" title="0">{
        query := `
                SELECT id, poll_id, option_text, option_order, vote_count, metadata, created_at
                FROM poll_options
                WHERE poll_id = ?
                ORDER BY option_order ASC
        `

        rows, err := s.db.Query(query, pollID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get poll options: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var options []models.PollOption
        for rows.Next() </span><span class="cov0" title="0">{
                var option models.PollOption
                err := rows.Scan(
                        &amp;option.ID, &amp;option.PollID, &amp;option.OptionText, &amp;option.OptionOrder,
                        &amp;option.VoteCount, &amp;option.Metadata, &amp;option.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan poll option: %w", err)
                }</span>
                <span class="cov0" title="0">options = append(options, option)</span>
        }

        <span class="cov0" title="0">return options, nil</span>
}

func (s *PollsService) getTotalEligibleVoters(chamaID string) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM chama_members WHERE chama_id = ? AND is_active = TRUE`
        var count int
        err := s.db.QueryRow(query, chamaID).Scan(&amp;count)
        return count, err
}</span>

func (s *PollsService) canCreatePolls(userID, chamaID string) bool <span class="cov0" title="0">{
        // Check if user is a chama member (any member can create general polls)
        query := `
                SELECT 1 FROM chama_members
                WHERE user_id = ? AND chama_id = ? AND is_active = TRUE
        `
        var exists int
        err := s.db.QueryRow(query, userID, chamaID).Scan(&amp;exists)
        return err == nil
}</span>

func (s *PollsService) isEligibleToVote(userID, chamaID string) bool <span class="cov0" title="0">{
        query := `
                SELECT 1 FROM chama_members
                WHERE user_id = ? AND chama_id = ? AND is_active = TRUE
        `
        var exists int
        err := s.db.QueryRow(query, userID, chamaID).Scan(&amp;exists)
        return err == nil
}</span>

func (s *PollsService) hasUserVoted(pollID, voterHash string) bool <span class="cov0" title="0">{
        query := `SELECT 1 FROM votes WHERE poll_id = ? AND voter_hash = ? AND is_valid = TRUE`
        var exists int
        err := s.db.QueryRow(query, pollID, voterHash).Scan(&amp;exists)
        return err == nil
}</span>

func (s *PollsService) isValidOption(pollID, optionID string) bool <span class="cov0" title="0">{
        query := `SELECT 1 FROM poll_options WHERE poll_id = ? AND id = ?`
        var exists int
        err := s.db.QueryRow(query, pollID, optionID).Scan(&amp;exists)
        return err == nil
}</span>

func (s *PollsService) incrementOptionVoteCount(optionID string) error <span class="cov0" title="0">{
        query := `UPDATE poll_options SET vote_count = vote_count + 1 WHERE id = ?`
        _, err := s.db.Exec(query, optionID)
        return err
}</span>

func (s *PollsService) incrementPollVoteCount(pollID string) error <span class="cov0" title="0">{
        query := `UPDATE polls SET total_votes_cast = total_votes_cast + 1, updated_at = ? WHERE id = ?`
        _, err := s.db.Exec(query, time.Now(), pollID)
        return err
}</span>

func (s *PollsService) declarePollResult(pollID string, result models.PollResult) error <span class="cov0" title="0">{
        now := time.Now()
        query := `
                UPDATE polls
                SET result = ?, result_declared_at = ?, status = ?, updated_at = ?
                WHERE id = ?
        `
        _, err := s.db.Exec(query, result, now, models.PollStatusCompleted, now, pollID)
        return err
}</span>

func (s *PollsService) getUserName(userID string) (string, error) <span class="cov0" title="0">{
        query := `SELECT first_name, last_name FROM users WHERE id = ?`
        var firstName, lastName string
        err := s.db.QueryRow(query, userID).Scan(&amp;firstName, &amp;lastName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return firstName + " " + lastName, nil</span>
}

func (s *PollsService) getMemberRole(userID, chamaID string) (string, error) <span class="cov0" title="0">{
        query := `SELECT role FROM chama_members WHERE user_id = ? AND chama_id = ? AND is_active = TRUE`
        var role string
        err := s.db.QueryRow(query, userID, chamaID).Scan(&amp;role)
        return role, err
}</span>

// ProcessRoleEscalationResult processes the result of a role escalation poll
func (s *PollsService) ProcessRoleEscalationResult(pollID string, result models.PollResult) error <span class="cov0" title="0">{
        // Get the role escalation request associated with this poll
        query := `
                SELECT id, chama_id, candidate_id, current_role, requested_role, requested_by
                FROM Election / Voting_requests
                WHERE poll_id = ?
        `

        var req models.RoleEscalationRequest
        err := s.db.QueryRow(query, pollID).Scan(
                &amp;req.ID, &amp;req.ChamaID, &amp;req.CandidateID,
                &amp;req.CurrentRole, &amp;req.RequestedRole, &amp;req.RequestedBy,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get role escalation request: %w", err)
        }</span>

        <span class="cov0" title="0">now := time.Now()

        if result == models.PollResultPassed </span><span class="cov0" title="0">{
                // Role change approved - update member roles
                err = s.executeRoleChange(&amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute role change: %w", err)
                }</span>

                // Update escalation request status
                <span class="cov0" title="0">updateQuery := `
                        UPDATE Election / Voting_requests
                        SET status = 'approved', updated_at = ?
                        WHERE id = ?
                `
                _, err = s.db.Exec(updateQuery, now, req.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update escalation request status: %w", err)
                }</span>

                <span class="cov0" title="0">log.Printf("Role escalation approved: %s changed from %s to %s in chama %s",
                        req.CandidateID, req.CurrentRole, req.RequestedRole, req.ChamaID)</span>
        } else<span class="cov0" title="0"> {
                // Role change rejected
                updateQuery := `
                        UPDATE Election / Voting_requests
                        SET status = 'rejected', updated_at = ?
                        WHERE id = ?
                `
                _, err = s.db.Exec(updateQuery, now, req.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update escalation request status: %w", err)
                }</span>

                <span class="cov0" title="0">log.Printf("Role escalation rejected for %s in chama %s", req.CandidateID, req.ChamaID)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// executeRoleChange handles the actual role change process
func (s *PollsService) executeRoleChange(req *models.RoleEscalationRequest) error <span class="cov0" title="0">{
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        now := time.Now()

        // If someone else currently holds the requested role, demote them to member
        if req.RequestedRole != "member" </span><span class="cov0" title="0">{
                demoteQuery := `
                        UPDATE chama_members
                        SET role = 'member', updated_at = ?
                        WHERE chama_id = ? AND role = ? AND user_id != ? AND is_active = TRUE
                `
                _, err = tx.Exec(demoteQuery, now, req.ChamaID, req.RequestedRole, req.CandidateID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to demote current role holder: %w", err)
                }</span>
        }

        // Update the candidate's role
        <span class="cov0" title="0">promoteQuery := `
                UPDATE chama_members
                SET role = ?, updated_at = ?
                WHERE chama_id = ? AND user_id = ? AND is_active = TRUE
        `
        _, err = tx.Exec(promoteQuery, req.RequestedRole, now, req.ChamaID, req.CandidateID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update candidate role: %w", err)
        }</span>

        // Create role change log entry
        <span class="cov0" title="0">logQuery := `
                INSERT INTO role_change_logs (
                        id, chama_id, user_id, old_role, new_role, changed_by, change_reason, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `
        logID := uuid.New().String()
        _, err = tx.Exec(logQuery, logID, req.ChamaID, req.CandidateID,
                req.CurrentRole, req.RequestedRole, req.RequestedBy,
                "Role escalation poll approved", now)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create role change log: %w", err)
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}

// GetChamaMembers retrieves all active members of a chama for role voting
func (s *PollsService) GetChamaMembers(chamaID string) ([]models.ChamaMemberInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT cm.user_id, cm.role, u.first_name, u.last_name, u.email, u.phone
                FROM chama_members cm
                JOIN users u ON cm.user_id = u.id
                WHERE cm.chama_id = ? AND cm.is_active = TRUE
                ORDER BY u.first_name, u.last_name
        `

        rows, err := s.db.Query(query, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get chama members: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var members []models.ChamaMemberInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var member models.ChamaMemberInfo
                err := rows.Scan(
                        &amp;member.UserID, &amp;member.Role, &amp;member.FirstName,
                        &amp;member.LastName, &amp;member.Email, &amp;member.Phone,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan member: %w", err)
                }</span>
                <span class="cov0" title="0">member.FullName = member.FirstName + " " + member.LastName
                members = append(members, member)</span>
        }

        <span class="cov0" title="0">return members, nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package services

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "vaultke-backend/internal/models"
)

// GetProductReviews retrieves reviews for a product
func (s *MarketplaceService) GetProductReviews(productID string) ([]*models.ProductReview, error) <span class="cov0" title="0">{
        query := `
                SELECT r.id, r.reviewer_id, r.product_id, r.order_id, r.rating, r.comment, r.images, r.created_at,
                           u.first_name, u.last_name, u.avatar
                FROM product_reviews r
                INNER JOIN users u ON r.reviewer_id = u.id
                WHERE r.product_id = ?
                ORDER BY r.created_at DESC
        `

        rows, err := s.db.Query(query, productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query reviews: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reviews []*models.ProductReview
        for rows.Next() </span><span class="cov0" title="0">{
                var review models.ProductReview
                var user models.User
                var userAvatar, imagesJSON sql.NullString

                err := rows.Scan(
                        &amp;review.ID, &amp;review.ReviewerID, &amp;review.ProductID, &amp;review.OrderID,
                        &amp;review.Rating, &amp;review.Comment, &amp;imagesJSON, &amp;review.CreatedAt,
                        &amp;user.FirstName, &amp;user.LastName, &amp;userAvatar,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse images JSON
                <span class="cov0" title="0">var images []string
                if imagesJSON.Valid &amp;&amp; imagesJSON.String != "" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal([]byte(imagesJSON.String), &amp;images); err == nil </span><span class="cov0" title="0">{
                                review.Images = images
                        }</span>
                }

                // Set user info
                <span class="cov0" title="0">user.ID = review.ReviewerID
                if userAvatar.Valid </span><span class="cov0" title="0">{
                        user.Avatar = &amp;userAvatar.String
                }</span>
                <span class="cov0" title="0">review.Reviewer = &amp;user

                reviews = append(reviews, &amp;review)</span>
        }

        <span class="cov0" title="0">return reviews, nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package services

import (
        "database/sql"
        "fmt"
        "log"
        "time"

        "vaultke-backend/internal/models"

        "github.com/google/uuid"
)

// ReminderService handles reminder-related business logic
type ReminderService struct {
        db *sql.DB
}

// NewReminderService creates a new reminder service
func NewReminderService(db *sql.DB) *ReminderService <span class="cov8" title="1">{
        return &amp;ReminderService{db: db}
}</span>

// CreateReminder creates a new reminder for a user
func (s *ReminderService) CreateReminder(userID string, req *models.CreateReminderRequest) (*models.Reminder, error) <span class="cov8" title="1">{
        // Validate that the scheduled time is in the future
        if req.ScheduledAt.Before(time.Now()) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("scheduled time must be in the future")
        }</span>

        // Generate unique ID
        <span class="cov8" title="1">reminderID := uuid.New().String()

        // Set default values
        isEnabled := true
        if req.IsEnabled != nil </span><span class="cov0" title="0">{
                isEnabled = *req.IsEnabled
        }</span>

        <span class="cov8" title="1">now := time.Now()
        reminder := &amp;models.Reminder{
                ID:           reminderID,
                UserID:       userID,
                Title:        req.Title,
                Description:  req.Description,
                ReminderType: req.ReminderType,
                ScheduledAt:  req.ScheduledAt,
                IsEnabled:    isEnabled,
                IsCompleted:  false,
                CreatedAt:    now,
                UpdatedAt:    now,
        }

        // Insert into database
        query := `
                INSERT INTO reminders (
                        id, user_id, title, description, reminder_type, 
                        scheduled_at, is_enabled, is_completed, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.Exec(
                query,
                reminder.ID,
                reminder.UserID,
                reminder.Title,
                reminder.Description,
                reminder.ReminderType,
                reminder.ScheduledAt,
                reminder.IsEnabled,
                reminder.IsCompleted,
                reminder.CreatedAt,
                reminder.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create reminder: %w", err)
        }</span>

        <span class="cov8" title="1">log.Printf("Created reminder %s for user %s", reminderID, userID)
        return reminder, nil</span>
}

// GetUserReminders retrieves all reminders for a user
func (s *ReminderService) GetUserReminders(userID string, limit, offset int) ([]models.Reminder, error) <span class="cov8" title="1">{
        query := `
                SELECT id, user_id, title, description, reminder_type, scheduled_at, 
                           is_enabled, is_completed, notification_sent, created_at, updated_at
                FROM reminders 
                WHERE user_id = ? 
                ORDER BY scheduled_at ASC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user reminders: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var reminders []models.Reminder
        for rows.Next() </span><span class="cov0" title="0">{
                var reminder models.Reminder
                err := rows.Scan(
                        &amp;reminder.ID,
                        &amp;reminder.UserID,
                        &amp;reminder.Title,
                        &amp;reminder.Description,
                        &amp;reminder.ReminderType,
                        &amp;reminder.ScheduledAt,
                        &amp;reminder.IsEnabled,
                        &amp;reminder.IsCompleted,
                        &amp;reminder.NotificationSent,
                        &amp;reminder.CreatedAt,
                        &amp;reminder.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan reminder: %w", err)
                }</span>
                <span class="cov0" title="0">reminders = append(reminders, reminder)</span>
        }

        <span class="cov8" title="1">return reminders, nil</span>
}

// GetReminderByID retrieves a specific reminder by ID
func (s *ReminderService) GetReminderByID(reminderID, userID string) (*models.Reminder, error) <span class="cov8" title="1">{
        query := `
                SELECT id, user_id, title, description, reminder_type, scheduled_at, 
                           is_enabled, is_completed, notification_sent, created_at, updated_at
                FROM reminders 
                WHERE id = ? AND user_id = ?
        `

        var reminder models.Reminder
        err := s.db.QueryRow(query, reminderID, userID).Scan(
                &amp;reminder.ID,
                &amp;reminder.UserID,
                &amp;reminder.Title,
                &amp;reminder.Description,
                &amp;reminder.ReminderType,
                &amp;reminder.ScheduledAt,
                &amp;reminder.IsEnabled,
                &amp;reminder.IsCompleted,
                &amp;reminder.NotificationSent,
                &amp;reminder.CreatedAt,
                &amp;reminder.UpdatedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("reminder not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get reminder: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;reminder, nil</span>
}

// UpdateReminder updates an existing reminder
func (s *ReminderService) UpdateReminder(reminderID, userID string, req *models.UpdateReminderRequest) (*models.Reminder, error) <span class="cov8" title="1">{
        // First, get the existing reminder
        existing, err := s.GetReminderByID(reminderID, userID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Update fields if provided
        <span class="cov0" title="0">if req.Title != nil </span><span class="cov0" title="0">{
                existing.Title = *req.Title
        }</span>
        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                existing.Description = req.Description
        }</span>
        <span class="cov0" title="0">if req.ReminderType != nil </span><span class="cov0" title="0">{
                existing.ReminderType = *req.ReminderType
        }</span>
        <span class="cov0" title="0">if req.ScheduledAt != nil </span><span class="cov0" title="0">{
                // Validate that the new scheduled time is in the future
                if req.ScheduledAt.Before(time.Now()) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scheduled time must be in the future")
                }</span>
                <span class="cov0" title="0">existing.ScheduledAt = *req.ScheduledAt</span>
        }
        <span class="cov0" title="0">if req.IsEnabled != nil </span><span class="cov0" title="0">{
                existing.IsEnabled = *req.IsEnabled
        }</span>
        <span class="cov0" title="0">if req.IsCompleted != nil </span><span class="cov0" title="0">{
                existing.IsCompleted = *req.IsCompleted
        }</span>

        <span class="cov0" title="0">existing.UpdatedAt = time.Now()

        // Update in database
        query := `
                UPDATE reminders 
                SET title = ?, description = ?, reminder_type = ?, scheduled_at = ?, 
                        is_enabled = ?, is_completed = ?, updated_at = ?
                WHERE id = ? AND user_id = ?
        `

        _, err = s.db.Exec(
                query,
                existing.Title,
                existing.Description,
                existing.ReminderType,
                existing.ScheduledAt,
                existing.IsEnabled,
                existing.IsCompleted,
                existing.UpdatedAt,
                reminderID,
                userID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update reminder: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Updated reminder %s for user %s", reminderID, userID)
        return existing, nil</span>
}

// DeleteReminder deletes a reminder
func (s *ReminderService) DeleteReminder(reminderID, userID string) error <span class="cov8" title="1">{
        query := `DELETE FROM reminders WHERE id = ? AND user_id = ?`

        result, err := s.db.Exec(query, reminderID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete reminder: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("reminder not found")
        }</span>

        <span class="cov0" title="0">log.Printf("Deleted reminder %s for user %s", reminderID, userID)
        return nil</span>
}

// GetPendingReminders retrieves reminders that need notifications sent
func (s *ReminderService) GetPendingReminders() ([]models.Reminder, error) <span class="cov0" title="0">{
        now := time.Now()

        query := `
                SELECT id, user_id, title, description, reminder_type, scheduled_at, 
                           is_enabled, is_completed, notification_sent, created_at, updated_at
                FROM reminders 
                WHERE is_enabled = TRUE 
                  AND is_completed = FALSE 
                  AND (
                    (reminder_type = 'once' AND scheduled_at &lt;= ? AND notification_sent = FALSE)
                    OR (reminder_type != 'once' AND scheduled_at &lt;= ?)
                  )
                ORDER BY scheduled_at ASC
        `

        rows, err := s.db.Query(query, now, now)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pending reminders: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reminders []models.Reminder
        for rows.Next() </span><span class="cov0" title="0">{
                var reminder models.Reminder
                err := rows.Scan(
                        &amp;reminder.ID,
                        &amp;reminder.UserID,
                        &amp;reminder.Title,
                        &amp;reminder.Description,
                        &amp;reminder.ReminderType,
                        &amp;reminder.ScheduledAt,
                        &amp;reminder.IsEnabled,
                        &amp;reminder.IsCompleted,
                        &amp;reminder.NotificationSent,
                        &amp;reminder.CreatedAt,
                        &amp;reminder.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan reminder: %w", err)
                }</span>
                <span class="cov0" title="0">reminders = append(reminders, reminder)</span>
        }

        <span class="cov0" title="0">return reminders, nil</span>
}

// MarkNotificationSent marks a reminder as having its notification sent
func (s *ReminderService) MarkNotificationSent(reminderID string) error <span class="cov0" title="0">{
        query := `UPDATE reminders SET notification_sent = TRUE WHERE id = ?`

        _, err := s.db.Exec(query, reminderID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark notification as sent: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package services

import (
        "database/sql"
        "log"
        "time"
)

// SchedulerService handles scheduled tasks like meeting auto-unlock
type SchedulerService struct {
        db             *sql.DB
        meetingService *MeetingService
        ticker         *time.Ticker
        stopChan       chan bool
}

// NewSchedulerService creates a new scheduler service
func NewSchedulerService(db *sql.DB, meetingService *MeetingService) *SchedulerService <span class="cov0" title="0">{
        return &amp;SchedulerService{
                db:             db,
                meetingService: meetingService,
                stopChan:       make(chan bool),
        }
}</span>

// Start begins the scheduler with a specified interval
func (s *SchedulerService) Start(interval time.Duration) <span class="cov0" title="0">{
        s.ticker = time.NewTicker(interval)
        
        log.Printf("Scheduler started with interval: %v", interval)
        
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-s.ticker.C:<span class="cov0" title="0">
                                s.runScheduledTasks()</span>
                        case &lt;-s.stopChan:<span class="cov0" title="0">
                                log.Println("Scheduler stopped")
                                return</span>
                        }
                }
        }()
}

// Stop stops the scheduler
func (s *SchedulerService) Stop() <span class="cov0" title="0">{
        if s.ticker != nil </span><span class="cov0" title="0">{
                s.ticker.Stop()
        }</span>
        <span class="cov0" title="0">s.stopChan &lt;- true</span>
}

// runScheduledTasks executes all scheduled tasks
func (s *SchedulerService) runScheduledTasks() <span class="cov0" title="0">{
        s.checkMeetingAutoUnlock()
        s.checkMeetingAutoEnd()
}</span>

// checkMeetingAutoUnlock checks for meetings that should be auto-unlocked (5 minutes before start)
func (s *SchedulerService) checkMeetingAutoUnlock() <span class="cov0" title="0">{
        now := time.Now()
        unlockTime := now.Add(5 * time.Minute) // 5 minutes from now
        
        query := `
                SELECT id, title, scheduled_at, meeting_type
                FROM meetings 
                WHERE status = 'scheduled' 
                AND scheduled_at &lt;= ? 
                AND scheduled_at &gt; ?
        `
        
        rows, err := s.db.Query(query, unlockTime, now)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error checking meetings for auto-unlock: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        
        var unlockedCount int
        
        for rows.Next() </span><span class="cov0" title="0">{
                var meetingID, title, meetingType string
                var scheduledAt time.Time
                
                err := rows.Scan(&amp;meetingID, &amp;title, &amp;scheduledAt, &amp;meetingType)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning meeting row: %v", err)
                        continue</span>
                }
                
                // Update meeting status to allow joining
                <span class="cov0" title="0">updateQuery := `
                        UPDATE meetings 
                        SET status = 'ready', updated_at = CURRENT_TIMESTAMP
                        WHERE id = ? AND status = 'scheduled'
                `
                
                result, err := s.db.Exec(updateQuery, meetingID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error updating meeting %s status: %v", meetingID, err)
                        continue</span>
                }
                
                <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error checking rows affected for meeting %s: %v", meetingID, err)
                        continue</span>
                }
                
                <span class="cov0" title="0">if rowsAffected &gt; 0 </span><span class="cov0" title="0">{
                        unlockedCount++
                        log.Printf("Auto-unlocked meeting: %s (%s) scheduled for %v", 
                                meetingID, title, scheduledAt.Format("2006-01-02 15:04:05"))
                        
                        // Send notifications to chama members
                        s.sendMeetingNotifications(meetingID, title, "Meeting is now available to join")
                }</span>
        }
        
        <span class="cov0" title="0">if unlockedCount &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Auto-unlocked %d meetings", unlockedCount)
        }</span>
}

// checkMeetingAutoEnd checks for meetings that should be automatically ended
func (s *SchedulerService) checkMeetingAutoEnd() <span class="cov0" title="0">{
        now := time.Now()
        
        // End meetings that have been active for more than their duration + 30 minutes grace period
        query := `
                SELECT id, title, scheduled_at, duration, started_at
                FROM meetings 
                WHERE status = 'active' 
                AND started_at IS NOT NULL
                AND datetime(started_at, '+' || (duration + 30) || ' minutes') &lt;= ?
        `
        
        rows, err := s.db.Query(query, now)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error checking meetings for auto-end: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        
        var endedCount int
        
        for rows.Next() </span><span class="cov0" title="0">{
                var meetingID, title string
                var scheduledAt, startedAt time.Time
                var duration int
                
                err := rows.Scan(&amp;meetingID, &amp;title, &amp;scheduledAt, &amp;duration, &amp;startedAt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning meeting row for auto-end: %v", err)
                        continue</span>
                }
                
                // End the meeting
                <span class="cov0" title="0">err = s.meetingService.EndMeeting(meetingID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error auto-ending meeting %s: %v", meetingID, err)
                        continue</span>
                }
                
                <span class="cov0" title="0">endedCount++
                log.Printf("Auto-ended meeting: %s (%s) that started at %v", 
                        meetingID, title, startedAt.Format("2006-01-02 15:04:05"))
                
                // Send notifications
                s.sendMeetingNotifications(meetingID, title, "Meeting has ended")</span>
        }
        
        <span class="cov0" title="0">if endedCount &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Auto-ended %d meetings", endedCount)
        }</span>
}

// sendMeetingNotifications sends notifications to chama members about meeting status changes
func (s *SchedulerService) sendMeetingNotifications(meetingID, meetingTitle, message string) <span class="cov0" title="0">{
        // Get chama ID for the meeting
        var chamaID string
        err := s.db.QueryRow("SELECT chama_id FROM meetings WHERE id = ?", meetingID).Scan(&amp;chamaID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting chama ID for meeting %s: %v", meetingID, err)
                return
        }</span>
        
        // Get all chama members
        <span class="cov0" title="0">query := `
                SELECT cm.user_id, u.first_name, u.last_name 
                FROM chama_members cm
                JOIN users u ON cm.user_id = u.id
                WHERE cm.chama_id = ? AND cm.is_active = TRUE
        `
        
        rows, err := s.db.Query(query, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting chama members for notifications: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        
        var notificationCount int
        
        for rows.Next() </span><span class="cov0" title="0">{
                var userID, firstName, lastName string
                err := rows.Scan(&amp;userID, &amp;firstName, &amp;lastName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning chama member: %v", err)
                        continue</span>
                }
                
                // Create notification
                <span class="cov0" title="0">notificationID := generateUUID()
                insertQuery := `
                        INSERT INTO notifications (
                                id, user_id, title, message, type, data, created_at
                        ) VALUES (?, ?, ?, ?, 'meeting', ?, CURRENT_TIMESTAMP)
                `
                
                notificationData := map[string]interface{}{
                        "meetingId":    meetingID,
                        "meetingTitle": meetingTitle,
                        "chamaId":      chamaID,
                }
                
                dataJSON, _ := jsonMarshal(notificationData)
                
                _, err = s.db.Exec(insertQuery, 
                        notificationID, 
                        userID, 
                        meetingTitle, 
                        message, 
                        string(dataJSON))
                
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error creating notification for user %s: %v", userID, err)
                        continue</span>
                }
                
                <span class="cov0" title="0">notificationCount++</span>
        }
        
        <span class="cov0" title="0">if notificationCount &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Sent %d notifications for meeting %s", notificationCount, meetingID)
        }</span>
}

// Helper functions (you might want to move these to a utils package)
func generateUUID() string <span class="cov0" title="0">{
        // Simple UUID generation - in production, use a proper UUID library
        return time.Now().Format("20060102150405") + "-" + randomString(8)
}</span>

func randomString(length int) string <span class="cov0" title="0">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        b := make([]byte, length)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = charset[time.Now().UnixNano()%int64(len(charset))]
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}

func jsonMarshal(v interface{}) ([]byte, error) <span class="cov0" title="0">{
        // Simple JSON marshaling - in production, use encoding/json
        return []byte("{}"), nil
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package services

import (
        "database/sql"
        "fmt"
        "log"
        "time"

        "vaultke-backend/internal/models"

        "github.com/google/uuid"
)

// SharesService handles shares-related business logic
type SharesService struct {
        db *sql.DB
}

// NewSharesService creates a new shares service
func NewSharesService(db *sql.DB) *SharesService <span class="cov0" title="0">{
        return &amp;SharesService{db: db}
}</span>

// CreateShares creates new shares for a member
func (s *SharesService) CreateShares(chamaID string, req *models.CreateShareRequest) (*models.Share, error) <span class="cov0" title="0">{
        // Validate member is part of the chama
        if !s.isMemberOfChama(req.MemberID, chamaID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member is not part of this chama")
        }</span>

        // Generate unique ID
        <span class="cov0" title="0">shareID := uuid.New().String()
        now := time.Now()

        share := &amp;models.Share{
                ID:                shareID,
                ChamaID:           chamaID,
                MemberID:          req.MemberID,
                ShareType:         req.ShareType,
                SharesOwned:       req.SharesCount,
                ShareValue:        req.ShareValue,
                PurchaseDate:      req.PurchaseDate,
                CertificateNumber: req.CertificateNumber,
                Status:            models.ShareStatusActive,
                CreatedAt:         now,
                UpdatedAt:         now,
        }

        // Calculate total value
        share.CalculateTotalValue()

        // Insert into database
        query := `
                INSERT INTO shares (
                        id, chama_id, member_id, share_type, shares_owned, share_value, 
                        total_value, purchase_date, certificate_number, status, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.Exec(
                query,
                share.ID,
                share.ChamaID,
                share.MemberID,
                share.ShareType,
                share.SharesOwned,
                share.ShareValue,
                share.TotalValue,
                share.PurchaseDate,
                share.CertificateNumber,
                share.Status,
                share.CreatedAt,
                share.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create shares: %w", err)
        }</span>

        // Create share transaction record
        <span class="cov0" title="0">_, err = s.createShareTransaction(chamaID, &amp;models.CreateShareTransactionRequest{
                ToMemberID:      &amp;req.MemberID,
                TransactionType: models.ShareTransactionPurchase,
                SharesCount:     req.SharesCount,
                ShareValue:      req.ShareValue,
                TransactionDate: req.PurchaseDate,
                Description:     stringPtr("Initial share purchase"),
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to create share transaction record: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Created shares %s for member %s in chama %s", shareID, req.MemberID, chamaID)
        return share, nil</span>
}

// GetChamaShares retrieves all shares for a chama
func (s *SharesService) GetChamaShares(chamaID string, limit, offset int) ([]models.ShareWithMemberInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT s.id, s.chama_id, s.member_id, s.share_type, s.shares_owned, s.share_value,
                           s.total_value, s.purchase_date, s.certificate_number, s.status, 
                           s.created_at, s.updated_at, u.first_name, u.last_name, u.email
                FROM shares s
                JOIN users u ON s.member_id = u.id
                WHERE s.chama_id = ? AND s.status = 'active'
                ORDER BY s.created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get chama shares: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var shares []models.ShareWithMemberInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var share models.ShareWithMemberInfo
                var firstName, lastName string

                err := rows.Scan(
                        &amp;share.ID,
                        &amp;share.ChamaID,
                        &amp;share.MemberID,
                        &amp;share.ShareType,
                        &amp;share.SharesOwned,
                        &amp;share.ShareValue,
                        &amp;share.TotalValue,
                        &amp;share.PurchaseDate,
                        &amp;share.CertificateNumber,
                        &amp;share.Status,
                        &amp;share.CreatedAt,
                        &amp;share.UpdatedAt,
                        &amp;firstName,
                        &amp;lastName,
                        &amp;share.MemberEmail,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan share: %w", err)
                }</span>

                <span class="cov0" title="0">share.MemberName = firstName + " " + lastName
                shares = append(shares, share)</span>
        }

        <span class="cov0" title="0">return shares, nil</span>
}

// GetMemberShares retrieves all shares for a specific member in a chama
func (s *SharesService) GetMemberShares(chamaID, memberID string) ([]models.Share, error) <span class="cov0" title="0">{
        query := `
                SELECT id, chama_id, member_id, share_type, shares_owned, share_value,
                           total_value, purchase_date, certificate_number, status, created_at, updated_at
                FROM shares 
                WHERE chama_id = ? AND member_id = ? AND status = 'active'
                ORDER BY purchase_date DESC
        `

        rows, err := s.db.Query(query, chamaID, memberID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get member shares: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var shares []models.Share
        for rows.Next() </span><span class="cov0" title="0">{
                var share models.Share
                err := rows.Scan(
                        &amp;share.ID,
                        &amp;share.ChamaID,
                        &amp;share.MemberID,
                        &amp;share.ShareType,
                        &amp;share.SharesOwned,
                        &amp;share.ShareValue,
                        &amp;share.TotalValue,
                        &amp;share.PurchaseDate,
                        &amp;share.CertificateNumber,
                        &amp;share.Status,
                        &amp;share.CreatedAt,
                        &amp;share.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan share: %w", err)
                }</span>
                <span class="cov0" title="0">shares = append(shares, share)</span>
        }

        <span class="cov0" title="0">return shares, nil</span>
}

// GetChamaSharesSummary retrieves aggregated share information for a chama
func (s *SharesService) GetChamaSharesSummary(chamaID string) ([]models.ShareSummary, error) <span class="cov0" title="0">{
        query := `
                SELECT s.member_id, u.first_name, u.last_name, 
                           SUM(s.shares_owned) as total_shares, 
                           SUM(s.total_value) as total_value,
                           MAX(s.purchase_date) as last_purchase
                FROM shares s
                JOIN users u ON s.member_id = u.id
                WHERE s.chama_id = ? AND s.status = 'active'
                GROUP BY s.member_id, u.first_name, u.last_name
                ORDER BY total_shares DESC
        `

        rows, err := s.db.Query(query, chamaID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error querying shares summary for chama %s: %v", chamaID, err)
                return nil, fmt.Errorf("failed to get chama shares summary: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var summaries []models.ShareSummary
        for rows.Next() </span><span class="cov0" title="0">{
                var summary models.ShareSummary
                var firstName, lastName string
                var lastPurchase sql.NullTime

                err := rows.Scan(
                        &amp;summary.MemberID,
                        &amp;firstName,
                        &amp;lastName,
                        &amp;summary.TotalShares,
                        &amp;summary.TotalValue,
                        &amp;lastPurchase,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan share summary: %w", err)
                }</span>

                <span class="cov0" title="0">summary.MemberName = firstName + " " + lastName
                if lastPurchase.Valid </span><span class="cov0" title="0">{
                        summary.LastPurchase = &amp;lastPurchase.Time
                }</span>

                // Get detailed share types for this member
                <span class="cov0" title="0">shareTypes, err := s.GetMemberShares(chamaID, summary.MemberID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to get share types for member %s: %v", summary.MemberID, err)
                }</span> else<span class="cov0" title="0"> {
                        summary.ShareTypes = shareTypes
                }</span>

                <span class="cov0" title="0">summaries = append(summaries, summary)</span>
        }

        <span class="cov0" title="0">return summaries, nil</span>
}

// UpdateShares updates existing shares
func (s *SharesService) UpdateShares(shareID string, req *models.UpdateShareRequest) (*models.Share, error) <span class="cov0" title="0">{
        // Get existing share
        existing, err := s.getShareByID(shareID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update fields if provided
        <span class="cov0" title="0">if req.SharesOwned != nil </span><span class="cov0" title="0">{
                existing.SharesOwned = *req.SharesOwned
        }</span>
        <span class="cov0" title="0">if req.ShareValue != nil </span><span class="cov0" title="0">{
                existing.ShareValue = *req.ShareValue
        }</span>
        <span class="cov0" title="0">if req.CertificateNumber != nil </span><span class="cov0" title="0">{
                existing.CertificateNumber = req.CertificateNumber
        }</span>
        <span class="cov0" title="0">if req.Status != nil </span><span class="cov0" title="0">{
                existing.Status = *req.Status
        }</span>

        // Recalculate total value
        <span class="cov0" title="0">existing.CalculateTotalValue()
        existing.UpdatedAt = time.Now()

        // Update in database
        query := `
                UPDATE shares 
                SET shares_owned = ?, share_value = ?, total_value = ?, 
                        certificate_number = ?, status = ?, updated_at = ?
                WHERE id = ?
        `

        _, err = s.db.Exec(
                query,
                existing.SharesOwned,
                existing.ShareValue,
                existing.TotalValue,
                existing.CertificateNumber,
                existing.Status,
                existing.UpdatedAt,
                shareID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update shares: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Updated shares %s", shareID)
        return existing, nil</span>
}

// Helper functions
func (s *SharesService) getShareByID(shareID string) (*models.Share, error) <span class="cov0" title="0">{
        query := `
                SELECT id, chama_id, member_id, share_type, shares_owned, share_value,
                           total_value, purchase_date, certificate_number, status, created_at, updated_at
                FROM shares WHERE id = ?
        `

        var share models.Share
        err := s.db.QueryRow(query, shareID).Scan(
                &amp;share.ID,
                &amp;share.ChamaID,
                &amp;share.MemberID,
                &amp;share.ShareType,
                &amp;share.SharesOwned,
                &amp;share.ShareValue,
                &amp;share.TotalValue,
                &amp;share.PurchaseDate,
                &amp;share.CertificateNumber,
                &amp;share.Status,
                &amp;share.CreatedAt,
                &amp;share.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("share not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get share: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;share, nil</span>
}

func (s *SharesService) isMemberOfChama(memberID, chamaID string) bool <span class="cov0" title="0">{
        query := `SELECT 1 FROM chama_members WHERE user_id = ? AND chama_id = ? AND is_active = TRUE`
        var exists int
        err := s.db.QueryRow(query, memberID, chamaID).Scan(&amp;exists)
        return err == nil
}</span>

func (s *SharesService) createShareTransaction(chamaID string, req *models.CreateShareTransactionRequest) (*models.ShareTransaction, error) <span class="cov0" title="0">{
        transactionID := uuid.New().String()
        now := time.Now()

        transaction := &amp;models.ShareTransaction{
                ID:              transactionID,
                ChamaID:         chamaID,
                FromMemberID:    req.FromMemberID,
                ToMemberID:      req.ToMemberID,
                TransactionType: req.TransactionType,
                SharesCount:     req.SharesCount,
                ShareValue:      req.ShareValue,
                TotalAmount:     float64(req.SharesCount) * req.ShareValue,
                TransactionDate: req.TransactionDate,
                Status:          models.ShareTransactionCompleted,
                Description:     req.Description,
                CreatedAt:       now,
                UpdatedAt:       now,
        }

        query := `
                INSERT INTO share_transactions (
                        id, chama_id, from_member_id, to_member_id, transaction_type,
                        shares_count, share_value, total_amount, transaction_date, status,
                        description, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.Exec(
                query,
                transaction.ID,
                transaction.ChamaID,
                transaction.FromMemberID,
                transaction.ToMemberID,
                transaction.TransactionType,
                transaction.SharesCount,
                transaction.ShareValue,
                transaction.TotalAmount,
                transaction.TransactionDate,
                transaction.Status,
                transaction.Description,
                transaction.CreatedAt,
                transaction.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create share transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return transaction, nil</span>
}

// GetShareTransactions retrieves share transactions for a chama
func (s *SharesService) GetShareTransactions(chamaID string, limit, offset int) ([]models.ShareTransaction, error) <span class="cov0" title="0">{
        query := `
                SELECT id, chama_id, from_member_id, to_member_id, transaction_type,
                           shares_count, share_value, total_amount, transaction_date, status,
                           approved_by, description, created_at, updated_at
                FROM share_transactions
                WHERE chama_id = ?
                ORDER BY transaction_date DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, chamaID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get share transactions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var transactions []models.ShareTransaction
        for rows.Next() </span><span class="cov0" title="0">{
                var transaction models.ShareTransaction
                err := rows.Scan(
                        &amp;transaction.ID,
                        &amp;transaction.ChamaID,
                        &amp;transaction.FromMemberID,
                        &amp;transaction.ToMemberID,
                        &amp;transaction.TransactionType,
                        &amp;transaction.SharesCount,
                        &amp;transaction.ShareValue,
                        &amp;transaction.TotalAmount,
                        &amp;transaction.TransactionDate,
                        &amp;transaction.Status,
                        &amp;transaction.ApprovedBy,
                        &amp;transaction.Description,
                        &amp;transaction.CreatedAt,
                        &amp;transaction.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan share transaction: %w", err)
                }</span>
                <span class="cov0" title="0">transactions = append(transactions, transaction)</span>
        }

        <span class="cov0" title="0">return transactions, nil</span>
}

func stringPtr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package services

import (
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/utils"
)

// UserService handles user-related business logic
type UserService struct {
        db *sql.DB
}

// NewUserService creates a new user service
func NewUserService(db *sql.DB) *UserService <span class="cov0" title="0">{
        return &amp;UserService{db: db}
}</span>

// CreateUser creates a new user
func (s *UserService) CreateUser(registration *models.UserRegistration) (*models.User, error) <span class="cov0" title="0">{
        // Validate input structure
        if err := utils.ValidateStruct(registration); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        // Comprehensive password validation
        <span class="cov0" title="0">if passwordErrors := utils.ValidatePassword(registration.Password); len(passwordErrors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("password validation failed: %s", strings.Join(passwordErrors, ", "))
        }</span>

        // Additional phone validation
        <span class="cov0" title="0">if !utils.ValidateKenyanPhone(registration.Phone) </span><span class="cov0" title="0">{
                return nil, errors.New("invalid Kenyan phone number format")
        }</span>

        // Sanitize all string inputs
        <span class="cov0" title="0">registration.Email = utils.SanitizeString(registration.Email)
        registration.FirstName = utils.SanitizeString(registration.FirstName)
        registration.LastName = utils.SanitizeString(registration.LastName)
        registration.Language = utils.SanitizeString(registration.Language)

        // Additional validation after sanitization
        if len(registration.FirstName) &lt; 2 || len(registration.LastName) &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("first name and last name must be at least 2 characters after sanitization")
        }</span>

        // Check if user already exists
        <span class="cov0" title="0">exists, err := s.UserExists(registration.Email, registration.Phone)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check user existence: %w", err)
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, errors.New("user with this email or phone already exists")
        }</span>

        // Hash password
        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(registration.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Format phone number
        <span class="cov0" title="0">formattedPhone := utils.FormatPhoneNumber(registration.Phone)

        // Determine user role - check if this is Samuel Okoth (admin)
        userRole := models.UserRoleUser // Default to user
        if registration.Email == "sam.okothomulo@gmail.com" </span><span class="cov0" title="0">{
                userRole = models.UserRoleAdmin
        }</span>

        // Create user
        <span class="cov0" title="0">user := &amp;models.User{
                ID:              uuid.New().String(),
                Email:           registration.Email,
                Phone:           formattedPhone,
                FirstName:       registration.FirstName,
                LastName:        registration.LastName,
                PasswordHash:    string(hashedPassword),
                Role:            userRole,
                Status:          models.UserStatusActive, // Auto-activate for development
                IsEmailVerified: false,
                IsPhoneVerified: false,
                Language:        registration.Language,
                Theme:           "dark", // Default theme
                Rating:          0,
                TotalRatings:    0,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }

        // Set default language if not provided
        if user.Language == "" </span><span class="cov0" title="0">{
                user.Language = "en"
        }</span>

        // Insert user into database
        <span class="cov0" title="0">query := `
                INSERT INTO users (
                        id, email, phone, first_name, last_name, password_hash, role, status,
                        is_email_verified, is_phone_verified, language, theme, rating, total_ratings,
                        created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.Exec(query,
                user.ID, user.Email, user.Phone, user.FirstName, user.LastName,
                user.PasswordHash, user.Role, user.Status, user.IsEmailVerified,
                user.IsPhoneVerified, user.Language, user.Theme, user.Rating,
                user.TotalRatings, user.CreatedAt, user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        // Create personal wallet for the user
        <span class="cov0" title="0">walletService := NewWalletService(s.db)
        _, err = walletService.CreateWallet(user.ID, models.WalletTypePersonal)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail user creation
                fmt.Printf("Warning: failed to create wallet for user %s: %v\n", user.ID, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// AuthenticateUser authenticates a user with email/phone and password
func (s *UserService) AuthenticateUser(login *models.UserLogin) (*models.User, error) <span class="cov0" title="0">{
        // Validate input structure
        if err := utils.ValidateStruct(login); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation error: %w", err)
        }</span>

        // Sanitize identifier
        <span class="cov0" title="0">login.Identifier = utils.SanitizeString(login.Identifier)

        // Additional validation after sanitization
        if len(login.Identifier) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        // Validate password length (basic check to prevent brute force with very long passwords)
        <span class="cov0" title="0">if len(login.Password) &gt; 128 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        // Find user by email or phone
        <span class="cov0" title="0">user, err := s.GetUserByEmailOrPhone(login.Identifier)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        // Check password
        <span class="cov0" title="0">err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(login.Password))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        // Check if user is active
        <span class="cov0" title="0">if !user.IsActive() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("account is not active")
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// GetUserByID retrieves a user by ID
func (s *UserService) GetUserByID(userID string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, email, phone, first_name, last_name, avatar, role, status,
                           is_email_verified, is_phone_verified, language, theme, county, town,
                           latitude, longitude, business_type, business_description, rating,
                           total_ratings, created_at, updated_at
                FROM users WHERE id = ?
        `

        user := &amp;models.User{}
        err := s.db.QueryRow(query, userID).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.Phone, &amp;user.FirstName, &amp;user.LastName,
                &amp;user.Avatar, &amp;user.Role, &amp;user.Status, &amp;user.IsEmailVerified,
                &amp;user.IsPhoneVerified, &amp;user.Language, &amp;user.Theme, &amp;user.County,
                &amp;user.Town, &amp;user.Latitude, &amp;user.Longitude, &amp;user.BusinessType,
                &amp;user.BusinessDescription, &amp;user.Rating, &amp;user.TotalRatings,
                &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}

// GetUserByEmailOrPhone retrieves a user by email or phone
func (s *UserService) GetUserByEmailOrPhone(identifier string) (*models.User, error) <span class="cov0" title="0">{
        // Format phone number if it looks like a phone number
        formattedIdentifier := identifier
        if utils.IsPhoneNumber(identifier) </span><span class="cov0" title="0">{
                formattedIdentifier = utils.FormatPhoneNumber(identifier)
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, email, phone, first_name, last_name, password_hash, avatar, role, status,
                           is_email_verified, is_phone_verified, language, theme, county, town,
                           latitude, longitude, business_type, business_description, rating,
                           total_ratings, created_at, updated_at
                FROM users WHERE email = ? OR phone = ?
        `

        user := &amp;models.User{}
        err := s.db.QueryRow(query, identifier, formattedIdentifier).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.Phone, &amp;user.FirstName, &amp;user.LastName,
                &amp;user.PasswordHash, &amp;user.Avatar, &amp;user.Role, &amp;user.Status,
                &amp;user.IsEmailVerified, &amp;user.IsPhoneVerified, &amp;user.Language, &amp;user.Theme,
                &amp;user.County, &amp;user.Town, &amp;user.Latitude, &amp;user.Longitude,
                &amp;user.BusinessType, &amp;user.BusinessDescription, &amp;user.Rating,
                &amp;user.TotalRatings, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}

// UpdateUser updates user information
func (s *UserService) UpdateUser(userID string, update *models.UserProfileUpdate) (*models.User, error) <span class="cov0" title="0">{
        // Get current user
        user, err := s.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Build dynamic update query
        <span class="cov0" title="0">setParts := []string{}
        args := []interface{}{}

        if update.FirstName != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "first_name = ?")
                args = append(args, *update.FirstName)
        }</span>
        <span class="cov0" title="0">if update.LastName != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "last_name = ?")
                args = append(args, *update.LastName)
        }</span>
        <span class="cov0" title="0">if update.Avatar != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "avatar = ?")
                args = append(args, *update.Avatar)
        }</span>
        <span class="cov0" title="0">if update.Language != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "language = ?")
                args = append(args, *update.Language)
        }</span>
        <span class="cov0" title="0">if update.Theme != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "theme = ?")
                args = append(args, *update.Theme)
        }</span>
        <span class="cov0" title="0">if update.County != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "county = ?")
                args = append(args, *update.County)
        }</span>
        <span class="cov0" title="0">if update.Town != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "town = ?")
                args = append(args, *update.Town)
        }</span>
        <span class="cov0" title="0">if update.Latitude != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "latitude = ?")
                args = append(args, *update.Latitude)
        }</span>
        <span class="cov0" title="0">if update.Longitude != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "longitude = ?")
                args = append(args, *update.Longitude)
        }</span>
        <span class="cov0" title="0">if update.BusinessType != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "business_type = ?")
                args = append(args, *update.BusinessType)
        }</span>
        <span class="cov0" title="0">if update.BusinessDescription != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "business_description = ?")
                args = append(args, *update.BusinessDescription)
        }</span>
        <span class="cov0" title="0">if update.Bio != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "bio = ?")
                args = append(args, *update.Bio)
        }</span>
        <span class="cov0" title="0">if update.Occupation != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "occupation = ?")
                args = append(args, *update.Occupation)
        }</span>
        <span class="cov0" title="0">if update.DateOfBirth != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "date_of_birth = ?")
                args = append(args, update.DateOfBirth.Time)
        }</span>

        <span class="cov0" title="0">if len(setParts) == 0 </span><span class="cov0" title="0">{
                return user, nil // No updates
        }</span>

        // Add updated_at
        <span class="cov0" title="0">setParts = append(setParts, "updated_at = ?")
        args = append(args, time.Now())
        args = append(args, userID)

        query := "UPDATE users SET " + setParts[0]
        for i := 1; i &lt; len(setParts); i++ </span><span class="cov0" title="0">{
                query += ", " + setParts[i]
        }</span>
        <span class="cov0" title="0">query += " WHERE id = ?"

        _, err = s.db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        // Return updated user
        <span class="cov0" title="0">return s.GetUserByID(userID)</span>
}

// UserExists checks if a user exists with the given email or phone
func (s *UserService) UserExists(email, phone string) (bool, error) <span class="cov0" title="0">{
        formattedPhone := utils.FormatPhoneNumber(phone)

        query := "SELECT COUNT(*) FROM users WHERE email = ? OR phone = ?"
        var count int
        err := s.db.QueryRow(query, email, formattedPhone).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check user existence: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// VerifyEmail marks user's email as verified
func (s *UserService) VerifyEmail(userID string) error <span class="cov0" title="0">{
        query := "UPDATE users SET is_email_verified = true, updated_at = ? WHERE id = ?"
        _, err := s.db.Exec(query, time.Now(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify email: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// VerifyPhone marks user's phone as verified
func (s *UserService) VerifyPhone(userID string) error <span class="cov0" title="0">{
        query := "UPDATE users SET is_phone_verified = true, updated_at = ? WHERE id = ?"
        _, err := s.db.Exec(query, time.Now(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify phone: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateUserStatus updates user status
func (s *UserService) UpdateUserStatus(userID string, status models.UserStatus) error <span class="cov0" title="0">{
        query := "UPDATE users SET status = ?, updated_at = ? WHERE id = ?"
        _, err := s.db.Exec(query, status, time.Now(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user status: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetUsersByLocation gets users by location (county/town)
func (s *UserService) GetUsersByLocation(county, town string, limit, offset int) ([]*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, email, phone, first_name, last_name, avatar, role, status,
                           is_email_verified, is_phone_verified, language, theme, county, town,
                           latitude, longitude, business_type, business_description, rating,
                           total_ratings, created_at, updated_at
                FROM users
                WHERE county = ? AND town = ? AND status = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, county, town, models.UserStatusActive, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get users by location: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []*models.User
        for rows.Next() </span><span class="cov0" title="0">{
                user := &amp;models.User{}
                err := rows.Scan(
                        &amp;user.ID, &amp;user.Email, &amp;user.Phone, &amp;user.FirstName, &amp;user.LastName,
                        &amp;user.Avatar, &amp;user.Role, &amp;user.Status, &amp;user.IsEmailVerified,
                        &amp;user.IsPhoneVerified, &amp;user.Language, &amp;user.Theme, &amp;user.County,
                        &amp;user.Town, &amp;user.Latitude, &amp;user.Longitude, &amp;user.BusinessType,
                        &amp;user.BusinessDescription, &amp;user.Rating, &amp;user.TotalRatings,
                        &amp;user.CreatedAt, &amp;user.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user: %w", err)
                }</span>
                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package services

import (
        "database/sql"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/google/uuid"

        "vaultke-backend/internal/models"
        "vaultke-backend/internal/utils"
)

// WalletService handles wallet-related business logic
type WalletService struct {
        db *sql.DB
}

// NewWalletService creates a new wallet service
func NewWalletService(db *sql.DB) *WalletService <span class="cov8" title="1">{
        return &amp;WalletService{db: db}
}</span>

// CreateWallet creates a new wallet
func (s *WalletService) CreateWallet(ownerID string, walletType models.WalletType) (*models.Wallet, error) <span class="cov0" title="0">{
        return s.CreateWalletWithTx(nil, ownerID, walletType)
}</span>

// CreateWalletWithTx creates a new wallet within an existing transaction
func (s *WalletService) CreateWalletWithTx(tx *sql.Tx, ownerID string, walletType models.WalletType) (*models.Wallet, error) <span class="cov0" title="0">{
        wallet := &amp;models.Wallet{
                ID:        uuid.New().String(),
                Type:      walletType,
                OwnerID:   ownerID,
                Balance:   0,
                Currency:  "KES",
                IsActive:  true,
                IsLocked:  false,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        query := `
                INSERT INTO wallets (id, type, owner_id, balance, currency, is_active, is_locked, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        var err error
        if tx != nil </span><span class="cov0" title="0">{
                // Use the provided transaction
                _, err = tx.Exec(query,
                        wallet.ID, wallet.Type, wallet.OwnerID, wallet.Balance, wallet.Currency,
                        wallet.IsActive, wallet.IsLocked, wallet.CreatedAt, wallet.UpdatedAt,
                )
        }</span> else<span class="cov0" title="0"> {
                // Use the database directly
                _, err = s.db.Exec(query,
                        wallet.ID, wallet.Type, wallet.OwnerID, wallet.Balance, wallet.Currency,
                        wallet.IsActive, wallet.IsLocked, wallet.CreatedAt, wallet.UpdatedAt,
                )
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create wallet: %w", err)
        }</span>

        <span class="cov0" title="0">return wallet, nil</span>
}

// GetWalletByID retrieves a wallet by ID
func (s *WalletService) GetWalletByID(walletID string) (*models.Wallet, error) <span class="cov8" title="1">{
        query := `
                SELECT id, type, owner_id, balance, currency, is_active, is_locked,
                           daily_limit, monthly_limit, created_at, updated_at
                FROM wallets WHERE id = ?
        `

        wallet := &amp;models.Wallet{}
        err := s.db.QueryRow(query, walletID).Scan(
                &amp;wallet.ID, &amp;wallet.Type, &amp;wallet.OwnerID, &amp;wallet.Balance, &amp;wallet.Currency,
                &amp;wallet.IsActive, &amp;wallet.IsLocked, &amp;wallet.DailyLimit, &amp;wallet.MonthlyLimit,
                &amp;wallet.CreatedAt, &amp;wallet.UpdatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("wallet not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get wallet: %w", err)</span>
        }

        <span class="cov8" title="1">return wallet, nil</span>
}

// GetWalletsByOwner retrieves all wallets for an owner
func (s *WalletService) GetWalletsByOwner(ownerID string) ([]*models.Wallet, error) <span class="cov8" title="1">{
        query := `
                SELECT id, type, owner_id, balance, currency, is_active, is_locked,
                           daily_limit, monthly_limit, created_at, updated_at
                FROM wallets WHERE owner_id = ? ORDER BY created_at ASC
        `

        rows, err := s.db.Query(query, ownerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get wallets: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var wallets []*models.Wallet
        for rows.Next() </span><span class="cov8" title="1">{
                wallet := &amp;models.Wallet{}
                err := rows.Scan(
                        &amp;wallet.ID, &amp;wallet.Type, &amp;wallet.OwnerID, &amp;wallet.Balance, &amp;wallet.Currency,
                        &amp;wallet.IsActive, &amp;wallet.IsLocked, &amp;wallet.DailyLimit, &amp;wallet.MonthlyLimit,
                        &amp;wallet.CreatedAt, &amp;wallet.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan wallet: %w", err)
                }</span>
                <span class="cov8" title="1">wallets = append(wallets, wallet)</span>
        }

        <span class="cov8" title="1">return wallets, nil</span>
}

// GetWalletByOwnerAndType retrieves a wallet by owner and type
func (s *WalletService) GetWalletByOwnerAndType(ownerID string, walletType models.WalletType) (*models.Wallet, error) <span class="cov8" title="1">{
        query := `
                SELECT id, type, owner_id, balance, currency, is_active, is_locked,
                           daily_limit, monthly_limit, created_at, updated_at
                FROM wallets WHERE owner_id = ? AND type = ?
        `

        wallet := &amp;models.Wallet{}
        err := s.db.QueryRow(query, ownerID, walletType).Scan(
                &amp;wallet.ID, &amp;wallet.Type, &amp;wallet.OwnerID, &amp;wallet.Balance, &amp;wallet.Currency,
                &amp;wallet.IsActive, &amp;wallet.IsLocked, &amp;wallet.DailyLimit, &amp;wallet.MonthlyLimit,
                &amp;wallet.CreatedAt, &amp;wallet.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("wallet not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get wallet: %w", err)</span>
        }

        <span class="cov8" title="1">return wallet, nil</span>
}

// UpdateWalletBalance updates wallet balance
func (s *WalletService) UpdateWalletBalance(walletID string, newBalance float64) error <span class="cov0" title="0">{
        query := "UPDATE wallets SET balance = ?, updated_at = ? WHERE id = ?"
        _, err := s.db.Exec(query, newBalance, time.Now(), walletID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update wallet balance: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// LockWallet locks a wallet
func (s *WalletService) LockWallet(walletID string) error <span class="cov0" title="0">{
        query := "UPDATE wallets SET is_locked = true, updated_at = ? WHERE id = ?"
        _, err := s.db.Exec(query, time.Now(), walletID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to lock wallet: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UnlockWallet unlocks a wallet
func (s *WalletService) UnlockWallet(walletID string) error <span class="cov0" title="0">{
        query := "UPDATE wallets SET is_locked = false, updated_at = ? WHERE id = ?"
        _, err := s.db.Exec(query, time.Now(), walletID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unlock wallet: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateTransaction creates a new transaction
func (s *WalletService) CreateTransaction(transaction *models.TransactionCreation, initiatedBy string) (*models.Transaction, error) <span class="cov0" title="0">{
        // Create transaction
        tx := &amp;models.Transaction{
                ID:               uuid.New().String(),
                FromWalletID:     transaction.FromWalletID,
                ToWalletID:       transaction.ToWalletID,
                Type:             transaction.Type,
                Status:           models.TransactionStatusPending,
                Amount:           transaction.Amount,
                Currency:         "KES",
                Description:      transaction.Description,
                PaymentMethod:    transaction.PaymentMethod,
                Metadata:         transaction.Metadata,
                Fees:             0, // Calculate fees based on transaction type
                InitiatedBy:      initiatedBy,
                RequiresApproval: false, // Set based on business rules
                CreatedAt:        time.Now(),
                UpdatedAt:        time.Now(),
        }

        // Calculate fees
        tx.Fees = s.calculateTransactionFees(tx)

        // Check if transaction requires approval
        tx.RequiresApproval = s.requiresApproval(tx)

        // Get metadata JSON
        metadataJSON, err := tx.GetMetadataJSON()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to serialize metadata: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO transactions (
                        id, from_wallet_id, to_wallet_id, type, status, amount, currency,
                        description, reference, payment_method, metadata, fees, initiated_by,
                        requires_approval, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.Exec(query,
                tx.ID, tx.FromWalletID, tx.ToWalletID, tx.Type, tx.Status, tx.Amount,
                tx.Currency, tx.Description, tx.Reference, tx.PaymentMethod, metadataJSON,
                tx.Fees, tx.InitiatedBy, tx.RequiresApproval, tx.CreatedAt, tx.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return tx, nil</span>
}

// ProcessTransaction processes a transaction (updates wallet balances)
func (s *WalletService) ProcessTransaction(transactionID string) error <span class="cov0" title="0">{
        // Get transaction
        transaction, err := s.GetTransactionByID(transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if transaction can be processed
        <span class="cov0" title="0">if transaction.Status != models.TransactionStatusPending </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction is not in pending status")
        }</span>

        // Start database transaction
        <span class="cov0" title="0">dbTx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer dbTx.Rollback()

        // Process based on transaction type
        switch transaction.Type </span>{
        case models.TransactionTypeDeposit:<span class="cov0" title="0">
                err = s.processDeposit(dbTx, transaction)</span>
        case models.TransactionTypeWithdrawal:<span class="cov0" title="0">
                err = s.processWithdrawal(dbTx, transaction)</span>
        case models.TransactionTypeTransfer:<span class="cov0" title="0">
                err = s.processTransfer(dbTx, transaction)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported transaction type: %s", transaction.Type)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update transaction status using centralized function
        <span class="cov0" title="0">err = s.updateTransactionStatus(dbTx, transactionID, models.TransactionStatusCompleted)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update transaction status: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = dbTx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTransactionByID retrieves a transaction by ID
func (s *WalletService) GetTransactionByID(transactionID string) (*models.Transaction, error) <span class="cov0" title="0">{
        query := `
                SELECT id, from_wallet_id, to_wallet_id, type, status, amount, currency,
                           description, reference, payment_method, metadata, fees, initiated_by,
                           approved_by, requires_approval, approval_deadline, created_at, updated_at
                FROM transactions WHERE id = ?
        `

        transaction := &amp;models.Transaction{}
        var metadataJSON sql.NullString
        err := s.db.QueryRow(query, transactionID).Scan(
                &amp;transaction.ID, &amp;transaction.FromWalletID, &amp;transaction.ToWalletID,
                &amp;transaction.Type, &amp;transaction.Status, &amp;transaction.Amount, &amp;transaction.Currency,
                &amp;transaction.Description, &amp;transaction.Reference, &amp;transaction.PaymentMethod,
                &amp;metadataJSON, &amp;transaction.Fees, &amp;transaction.InitiatedBy, &amp;transaction.ApprovedBy,
                &amp;transaction.RequiresApproval, &amp;transaction.ApprovalDeadline, &amp;transaction.CreatedAt,
                &amp;transaction.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("transaction not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get transaction: %w", err)</span>
        }

        // Parse metadata
        <span class="cov0" title="0">metadataStr := "{}"
        if metadataJSON.Valid </span><span class="cov0" title="0">{
                metadataStr = metadataJSON.String
        }</span>
        <span class="cov0" title="0">if err = transaction.SetMetadataFromJSON(metadataStr); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse metadata: %w", err)
        }</span>

        <span class="cov0" title="0">return transaction, nil</span>
}

// GetWalletTransactions retrieves transactions for a wallet
func (s *WalletService) GetWalletTransactions(walletID string, limit, offset int) ([]*models.Transaction, error) <span class="cov8" title="1">{
        query := `
                SELECT id, from_wallet_id, to_wallet_id, type, status, amount, currency,
                           description, reference, payment_method, metadata, fees, initiated_by,
                           approved_by, requires_approval, approval_deadline, created_at, updated_at
                FROM transactions
                WHERE from_wallet_id = ? OR to_wallet_id = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, walletID, walletID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get wallet transactions: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var transactions []*models.Transaction
        for rows.Next() </span><span class="cov0" title="0">{
                transaction := &amp;models.Transaction{}
                var metadataJSON sql.NullString
                err := rows.Scan(
                        &amp;transaction.ID, &amp;transaction.FromWalletID, &amp;transaction.ToWalletID,
                        &amp;transaction.Type, &amp;transaction.Status, &amp;transaction.Amount, &amp;transaction.Currency,
                        &amp;transaction.Description, &amp;transaction.Reference, &amp;transaction.PaymentMethod,
                        &amp;metadataJSON, &amp;transaction.Fees, &amp;transaction.InitiatedBy, &amp;transaction.ApprovedBy,
                        &amp;transaction.RequiresApproval, &amp;transaction.ApprovalDeadline, &amp;transaction.CreatedAt,
                        &amp;transaction.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan transaction: %w", err)
                }</span>

                // Parse metadata
                <span class="cov0" title="0">metadataStr := "{}"
                if metadataJSON.Valid </span><span class="cov0" title="0">{
                        metadataStr = metadataJSON.String
                }</span>
                <span class="cov0" title="0">if err = transaction.SetMetadataFromJSON(metadataStr); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse metadata: %w", err)
                }</span>

                <span class="cov0" title="0">transactions = append(transactions, transaction)</span>
        }

        <span class="cov8" title="1">return transactions, nil</span>
}

// updateTransactionStatus updates transaction status within a database transaction
func (s *WalletService) updateTransactionStatus(tx *sql.Tx, transactionID string, status models.TransactionStatus) error <span class="cov0" title="0">{
        updateQuery := "UPDATE transactions SET status = ?, updated_at = ? WHERE id = ?"
        result, err := tx.Exec(updateQuery, status, utils.NowEAT(), transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update transaction status: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction not found: %s", transactionID)
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully updated transaction %s status to %s", transactionID, status)
        return nil</span>
}

// Helper methods

func (s *WalletService) calculateTransactionFees(transaction *models.Transaction) float64 <span class="cov0" title="0">{
        // Simple fee calculation - can be made more sophisticated
        switch transaction.Type </span>{
        case models.TransactionTypeWithdrawal:<span class="cov0" title="0">
                if transaction.PaymentMethod == models.PaymentMethodMpesa </span><span class="cov0" title="0">{
                        return 10.0 // Fixed M-Pesa withdrawal fee
                }</span>
                <span class="cov0" title="0">return 5.0</span> // Other withdrawal fees
        case models.TransactionTypeTransfer:<span class="cov0" title="0">
                return 2.0</span> // Transfer fee
        default:<span class="cov0" title="0">
                return 0.0</span> // No fees for deposits and other types
        }
}

func (s *WalletService) requiresApproval(transaction *models.Transaction) bool <span class="cov0" title="0">{
        // Business rules for approval requirements
        if transaction.Amount &gt; 50000 </span><span class="cov0" title="0">{ // Large amounts require approval
                return true
        }</span>
        <span class="cov0" title="0">if transaction.Type == models.TransactionTypeLoan </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *WalletService) processDeposit(tx *sql.Tx, transaction *models.Transaction) error <span class="cov0" title="0">{
        if transaction.ToWalletID == nil </span><span class="cov0" title="0">{
                return errors.New("to_wallet_id is required for deposits")
        }</span>

        // Get current balance
        <span class="cov0" title="0">var currentBalance float64
        err := tx.QueryRow("SELECT balance FROM wallets WHERE id = ?", *transaction.ToWalletID).Scan(&amp;currentBalance)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get wallet balance: %w", err)
        }</span>

        // Update balance
        <span class="cov0" title="0">newBalance := currentBalance + transaction.Amount
        _, err = tx.Exec("UPDATE wallets SET balance = ?, updated_at = ? WHERE id = ?",
                newBalance, time.Now(), *transaction.ToWalletID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update wallet balance: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *WalletService) processWithdrawal(tx *sql.Tx, transaction *models.Transaction) error <span class="cov0" title="0">{
        if transaction.FromWalletID == nil </span><span class="cov0" title="0">{
                return errors.New("from_wallet_id is required for withdrawals")
        }</span>

        // Get current balance
        <span class="cov0" title="0">var currentBalance float64
        err := tx.QueryRow("SELECT balance FROM wallets WHERE id = ?", *transaction.FromWalletID).Scan(&amp;currentBalance)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get wallet balance: %w", err)
        }</span>

        // Check sufficient balance (including fees)
        <span class="cov0" title="0">totalAmount := transaction.Amount + transaction.Fees
        if currentBalance &lt; totalAmount </span><span class="cov0" title="0">{
                return errors.New("insufficient balance")
        }</span>

        // Update balance
        <span class="cov0" title="0">newBalance := currentBalance - totalAmount
        _, err = tx.Exec("UPDATE wallets SET balance = ?, updated_at = ? WHERE id = ?",
                newBalance, time.Now(), *transaction.FromWalletID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update wallet balance: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *WalletService) processTransfer(tx *sql.Tx, transaction *models.Transaction) error <span class="cov0" title="0">{
        if transaction.FromWalletID == nil || transaction.ToWalletID == nil </span><span class="cov0" title="0">{
                return errors.New("both from_wallet_id and to_wallet_id are required for transfers")
        }</span>

        // Process withdrawal from source wallet
        <span class="cov0" title="0">err := s.processWithdrawal(tx, transaction)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Process deposit to destination wallet
        <span class="cov0" title="0">depositTransaction := *transaction
        depositTransaction.Type = models.TransactionTypeDeposit
        depositTransaction.Fees = 0 // Fees already deducted from source
        err = s.processDeposit(tx, &amp;depositTransaction)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package services

import (
        "log"
        "net/http"
        "strconv"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
)

// WebSocketMessage represents a message sent over WebSocket
type WebSocketMessage struct {
        Type    string      `json:"type"`
        RoomID  string      `json:"roomId,omitempty"`
        UserID  string      `json:"userId,omitempty"`
        Data    interface{} `json:"data,omitempty"`
        Message string      `json:"message,omitempty"`
}

// Client represents a WebSocket client
type Client struct {
        ID     string
        UserID string
        Conn   *websocket.Conn
        Send   chan WebSocketMessage
        Hub    *Hub
}

// Hub maintains the set of active clients and broadcasts messages to the clients
type Hub struct {
        // Registered clients
        clients map[*Client]bool

        // Inbound messages from the clients
        broadcast chan WebSocketMessage

        // Register requests from the clients
        register chan *Client

        // Unregister requests from clients
        unregister chan *Client

        // Room subscriptions - maps roomID to clients
        rooms map[string]map[*Client]bool

        // User connections - maps userID to clients
        users map[string]*Client

        mutex sync.RWMutex
}

// WebSocketService handles WebSocket connections and real-time messaging
type WebSocketService struct {
        hub      *Hub
        upgrader websocket.Upgrader
}

// NewWebSocketService creates a new WebSocket service
func NewWebSocketService() *WebSocketService <span class="cov8" title="1">{
        hub := &amp;Hub{
                clients:    make(map[*Client]bool),
                broadcast:  make(chan WebSocketMessage),
                register:   make(chan *Client),
                unregister: make(chan *Client),
                rooms:      make(map[string]map[*Client]bool),
                users:      make(map[string]*Client),
        }

        service := &amp;WebSocketService{
                hub: hub,
                upgrader: websocket.Upgrader{
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                // Allow connections from any origin in development
                                // In production, you should check the origin properly
                                return true
                        }</span>,
                },
        }

        // Start the hub
        <span class="cov8" title="1">go hub.run()

        return service</span>
}

// HandleWebSocket handles WebSocket connections
func (s *WebSocketService) HandleWebSocket(c *gin.Context) <span class="cov0" title="0">{
        // Try to get user ID from context first (set by auth middleware)
        userID, exists := c.Get("userID")

        // If not in context, try to get from query parameter
        if !exists </span><span class="cov0" title="0">{
                token := c.Query("token")
                if token == "" </span><span class="cov0" title="0">{
                        log.Printf("WebSocket connection rejected: no token provided")
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - no token"})
                        return
                }</span>

                // Here you would validate the token and extract userID
                // For now, we'll use a simple approach - in production, use proper JWT validation
                <span class="cov0" title="0">tokenPreview := token
                if len(token) &gt; 20 </span><span class="cov0" title="0">{
                        tokenPreview = token[:20] + "..."
                }</span>
                <span class="cov0" title="0">log.Printf("WebSocket token received: %s", tokenPreview)

                // Set a placeholder userID - in production, extract from validated JWT
                userID = "temp_user_from_token"
                c.Set("userID", userID)</span>
        }

        // Upgrade HTTP connection to WebSocket
        <span class="cov0" title="0">conn, err := s.upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WebSocket upgrade error: %v", err)
                return
        }</span>

        // Create client
        <span class="cov0" title="0">client := &amp;Client{
                ID:     generateClientID(),
                UserID: userID.(string),
                Conn:   conn,
                Send:   make(chan WebSocketMessage, 256),
                Hub:    s.hub,
        }

        // Register client
        s.hub.register &lt;- client

        // Start goroutines for reading and writing
        go client.writePump()
        go client.readPump()</span>
}

// BroadcastToRoom sends a message to all clients in a specific room
func (s *WebSocketService) BroadcastToRoom(roomID string, message WebSocketMessage) <span class="cov8" title="1">{
        message.RoomID = roomID
        s.hub.broadcast &lt;- message
}</span>

// SendToUser sends a message to a specific user
func (s *WebSocketService) SendToUser(userID string, message WebSocketMessage) <span class="cov8" title="1">{
        s.hub.mutex.RLock()
        client, exists := s.hub.users[userID]
        s.hub.mutex.RUnlock()

        if exists </span><span class="cov0" title="0">{
                select </span>{
                case client.Send &lt;- message:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        close(client.Send)
                        delete(s.hub.users, userID)</span>
                }
        }
}

// Hub methods
func (h *Hub) run() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case client := &lt;-h.register:<span class="cov0" title="0">
                        h.mutex.Lock()
                        h.clients[client] = true
                        h.users[client.UserID] = client
                        h.mutex.Unlock()

                        // Send connection confirmation
                        select </span>{
                        case client.Send &lt;- WebSocketMessage{Type: "connected", Message: "Connected to chat server"}:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                close(client.Send)
                                delete(h.clients, client)
                                delete(h.users, client.UserID)</span>
                        }

                case client := &lt;-h.unregister:<span class="cov0" title="0">
                        h.mutex.Lock()
                        if _, ok := h.clients[client]; ok </span><span class="cov0" title="0">{
                                delete(h.clients, client)
                                delete(h.users, client.UserID)
                                close(client.Send)

                                // Remove from all rooms
                                for roomID, roomClients := range h.rooms </span><span class="cov0" title="0">{
                                        if _, inRoom := roomClients[client]; inRoom </span><span class="cov0" title="0">{
                                                delete(roomClients, client)
                                                if len(roomClients) == 0 </span><span class="cov0" title="0">{
                                                        delete(h.rooms, roomID)
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">h.mutex.Unlock()</span>

                case message := &lt;-h.broadcast:<span class="cov8" title="1">
                        h.mutex.RLock()
                        if message.RoomID != "" </span><span class="cov8" title="1">{
                                // Broadcast to specific room
                                if roomClients, exists := h.rooms[message.RoomID]; exists </span><span class="cov0" title="0">{
                                        for client := range roomClients </span><span class="cov0" title="0">{
                                                select </span>{
                                                case client.Send &lt;- message:<span class="cov0" title="0"></span>
                                                default:<span class="cov0" title="0">
                                                        close(client.Send)
                                                        delete(h.clients, client)
                                                        delete(h.users, client.UserID)
                                                        delete(roomClients, client)</span>
                                                }
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                // Broadcast to all clients
                                for client := range h.clients </span><span class="cov0" title="0">{
                                        select </span>{
                                        case client.Send &lt;- message:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0">
                                                close(client.Send)
                                                delete(h.clients, client)
                                                delete(h.users, client.UserID)</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">h.mutex.RUnlock()</span>
                }
        }
}

// JoinRoom adds a client to a room
func (h *Hub) JoinRoom(client *Client, roomID string) <span class="cov0" title="0">{
        h.mutex.Lock()
        defer h.mutex.Unlock()

        if h.rooms[roomID] == nil </span><span class="cov0" title="0">{
                h.rooms[roomID] = make(map[*Client]bool)
        }</span>
        <span class="cov0" title="0">h.rooms[roomID][client] = true</span>
}

// LeaveRoom removes a client from a room
func (h *Hub) LeaveRoom(client *Client, roomID string) <span class="cov0" title="0">{
        h.mutex.Lock()
        defer h.mutex.Unlock()

        if roomClients, exists := h.rooms[roomID]; exists </span><span class="cov0" title="0">{
                delete(roomClients, client)
                if len(roomClients) == 0 </span><span class="cov0" title="0">{
                        delete(h.rooms, roomID)
                }</span>
        }
}

// Client methods
func (c *Client) readPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.Hub.unregister &lt;- c
                c.Conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                var message WebSocketMessage
                err := c.Conn.ReadJSON(&amp;message)
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WebSocket error: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // Handle different message types
                <span class="cov0" title="0">switch message.Type </span>{
                case "join_room":<span class="cov0" title="0">
                        if message.RoomID != "" </span><span class="cov0" title="0">{
                                c.Hub.JoinRoom(c, message.RoomID)
                        }</span>
                case "leave_room":<span class="cov0" title="0">
                        if message.RoomID != "" </span><span class="cov0" title="0">{
                                c.Hub.LeaveRoom(c, message.RoomID)
                        }</span>
                case "ping":<span class="cov0" title="0">
                        // Send pong response
                        select </span>{
                        case c.Send &lt;- WebSocketMessage{Type: "pong"}:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }
}

func (c *Client) writePump() <span class="cov0" title="0">{
        defer c.Conn.Close()

        for  </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.Send:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">if err := c.Conn.WriteJSON(message); err != nil </span><span class="cov0" title="0">{
                                log.Printf("WebSocket write error: %v", err)
                                return
                        }</span>
                }
        }
}

// Helper function to generate client ID
func generateClientID() string <span class="cov0" title="0">{
        // Simple client ID generation - in production, use UUID
        return "client_" + strconv.FormatInt(time.Now().UnixNano(), 10)
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "vaultke-backend/internal/models"
        "vaultke-backend/internal/utils"

        "github.com/google/uuid"
)

// RemoveFromWishlist removes a product from user's wishlist
func (s *MarketplaceService) RemoveFromWishlist(userID, productID string) error <span class="cov0" title="0">{
        result, err := s.db.Exec(
                "DELETE FROM wishlist WHERE user_id = ? AND product_id = ?",
                userID, productID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove from wishlist: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("item not found in wishlist")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetWishlist retrieves user's wishlist (only in-stock products)
func (s *MarketplaceService) GetWishlist(userID string) ([]*models.WishlistItem, error) <span class="cov0" title="0">{
        query := `
                SELECT w.id, w.user_id, w.product_id, w.added_at,
                           p.id, p.name, p.description, p.category, p.price, p.currency, p.images,
                           p.status, p.stock, p.seller_id, p.county, p.town
                FROM wishlist w
                INNER JOIN products p ON w.product_id = p.id
                WHERE w.user_id = ? AND p.status = ? AND p.stock &gt; 0
                ORDER BY w.added_at DESC
        `

        rows, err := s.db.Query(query, userID, models.ProductStatusActive)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query wishlist: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var wishlistItems []*models.WishlistItem
        for rows.Next() </span><span class="cov0" title="0">{
                var item models.WishlistItem
                var product models.Product
                var images string

                err := rows.Scan(
                        &amp;item.ID, &amp;item.UserID, &amp;item.ProductID, &amp;item.AddedAt,
                        &amp;product.ID, &amp;product.Name, &amp;product.Description, &amp;product.Category,
                        &amp;product.Price, &amp;product.Currency, &amp;images, &amp;product.Status,
                        &amp;product.Stock, &amp;product.SellerID, &amp;product.County, &amp;product.Town,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse images JSON
                <span class="cov0" title="0">if images != "" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal([]byte(images), &amp;product.Images); err != nil </span><span class="cov0" title="0">{
                                product.Images = []string{}
                        }</span>
                }

                <span class="cov0" title="0">item.Product = &amp;product
                wishlistItems = append(wishlistItems, &amp;item)</span>
        }

        <span class="cov0" title="0">return wishlistItems, nil</span>
}

// AddToWishlist adds a product to user's wishlist
func (s *MarketplaceService) AddToWishlist(userID, productID string) error <span class="cov0" title="0">{
        // Check if already in wishlist
        var exists bool
        err := s.db.QueryRow(
                "SELECT EXISTS(SELECT 1 FROM wishlist WHERE user_id = ? AND product_id = ?)",
                userID, productID,
        ).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check wishlist: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("product already in wishlist")
        }</span>

        // Add to wishlist
        <span class="cov0" title="0">_, err = s.db.Exec(
                "INSERT INTO wishlist (id, user_id, product_id, added_at) VALUES (?, ?, ?, ?)",
                uuid.New().String(), userID, productID, utils.NowEAT(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add to wishlist: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package utils

import (
        "crypto/rand"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "log"
        "math"
        "regexp"
        "strconv"
        "strings"
        "time"
)

// East African Time timezone
var EATLocation *time.Location

func init() <span class="cov8" title="1">{
        // Load East African Time timezone (UTC+3)
        var err error
        EATLocation, err = time.LoadLocation("Africa/Nairobi")
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to fixed offset if timezone data is not available
                EATLocation = time.FixedZone("EAT", 3*60*60) // UTC+3
                log.Printf("Warning: Could not load Africa/Nairobi timezone, using fixed offset: %v", err)
        }</span>
}

// NowEAT returns the current time in East African Time
func NowEAT() time.Time <span class="cov0" title="0">{
        return time.Now().In(EATLocation)
}</span>

// ToEAT converts a time to East African Time
func ToEAT(t time.Time) time.Time <span class="cov0" title="0">{
        return t.In(EATLocation)
}</span>

// ParseTimeEAT parses a time string and returns it in EAT
func ParseTimeEAT(layout, value string) (time.Time, error) <span class="cov0" title="0">{
        t, err := time.Parse(layout, value)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">return t.In(EATLocation), nil</span>
}

// FormatTimeEAT formats a time in EAT with the given layout
func FormatTimeEAT(t time.Time, layout string) string <span class="cov0" title="0">{
        return t.In(EATLocation).Format(layout)
}</span>

// FormatCurrency formats a number as Kenyan Shilling currency
func FormatCurrency(amount float64) string <span class="cov0" title="0">{
        return fmt.Sprintf("KSh %.2f", amount)
}</span>

// FormatPhoneNumber formats a phone number to international format
func FormatPhoneNumber(phone string) string <span class="cov0" title="0">{
        // Remove all non-digit characters
        cleaned := regexp.MustCompile(`\D`).ReplaceAllString(phone, "")

        // Handle different formats
        if strings.HasPrefix(cleaned, "254") </span><span class="cov0" title="0">{
                return "+" + cleaned
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(cleaned, "0") &amp;&amp; len(cleaned) == 10 </span><span class="cov0" title="0">{
                return "+254" + cleaned[1:]
        }</span> else<span class="cov0" title="0"> if len(cleaned) == 9 </span><span class="cov0" title="0">{
                return "+254" + cleaned
        }</span>

        // Return as-is if format is unclear
        <span class="cov0" title="0">return phone</span>
}

// ParsePhoneNumber extracts the phone number without country code
func ParsePhoneNumber(phone string) string <span class="cov0" title="0">{
        formatted := FormatPhoneNumber(phone)
        if strings.HasPrefix(formatted, "+254") </span><span class="cov0" title="0">{
                return "0" + formatted[4:]
        }</span>
        <span class="cov0" title="0">return phone</span>
}

// GenerateRandomString generates a random string of specified length
func GenerateRandomString(length int) string <span class="cov0" title="0">{
        bytes := make([]byte, length/2)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes)[:length]</span>
}

// GenerateOTP generates a numeric OTP of specified length
func GenerateOTP(length int) string <span class="cov0" title="0">{
        if length &lt;= 0 </span><span class="cov0" title="0">{
                length = 6
        }</span>

        <span class="cov0" title="0">bytes := make([]byte, length)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "123456" // Fallback
        }</span>

        <span class="cov0" title="0">otp := ""
        for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                otp += strconv.Itoa(int(bytes[i]) % 10)
        }</span>

        <span class="cov0" title="0">return otp</span>
}

// Slugify converts a string to a URL-friendly slug
func Slugify(text string) string <span class="cov0" title="0">{
        // Convert to lowercase
        slug := strings.ToLower(text)

        // Replace spaces and special characters with hyphens
        slug = regexp.MustCompile(`[^a-z0-9]+`).ReplaceAllString(slug, "-")

        // Remove leading and trailing hyphens
        slug = strings.Trim(slug, "-")

        return slug
}</span>

// TruncateString truncates a string to specified length with ellipsis
func TruncateString(text string, maxLength int) string <span class="cov0" title="0">{
        if len(text) &lt;= maxLength </span><span class="cov0" title="0">{
                return text
        }</span>

        <span class="cov0" title="0">if maxLength &lt;= 3 </span><span class="cov0" title="0">{
                return text[:maxLength]
        }</span>

        <span class="cov0" title="0">return text[:maxLength-3] + "..."</span>
}

// CalculateDistance calculates distance between two coordinates in kilometers
func CalculateDistance(lat1, lon1, lat2, lon2 float64) float64 <span class="cov0" title="0">{
        const earthRadius = 6371 // Earth's radius in kilometers

        // Convert degrees to radians
        lat1Rad := lat1 * math.Pi / 180
        lon1Rad := lon1 * math.Pi / 180
        lat2Rad := lat2 * math.Pi / 180
        lon2Rad := lon2 * math.Pi / 180

        // Haversine formula
        dlat := lat2Rad - lat1Rad
        dlon := lon2Rad - lon1Rad

        a := math.Sin(dlat/2)*math.Sin(dlat/2) +
                math.Cos(lat1Rad)*math.Cos(lat2Rad)*math.Sin(dlon/2)*math.Sin(dlon/2)
        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

        return earthRadius * c
}</span>

// FormatDate formats a time.Time to a readable string in EAT
func FormatDate(t time.Time, format string) string <span class="cov0" title="0">{
        // Convert to EAT first
        eatTime := ToEAT(t)

        switch format </span>{
        case "short":<span class="cov0" title="0">
                return eatTime.Format("02/01/2006")</span>
        case "long":<span class="cov0" title="0">
                return eatTime.Format("02 January 2006")</span>
        case "datetime":<span class="cov0" title="0">
                return eatTime.Format("02/01/2006 15:04")</span>
        case "time":<span class="cov0" title="0">
                return eatTime.Format("15:04")</span>
        case "iso":<span class="cov0" title="0">
                return eatTime.Format(time.RFC3339)</span>
        case "api":<span class="cov0" title="0">
                // Format for API responses - ISO format but in EAT
                return eatTime.Format("2006-01-02T15:04:05Z07:00")</span>
        default:<span class="cov0" title="0">
                return eatTime.Format("02/01/2006")</span>
        }
}

// ParseDate parses a date string in various formats
func ParseDate(dateStr string) (time.Time, error) <span class="cov0" title="0">{
        formats := []string{
                "2006-01-02",
                "02/01/2006",
                "02-01-2006",
                "2006-01-02 15:04:05",
                "02/01/2006 15:04",
                time.RFC3339,
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                if t, err := time.Parse(format, dateStr); err == nil </span><span class="cov0" title="0">{
                        return t, nil
                }</span>
        }

        <span class="cov0" title="0">return time.Time{}, fmt.Errorf("unable to parse date: %s", dateStr)</span>
}

// GetTimeAgo returns a human-readable time difference in EAT
func GetTimeAgo(t time.Time) string <span class="cov0" title="0">{
        now := NowEAT()
        eatTime := ToEAT(t)
        diff := now.Sub(eatTime)

        if diff &lt; time.Minute </span><span class="cov0" title="0">{
                return "just now"
        }</span> else<span class="cov0" title="0"> if diff &lt; time.Hour </span><span class="cov0" title="0">{
                minutes := int(diff.Minutes())
                if minutes == 1 </span><span class="cov0" title="0">{
                        return "1 minute ago"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d minutes ago", minutes)</span>
        } else<span class="cov0" title="0"> if diff &lt; 24*time.Hour </span><span class="cov0" title="0">{
                hours := int(diff.Hours())
                if hours == 1 </span><span class="cov0" title="0">{
                        return "1 hour ago"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d hours ago", hours)</span>
        } else<span class="cov0" title="0"> if diff &lt; 7*24*time.Hour </span><span class="cov0" title="0">{
                days := int(diff.Hours() / 24)
                if days == 1 </span><span class="cov0" title="0">{
                        return "1 day ago"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d days ago", days)</span>
        } else<span class="cov0" title="0"> if diff &lt; 30*24*time.Hour </span><span class="cov0" title="0">{
                weeks := int(diff.Hours() / (24 * 7))
                if weeks == 1 </span><span class="cov0" title="0">{
                        return "1 week ago"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d weeks ago", weeks)</span>
        } else<span class="cov0" title="0"> if diff &lt; 365*24*time.Hour </span><span class="cov0" title="0">{
                months := int(diff.Hours() / (24 * 30))
                if months == 1 </span><span class="cov0" title="0">{
                        return "1 month ago"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d months ago", months)</span>
        } else<span class="cov0" title="0"> {
                years := int(diff.Hours() / (24 * 365))
                if years == 1 </span><span class="cov0" title="0">{
                        return "1 year ago"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d years ago", years)</span>
        }
}

// RoundToDecimalPlaces rounds a float to specified decimal places
func RoundToDecimalPlaces(value float64, places int) float64 <span class="cov0" title="0">{
        multiplier := math.Pow(10, float64(places))
        return math.Round(value*multiplier) / multiplier
}</span>

// CalculatePercentage calculates percentage of part from total
func CalculatePercentage(part, total float64) float64 <span class="cov0" title="0">{
        if total == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return (part / total) * 100</span>
}

// CalculatePercentageChange calculates percentage change between old and new values
func CalculatePercentageChange(oldValue, newValue float64) float64 <span class="cov0" title="0">{
        if oldValue == 0 </span><span class="cov0" title="0">{
                if newValue == 0 </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">return 100</span> // 100% increase from 0
        }
        <span class="cov0" title="0">return ((newValue - oldValue) / oldValue) * 100</span>
}

// IsWeekend checks if a date is weekend (Saturday or Sunday)
func IsWeekend(t time.Time) bool <span class="cov0" title="0">{
        weekday := t.Weekday()
        return weekday == time.Saturday || weekday == time.Sunday
}</span>

// IsBusinessDay checks if a date is a business day (Monday to Friday)
func IsBusinessDay(t time.Time) bool <span class="cov0" title="0">{
        return !IsWeekend(t)
}</span>

// GetNextBusinessDay returns the next business day
func GetNextBusinessDay(t time.Time) time.Time <span class="cov0" title="0">{
        next := t.AddDate(0, 0, 1)
        for IsWeekend(next) </span><span class="cov0" title="0">{
                next = next.AddDate(0, 0, 1)
        }</span>
        <span class="cov0" title="0">return next</span>
}

// GetStartOfDay returns the start of day (00:00:00) for given time
func GetStartOfDay(t time.Time) time.Time <span class="cov0" title="0">{
        return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())
}</span>

// GetEndOfDay returns the end of day (23:59:59) for given time
func GetEndOfDay(t time.Time) time.Time <span class="cov0" title="0">{
        return time.Date(t.Year(), t.Month(), t.Day(), 23, 59, 59, 999999999, t.Location())
}</span>

// GetStartOfMonth returns the start of month for given time
func GetStartOfMonth(t time.Time) time.Time <span class="cov0" title="0">{
        return time.Date(t.Year(), t.Month(), 1, 0, 0, 0, 0, t.Location())
}</span>

// GetEndOfMonth returns the end of month for given time
func GetEndOfMonth(t time.Time) time.Time <span class="cov0" title="0">{
        return GetStartOfMonth(t).AddDate(0, 1, 0).Add(-time.Nanosecond)
}</span>

// Contains checks if a slice contains a specific item
func Contains[T comparable](slice []T, item T) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// RemoveDuplicates removes duplicate items from a slice
func RemoveDuplicates[T comparable](slice []T) []T <span class="cov0" title="0">{
        keys := make(map[T]bool)
        var result []T

        for _, item := range slice </span><span class="cov0" title="0">{
                if !keys[item] </span><span class="cov0" title="0">{
                        keys[item] = true
                        result = append(result, item)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ChunkSlice splits a slice into chunks of specified size
func ChunkSlice[T any](slice []T, chunkSize int) [][]T <span class="cov0" title="0">{
        if chunkSize &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var chunks [][]T
        for i := 0; i &lt; len(slice); i += chunkSize </span><span class="cov0" title="0">{
                end := i + chunkSize
                if end &gt; len(slice) </span><span class="cov0" title="0">{
                        end = len(slice)
                }</span>
                <span class="cov0" title="0">chunks = append(chunks, slice[i:end])</span>
        }

        <span class="cov0" title="0">return chunks</span>
}

// SafeStringPointer safely converts string to *string
func SafeStringPointer(s string) *string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;s</span>
}

// SafeIntPointer safely converts int to *int
func SafeIntPointer(i int) *int <span class="cov0" title="0">{
        if i == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;i</span>
}

// SafeFloat64Pointer safely converts float64 to *float64
func SafeFloat64Pointer(f float64) *float64 <span class="cov0" title="0">{
        if f == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;f</span>
}

// DerefString safely dereferences a string pointer
func DerefString(s *string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *s</span>
}

// DerefInt safely dereferences an int pointer
func DerefInt(i *int) int <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return *i</span>
}

// DerefFloat64 safely dereferences a float64 pointer
func DerefFloat64(f *float64) float64 <span class="cov0" title="0">{
        if f == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return *f</span>
}

// JSONMarshal marshals data to JSON
func JSONMarshal(v interface{}) ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(v)
}</span>

// JSONUnmarshal unmarshals JSON data
func JSONUnmarshal(data []byte, v interface{}) error <span class="cov0" title="0">{
        return json.Unmarshal(data, v)
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package utils

import (
        "crypto/rand"
        "fmt"
        "math/big"
        "regexp"
        "strings"
        "time"
)

// RoomNameGenerator provides methods for generating consistent room names
type RoomNameGenerator struct{}

// NewRoomNameGenerator creates a new room name generator
func NewRoomNameGenerator() *RoomNameGenerator <span class="cov0" title="0">{
        return &amp;RoomNameGenerator{}
}</span>

// GenerateRoomName generates a consistent room name for a meeting
// Format: chama_{chamaId}_{meetingId}_{timestamp}
func (g *RoomNameGenerator) GenerateRoomName(chamaID, meetingID string) string <span class="cov0" title="0">{
        // Clean the IDs to ensure they're safe for room names
        cleanChamaID := g.cleanID(chamaID)
        cleanMeetingID := g.cleanID(meetingID)
        
        // Add timestamp for uniqueness
        timestamp := time.Now().Unix()
        
        roomName := fmt.Sprintf("chama_%s_meeting_%s_%d", cleanChamaID, cleanMeetingID, timestamp)
        
        // Ensure the room name is valid (alphanumeric, hyphens, underscores only)
        roomName = g.sanitizeRoomName(roomName)
        
        return roomName
}</span>

// GenerateShortRoomName generates a shorter room name for better UX
// Format: chama_{shortId}_{randomSuffix}
func (g *RoomNameGenerator) GenerateShortRoomName(chamaID, meetingID string) string <span class="cov0" title="0">{
        // Take first 8 characters of chama ID
        shortChamaID := g.cleanID(chamaID)
        if len(shortChamaID) &gt; 8 </span><span class="cov0" title="0">{
                shortChamaID = shortChamaID[:8]
        }</span>
        
        // Take first 8 characters of meeting ID
        <span class="cov0" title="0">shortMeetingID := g.cleanID(meetingID)
        if len(shortMeetingID) &gt; 8 </span><span class="cov0" title="0">{
                shortMeetingID = shortMeetingID[:8]
        }</span>
        
        // Generate random suffix for uniqueness
        <span class="cov0" title="0">randomSuffix := g.generateRandomString(6)
        
        roomName := fmt.Sprintf("chama_%s_%s_%s", shortChamaID, shortMeetingID, randomSuffix)
        
        return g.sanitizeRoomName(roomName)</span>
}

// GenerateUserFriendlyRoomName generates a human-readable room name
// Format: {ChamaName}_{MeetingTitle}_{Date}
func (g *RoomNameGenerator) GenerateUserFriendlyRoomName(chamaName, meetingTitle string, meetingDate time.Time) string <span class="cov0" title="0">{
        // Clean and truncate names
        cleanChamaName := g.cleanAndTruncate(chamaName, 15)
        cleanMeetingTitle := g.cleanAndTruncate(meetingTitle, 20)
        
        // Format date as YYYYMMDD
        dateStr := meetingDate.Format("20060102")
        
        roomName := fmt.Sprintf("%s_%s_%s", cleanChamaName, cleanMeetingTitle, dateStr)
        
        return g.sanitizeRoomName(roomName)
}</span>

// GetRoomNameFromMeeting extracts or generates room name from meeting data
func (g *RoomNameGenerator) GetRoomNameFromMeeting(chamaID, meetingID, chamaName, meetingTitle string, meetingDate time.Time, existingRoomName string) string <span class="cov0" title="0">{
        // If room name already exists and is valid, use it
        if existingRoomName != "" &amp;&amp; g.isValidRoomName(existingRoomName) </span><span class="cov0" title="0">{
                return existingRoomName
        }</span>
        
        // Try to generate user-friendly name first
        <span class="cov0" title="0">if chamaName != "" &amp;&amp; meetingTitle != "" </span><span class="cov0" title="0">{
                return g.GenerateUserFriendlyRoomName(chamaName, meetingTitle, meetingDate)
        }</span>
        
        // Fallback to short room name
        <span class="cov0" title="0">return g.GenerateShortRoomName(chamaID, meetingID)</span>
}

// cleanID removes special characters and keeps only alphanumeric and safe characters
func (g *RoomNameGenerator) cleanID(id string) string <span class="cov0" title="0">{
        // Remove common prefixes
        id = strings.TrimPrefix(id, "meeting-")
        id = strings.TrimPrefix(id, "chama-")
        
        // Keep only alphanumeric characters and hyphens
        reg := regexp.MustCompile(`[^a-zA-Z0-9\-]`)
        cleaned := reg.ReplaceAllString(id, "")
        
        // Remove consecutive hyphens
        reg = regexp.MustCompile(`-+`)
        cleaned = reg.ReplaceAllString(cleaned, "-")
        
        // Trim hyphens from start and end
        cleaned = strings.Trim(cleaned, "-")
        
        return cleaned
}</span>

// cleanAndTruncate cleans a string and truncates it to maxLength
func (g *RoomNameGenerator) cleanAndTruncate(str string, maxLength int) string <span class="cov0" title="0">{
        // Convert to lowercase and replace spaces with underscores
        cleaned := strings.ToLower(str)
        cleaned = strings.ReplaceAll(cleaned, " ", "_")
        
        // Remove special characters except underscores and hyphens
        reg := regexp.MustCompile(`[^a-z0-9_\-]`)
        cleaned = reg.ReplaceAllString(cleaned, "")
        
        // Remove consecutive underscores/hyphens
        reg = regexp.MustCompile(`[_\-]+`)
        cleaned = reg.ReplaceAllString(cleaned, "_")
        
        // Trim underscores from start and end
        cleaned = strings.Trim(cleaned, "_-")
        
        // Truncate if too long
        if len(cleaned) &gt; maxLength </span><span class="cov0" title="0">{
                cleaned = cleaned[:maxLength]
        }</span>
        
        // Ensure it's not empty
        <span class="cov0" title="0">if cleaned == "" </span><span class="cov0" title="0">{
                cleaned = "meeting"
        }</span>
        
        <span class="cov0" title="0">return cleaned</span>
}

// sanitizeRoomName ensures the room name meets LiveKit requirements
func (g *RoomNameGenerator) sanitizeRoomName(roomName string) string <span class="cov0" title="0">{
        // LiveKit room names should be alphanumeric with underscores and hyphens
        reg := regexp.MustCompile(`[^a-zA-Z0-9_\-]`)
        sanitized := reg.ReplaceAllString(roomName, "_")
        
        // Remove consecutive underscores
        reg = regexp.MustCompile(`_+`)
        sanitized = reg.ReplaceAllString(sanitized, "_")
        
        // Trim underscores from start and end
        sanitized = strings.Trim(sanitized, "_-")
        
        // Ensure minimum length
        if len(sanitized) &lt; 3 </span><span class="cov0" title="0">{
                sanitized = sanitized + "_room"
        }</span>
        
        // Ensure maximum length (LiveKit has limits)
        <span class="cov0" title="0">if len(sanitized) &gt; 63 </span><span class="cov0" title="0">{
                sanitized = sanitized[:63]
        }</span>
        
        <span class="cov0" title="0">return sanitized</span>
}

// isValidRoomName checks if a room name is valid for LiveKit
func (g *RoomNameGenerator) isValidRoomName(roomName string) bool <span class="cov0" title="0">{
        if roomName == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check length
        <span class="cov0" title="0">if len(roomName) &lt; 1 || len(roomName) &gt; 63 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check characters (alphanumeric, underscores, hyphens only)
        <span class="cov0" title="0">reg := regexp.MustCompile(`^[a-zA-Z0-9_\-]+$`)
        return reg.MatchString(roomName)</span>
}

// generateRandomString generates a random alphanumeric string of given length
func (g *RoomNameGenerator) generateRandomString(length int) string <span class="cov0" title="0">{
        const charset = "abcdefghijklmnopqrstuvwxyz0123456789"
        result := make([]byte, length)
        
        for i := range result </span><span class="cov0" title="0">{
                num, _ := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
                result[i] = charset[num.Int64()]
        }</span>
        
        <span class="cov0" title="0">return string(result)</span>
}

// GetRoomDisplayName generates a user-friendly display name for the room
func (g *RoomNameGenerator) GetRoomDisplayName(chamaName, meetingTitle string) string <span class="cov0" title="0">{
        if chamaName != "" &amp;&amp; meetingTitle != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s - %s", chamaName, meetingTitle)
        }</span>
        <span class="cov0" title="0">if meetingTitle != "" </span><span class="cov0" title="0">{
                return meetingTitle
        }</span>
        <span class="cov0" title="0">if chamaName != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s Meeting", chamaName)
        }</span>
        <span class="cov0" title="0">return "Meeting Room"</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package utils

import (
        "fmt"
        "reflect"
        "regexp"
        "strings"
)

// ValidationError represents a validation error
type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

// ValidationErrors represents multiple validation errors
type ValidationErrors []ValidationError

func (ve ValidationErrors) Error() string <span class="cov0" title="0">{
        var messages []string
        for _, err := range ve </span><span class="cov0" title="0">{
                messages = append(messages, fmt.Sprintf("%s: %s", err.Field, err.Message))
        }</span>
        <span class="cov0" title="0">return strings.Join(messages, ", ")</span>
}

// ValidateStruct validates a struct using reflection and struct tags
func ValidateStruct(s interface{}) error <span class="cov0" title="0">{
        var errors ValidationErrors

        v := reflect.ValueOf(s)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        <span class="cov0" title="0">if v.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return fmt.Errorf("expected struct, got %s", v.Kind())
        }</span>

        <span class="cov0" title="0">t := v.Type()

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                field := v.Field(i)
                fieldType := t.Field(i)

                // Skip unexported fields
                if !field.CanInterface() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get validation tag
                <span class="cov0" title="0">validateTag := fieldType.Tag.Get("validate")
                if validateTag == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse validation rules
                <span class="cov0" title="0">rules := strings.Split(validateTag, ",")
                for _, rule := range rules </span><span class="cov0" title="0">{
                        rule = strings.TrimSpace(rule)
                        if err := validateField(fieldType.Name, field, rule); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, *err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateField validates a single field against a rule
func validateField(fieldName string, field reflect.Value, rule string) *ValidationError <span class="cov0" title="0">{
        parts := strings.Split(rule, "=")
        ruleName := parts[0]
        var ruleValue string
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                ruleValue = parts[1]
        }</span>

        <span class="cov0" title="0">switch ruleName </span>{
        case "required":<span class="cov0" title="0">
                if isEmpty(field) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{
                                Field:   fieldName,
                                Message: "is required",
                        }
                }</span>
        case "email":<span class="cov0" title="0">
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        email := field.String()
                        if email != "" &amp;&amp; !IsValidEmail(email) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: "must be a valid email address",
                                }
                        }</span>
                }
        case "phone":<span class="cov0" title="0">
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        phone := field.String()
                        if phone != "" &amp;&amp; !IsPhoneNumber(phone) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: "must be a valid phone number",
                                }
                        }</span>
                }
        case "min":<span class="cov0" title="0">
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        if len(field.String()) &lt; parseIntOrDefault(ruleValue, 0) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: fmt.Sprintf("must be at least %s characters", ruleValue),
                                }
                        }</span>
                } else<span class="cov0" title="0"> if isNumeric(field) </span><span class="cov0" title="0">{
                        if getNumericValue(field) &lt; float64(parseIntOrDefault(ruleValue, 0)) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: fmt.Sprintf("must be at least %s", ruleValue),
                                }
                        }</span>
                }
        case "max":<span class="cov0" title="0">
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        if len(field.String()) &gt; parseIntOrDefault(ruleValue, 0) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: fmt.Sprintf("must be at most %s characters", ruleValue),
                                }
                        }</span>
                } else<span class="cov0" title="0"> if isNumeric(field) </span><span class="cov0" title="0">{
                        if getNumericValue(field) &gt; float64(parseIntOrDefault(ruleValue, 0)) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: fmt.Sprintf("must be at most %s", ruleValue),
                                }
                        }</span>
                }
        case "gt":<span class="cov0" title="0">
                if isNumeric(field) </span><span class="cov0" title="0">{
                        if getNumericValue(field) &lt;= float64(parseIntOrDefault(ruleValue, 0)) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: fmt.Sprintf("must be greater than %s", ruleValue),
                                }
                        }</span>
                }
        case "gte":<span class="cov0" title="0">
                if isNumeric(field) </span><span class="cov0" title="0">{
                        if getNumericValue(field) &lt; float64(parseIntOrDefault(ruleValue, 0)) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: fmt.Sprintf("must be greater than or equal to %s", ruleValue),
                                }
                        }</span>
                }
        case "lt":<span class="cov0" title="0">
                if isNumeric(field) </span><span class="cov0" title="0">{
                        if getNumericValue(field) &gt;= float64(parseIntOrDefault(ruleValue, 0)) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: fmt.Sprintf("must be less than %s", ruleValue),
                                }
                        }</span>
                }
        case "lte":<span class="cov0" title="0">
                if isNumeric(field) </span><span class="cov0" title="0">{
                        if getNumericValue(field) &gt; float64(parseIntOrDefault(ruleValue, 0)) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: fmt.Sprintf("must be less than or equal to %s", ruleValue),
                                }
                        }</span>
                }
        case "alphanumeric":<span class="cov0" title="0">
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        str := field.String()
                        if str != "" &amp;&amp; !regexp.MustCompile(`^[a-zA-Z0-9]+$`).MatchString(str) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: "must contain only letters and numbers",
                                }
                        }</span>
                }
        case "alpha":<span class="cov0" title="0">
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        str := field.String()
                        if str != "" &amp;&amp; !regexp.MustCompile(`^[a-zA-Z\s]+$`).MatchString(str) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: "must contain only letters and spaces",
                                }
                        }</span>
                }
        case "numeric":<span class="cov0" title="0">
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        str := field.String()
                        if str != "" &amp;&amp; !regexp.MustCompile(`^[0-9]+$`).MatchString(str) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: "must contain only numbers",
                                }
                        }</span>
                }
        case "no_sql_injection":<span class="cov0" title="0">
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        str := strings.ToLower(field.String())
                        dangerous := []string{
                                "'", "\"", ";", "--", "/*", "*/", "xp_", "sp_", "exec", "execute",
                                "select", "insert", "update", "delete", "drop", "create", "alter",
                                "union", "script", "javascript", "vbscript", "onload", "onerror",
                                "&lt;script", "&lt;/script", "eval(", "expression(", "url(", "import(",
                                "truncate", "grant", "revoke", "declare", "cast", "convert",
                        }
                        for _, pattern := range dangerous </span><span class="cov0" title="0">{
                                if strings.Contains(str, pattern) </span><span class="cov0" title="0">{
                                        return &amp;ValidationError{
                                                Field:   fieldName,
                                                Message: "contains potentially dangerous characters",
                                        }
                                }</span>
                        }
                }
        case "no_xss":<span class="cov0" title="0">
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        str := strings.ToLower(field.String())
                        xssPatterns := []string{
                                "&lt;script", "&lt;/script", "javascript:", "vbscript:", "onload=", "onerror=",
                                "onclick=", "onmouseover=", "onfocus=", "onblur=", "onchange=", "onsubmit=",
                                "&lt;iframe", "&lt;object", "&lt;embed", "&lt;link", "&lt;meta", "data:text/html",
                                "eval(", "expression(", "url(javascript:", "&amp;#", "&amp;#x", "&lt;svg",
                                "&lt;img", "onerror", "onmouseover", "onfocus", "onblur", "onchange",
                        }
                        for _, pattern := range xssPatterns </span><span class="cov0" title="0">{
                                if strings.Contains(str, pattern) </span><span class="cov0" title="0">{
                                        return &amp;ValidationError{
                                                Field:   fieldName,
                                                Message: "contains potentially malicious content",
                                        }
                                }</span>
                        }
                }
        case "amount":<span class="cov0" title="0">
                if isNumeric(field) </span><span class="cov0" title="0">{
                        value := getNumericValue(field)
                        if value &lt; 0 || value &gt; 100000000 </span><span class="cov0" title="0">{ // Max 100M KES
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: "amount must be between 0 and 100,000,000",
                                }
                        }</span>
                }
        case "safe_text":<span class="cov0" title="0">
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        str := field.String()
                        // Allow letters, numbers, spaces, and safe punctuation
                        if str != "" &amp;&amp; !regexp.MustCompile(`^[a-zA-Z0-9\s\.\,\!\?\-\_\(\)]+$`).MatchString(str) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: "contains invalid characters",
                                }
                        }</span>
                }
        case "url_safe":<span class="cov0" title="0">
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        str := field.String()
                        if str != "" &amp;&amp; !regexp.MustCompile(`^[a-zA-Z0-9\-\_\.\/\:]+$`).MatchString(str) </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        Field:   fieldName,
                                        Message: "must be URL safe",
                                }
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// isEmpty checks if a field is empty
func isEmpty(field reflect.Value) bool <span class="cov0" title="0">{
        switch field.Kind() </span>{
        case reflect.String:<span class="cov0" title="0">
                return field.String() == ""</span>
        case reflect.Slice, reflect.Map, reflect.Array:<span class="cov0" title="0">
                return field.Len() == 0</span>
        case reflect.Ptr, reflect.Interface:<span class="cov0" title="0">
                return field.IsNil()</span>
        case reflect.Invalid:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// isNumeric checks if a field is numeric
func isNumeric(field reflect.Value) bool <span class="cov0" title="0">{
        switch field.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return true</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return true</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// getNumericValue gets the numeric value as float64
func getNumericValue(field reflect.Value) float64 <span class="cov0" title="0">{
        switch field.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return float64(field.Int())</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return float64(field.Uint())</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return field.Float()</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// parseIntOrDefault parses an integer or returns default value
func parseIntOrDefault(s string, defaultValue int) int <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">var result int
        fmt.Sscanf(s, "%d", &amp;result)
        return result</span>
}

// IsValidEmail validates email format
func IsValidEmail(email string) bool <span class="cov0" title="0">{
        emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        return emailRegex.MatchString(email)
}</span>

// IsPhoneNumber checks if a string looks like a phone number
func IsPhoneNumber(phone string) bool <span class="cov0" title="0">{
        // Remove spaces and common separators
        cleaned := regexp.MustCompile(`[\s\-\(\)]+`).ReplaceAllString(phone, "")

        // Check for Kenyan phone number patterns
        kenyanPhoneRegex := regexp.MustCompile(`^(\+254|254|0)[17]\d{8}$`)
        return kenyanPhoneRegex.MatchString(cleaned)
}</span>

// ValidateKenyanPhone validates Kenyan phone number format
func ValidateKenyanPhone(phone string) bool <span class="cov0" title="0">{
        // Remove spaces and common separators
        cleaned := regexp.MustCompile(`[\s\-\(\)]+`).ReplaceAllString(phone, "")

        // Kenyan phone number patterns:
        // +254712345678, 254712345678, 0712345678
        // Networks: 7xx (Safaricom), 1xx (Airtel)
        kenyanPhoneRegex := regexp.MustCompile(`^(\+254|254|0)[17]\d{8}$`)
        return kenyanPhoneRegex.MatchString(cleaned)
}</span>

// ValidatePassword validates password strength
func ValidatePassword(password string) []string <span class="cov0" title="0">{
        var errors []string

        if len(password) &lt; 8 </span><span class="cov0" title="0">{
                errors = append(errors, "Password must be at least 8 characters long")
        }</span>

        <span class="cov0" title="0">if len(password) &gt; 128 </span><span class="cov0" title="0">{
                errors = append(errors, "Password must be at most 128 characters long")
        }</span>

        <span class="cov0" title="0">hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
        hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
        hasNumber := regexp.MustCompile(`\d`).MatchString(password)
        hasSpecial := regexp.MustCompile(`[!@#$%^&amp;*()_+\-=\[\]{};':"\\|,.&lt;&gt;\/?]`).MatchString(password)

        if !hasUpper </span><span class="cov0" title="0">{
                errors = append(errors, "Password must contain at least one uppercase letter")
        }</span>

        <span class="cov0" title="0">if !hasLower </span><span class="cov0" title="0">{
                errors = append(errors, "Password must contain at least one lowercase letter")
        }</span>

        <span class="cov0" title="0">if !hasNumber </span><span class="cov0" title="0">{
                errors = append(errors, "Password must contain at least one number")
        }</span>

        <span class="cov0" title="0">if !hasSpecial </span><span class="cov0" title="0">{
                errors = append(errors, "Password must contain at least one special character")
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// SanitizeString removes potentially harmful characters from strings
func SanitizeString(input string) string <span class="cov0" title="0">{
        // Remove null bytes and control characters
        sanitized := regexp.MustCompile(`[\x00-\x1f\x7f]`).ReplaceAllString(input, "")

        // Remove potential XSS patterns
        sanitized = regexp.MustCompile(`&lt;[^&gt;]*&gt;`).ReplaceAllString(sanitized, "")

        // Remove SQL injection patterns
        dangerous := []string{
                "'", "\"", ";", "--", "/*", "*/", "xp_", "sp_", "exec", "execute",
                "&lt;script", "&lt;/script", "javascript:", "vbscript:", "onload=", "onerror=",
                "eval(", "expression(", "url(", "import(",
        }

        for _, pattern := range dangerous </span><span class="cov0" title="0">{
                sanitized = strings.ReplaceAll(sanitized, pattern, "")
                sanitized = strings.ReplaceAll(sanitized, strings.ToUpper(pattern), "")
        }</span>

        // Trim whitespace
        <span class="cov0" title="0">sanitized = strings.TrimSpace(sanitized)

        return sanitized</span>
}

// SanitizeHTML removes HTML tags and dangerous content
func SanitizeHTML(input string) string <span class="cov0" title="0">{
        // Remove all HTML tags
        sanitized := regexp.MustCompile(`&lt;[^&gt;]*&gt;`).ReplaceAllString(input, "")

        // Decode HTML entities
        sanitized = strings.ReplaceAll(sanitized, "&amp;lt;", "&lt;")
        sanitized = strings.ReplaceAll(sanitized, "&amp;gt;", "&gt;")
        sanitized = strings.ReplaceAll(sanitized, "&amp;amp;", "&amp;")
        sanitized = strings.ReplaceAll(sanitized, "&amp;quot;", "\"")
        sanitized = strings.ReplaceAll(sanitized, "&amp;#x27;", "'")

        // Apply regular sanitization
        return SanitizeString(sanitized)
}</span>

// ValidateAndSanitizeInput validates and sanitizes input with specific rules
func ValidateAndSanitizeInput(input string, maxLength int, allowSpecialChars bool) (string, error) <span class="cov0" title="0">{
        if len(input) &gt; maxLength </span><span class="cov0" title="0">{
                return "", fmt.Errorf("input too long, maximum %d characters allowed", maxLength)
        }</span>

        // Sanitize first
        <span class="cov0" title="0">sanitized := SanitizeString(input)

        // Validate based on rules
        if !allowSpecialChars </span><span class="cov0" title="0">{
                if !regexp.MustCompile(`^[a-zA-Z0-9\s\.\,\!\?\-\_\(\)]*$`).MatchString(sanitized) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("input contains invalid characters")
                }</span>
        }

        <span class="cov0" title="0">return sanitized, nil</span>
}

// ValidateAmount validates monetary amounts
func ValidateAmount(amount float64, minAmount, maxAmount float64) error <span class="cov0" title="0">{
        if amount &lt; minAmount </span><span class="cov0" title="0">{
                return fmt.Errorf("amount must be at least %.2f", minAmount)
        }</span>
        <span class="cov0" title="0">if amount &gt; maxAmount </span><span class="cov0" title="0">{
                return fmt.Errorf("amount must not exceed %.2f", maxAmount)
        }</span>
        <span class="cov0" title="0">if amount != float64(int64(amount*100))/100 </span><span class="cov0" title="0">{
                return fmt.Errorf("amount can only have up to 2 decimal places")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidateUUID validates UUID format
func ValidateUUID(uuid string) bool <span class="cov0" title="0">{
        uuidRegex := regexp.MustCompile(`^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`)
        return uuidRegex.MatchString(strings.ToLower(uuid))
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package helpers

import (
        "bytes"
        "database/sql"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/http/httptest"
        "os"
        "path/filepath"
        "testing"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        _ "github.com/mattn/go-sqlite3"
        "github.com/stretchr/testify/assert"
        "golang.org/x/crypto/bcrypt"

        "vaultke-backend/internal/api"

        "vaultke-backend/internal/database"
        "vaultke-backend/internal/middleware"
        "vaultke-backend/internal/services"
)

// TestConfig holds test configuration
type TestConfig struct {
        JWTSecret    string
        DatabaseURL  string
        Environment  string
        ServerPort   string
        LiveKitKey   string
        LiveKitSecret string
        MpesaConsumerKey string
        MpesaConsumerSecret string
        MpesaPasskey string
        MpesaShortcode string
}

// TestUser represents a test user
type TestUser struct {
        ID       string
        Email    string
        Phone    string
        Role     string
        Password string
        Token    string
}

// TestDatabase manages test database setup and teardown
type TestDatabase struct {
        DB *sql.DB
}

// NewTestConfig creates a new test configuration
func NewTestConfig() *TestConfig <span class="cov0" title="0">{
        return &amp;TestConfig{
                JWTSecret:    "test-jwt-secret-key-12345678901234567890",
                DatabaseURL:  ":memory:",
                Environment:  "test",
                ServerPort:   "8080",
                LiveKitKey:   "test-livekit-key",
                LiveKitSecret: "test-livekit-secret",
                MpesaConsumerKey: "test-mpesa-consumer-key",
                MpesaConsumerSecret: "test-mpesa-consumer-secret",
                MpesaPasskey: "test-mpesa-passkey",
                MpesaShortcode: "123456",
        }
}</span>

// SetupTestDatabase creates an in-memory SQLite database for testing
func SetupTestDatabase() *TestDatabase <span class="cov8" title="1">{
        db, err := sql.Open("sqlite3", ":memory:")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to open test database: %v", err))</span>
        }

        <span class="cov8" title="1">if err := database.Migrate(db); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to migrate test database: %v", err))</span>
        }

        <span class="cov8" title="1">return &amp;TestDatabase{DB: db}</span>
}

// Close closes the test database
func (td *TestDatabase) Close() <span class="cov8" title="1">{
        if td.DB != nil </span><span class="cov8" title="1">{
                td.DB.Close()
        }</span>
}

// CreateTestUser creates a test user in the database
func (td *TestDatabase) CreateTestUser(user TestUser) error <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">query := `
                INSERT INTO users (id, email, phone, first_name, last_name, password_hash, role, status, is_email_verified, is_phone_verified)
                VALUES (?, ?, ?, ?, ?, ?, ?, 'active', true, true)
        `
        _, err = td.DB.Exec(query, user.ID, user.Email, user.Phone, "Test", "User", string(hashedPassword), user.Role)
        return err</span>
}

// CreateTestChama creates a test chama in the database
func (td *TestDatabase) CreateTestChama(chamaID, userID string) error <span class="cov0" title="0">{
        // Create chama
        query := `
                INSERT INTO chamas (id, name, description, type, county, town, contribution_amount, contribution_frequency, created_by, max_members, current_members)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `
        _, err := td.DB.Exec(query, chamaID, "Test Chama", "Test Description", "savings", "Nairobi", "Nairobi", 1000.0, "monthly", userID, 50, 1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create chama member
        <span class="cov0" title="0">memberQuery := `
                INSERT INTO chama_members (id, chama_id, user_id, role, joined_at, is_active)
                VALUES (?, ?, ?, ?, ?, ?)
        `
        memberID := uuid.New().String()
        _, err = td.DB.Exec(memberQuery, memberID, chamaID, userID, "chairperson", time.Now(), true)
        return err</span>
}

// CreateTestWallet creates a test wallet in the database
func (td *TestDatabase) CreateTestWallet(walletID, ownerID, walletType string, balance float64) error <span class="cov8" title="1">{
        query := `
                INSERT INTO wallets (id, owner_id, type, balance, currency, is_active)
                VALUES (?, ?, ?, ?, ?, ?)
        `
        _, err := td.DB.Exec(query, walletID, ownerID, walletType, balance, "KES", true)
        return err
}</span>

// CreateTestProduct creates a test product in the database
func (td *TestDatabase) CreateTestProduct(productID, sellerID string) error <span class="cov0" title="0">{
        query := `
                INSERT INTO products (id, name, description, category, price, seller_id, county, town, stock, status, images, tags)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `
        _, err := td.DB.Exec(query, productID, "Test Product", "Test Description", "electronics", 1000.0, sellerID, "Nairobi", "Nairobi", 10, "active", "[]", "[]")
        return err
}</span>

// GenerateJWTToken generates a JWT token for testing
func GenerateJWTToken(userID, role, secret string) (string, error) <span class="cov0" title="0">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "userID": userID,
                "role":   role,
                "exp":    time.Now().Add(time.Hour * 24).Unix(),
        })

        tokenString, err := token.SignedString([]byte(secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}

// SetupTestRouter creates a test router with middleware
func SetupTestRouter(db *sql.DB, cfg *TestConfig) *gin.Engine <span class="cov0" title="0">{
        gin.SetMode(gin.TestMode)
        router := gin.New()

        // Add middleware
        router.Use(gin.Recovery())
        router.Use(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Set("db", db)
                c.Set("config", cfg)
                c.Next()
        }</span>)

        // Initialize services
        <span class="cov0" title="0">authService := services.NewAuthService(cfg.JWTSecret, 86400) // 24 hours in seconds
        authMiddleware := middleware.NewAuthMiddleware(authService)
        wsService := services.NewWebSocketService()

        // Initialize handlers
        authHandlers := api.NewAuthHandlers(db, cfg.JWTSecret, 86400) // 24 hours in seconds
        reminderHandlers := api.NewReminderHandlers(db)
        sharesHandlers := api.NewSharesHandlers(db)
        dividendsHandlers := api.NewDividendsHandlers(db)
        pollsHandlers := api.NewPollsHandlers(db)

        // Add WebSocket service to context
        router.Use(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Set("wsService", wsService)
                c.Next()
        }</span>)

        // Health check
        <span class="cov0" title="0">router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "status": "ok",
                        "version": "1.0.0",
                })
        }</span>)

        // API routes
        <span class="cov0" title="0">apiGroup := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Auth routes
                auth := apiGroup.Group("/auth")
                </span><span class="cov0" title="0">{
                        auth.POST("/register", authHandlers.Register)
                        auth.POST("/login", authHandlers.Login)
                        auth.POST("/logout", authMiddleware.AuthRequired(), authHandlers.Logout)
                        auth.POST("/refresh", authHandlers.RefreshToken)
                }</span>

                // Public routes
                <span class="cov0" title="0">public := apiGroup.Group("/")
                </span><span class="cov0" title="0">{
                        public.GET("/marketplace/products", api.GetProducts)
                        public.GET("/marketplace/products/:id", api.GetProduct)
                        public.POST("/payments/mpesa/callback", api.HandleMpesaCallback)
                }</span>

                // Protected routes
                <span class="cov0" title="0">protected := apiGroup.Group("/")
                protected.Use(authMiddleware.AuthRequired())
                </span><span class="cov0" title="0">{
                        // Users
                        protected.GET("/users", api.GetUsers)
                        protected.GET("/users/profile", authHandlers.GetProfile)
                        protected.PUT("/users/profile", authHandlers.UpdateProfile)
                        protected.POST("/users/avatar", api.UploadAvatar)

                        // Chamas
                        protected.GET("/chamas", api.GetChamas)
                        protected.POST("/chamas", api.CreateChama)
                        protected.GET("/chamas/my", api.GetUserChamas)
                        protected.GET("/chamas/:id", api.GetChama)
                        protected.PUT("/chamas/:id", api.UpdateChama)
                        protected.DELETE("/chamas/:id", api.DeleteChama)
                        protected.GET("/chamas/:id/members", api.GetChamaMembers)
                        protected.POST("/chamas/:id/join", api.JoinChama)
                        protected.POST("/chamas/:id/leave", api.LeaveChama)

                        // Wallets
                        protected.GET("/wallets", api.GetWallets)
                        protected.GET("/wallets/:id", api.GetWallet)
                        protected.GET("/wallets/balance", api.GetWalletBalance)
                        protected.POST("/wallets/deposit", api.DepositMoney)
                        protected.POST("/wallets/transfer", api.TransferMoney)
                        protected.POST("/wallets/withdraw", api.WithdrawMoney)

                        // Marketplace
                        protected.POST("/marketplace/products", api.CreateProduct)
                        protected.PUT("/marketplace/products/:id", api.UpdateProduct)
                        protected.DELETE("/marketplace/products/:id", api.DeleteProduct)
                        protected.GET("/marketplace/cart", api.GetCart)
                        protected.POST("/marketplace/cart", api.AddToCart)
                        protected.DELETE("/marketplace/cart/:id", api.RemoveFromCart)
                        protected.GET("/marketplace/orders", api.GetOrders)
                        protected.POST("/marketplace/orders", api.CreateOrder)
                        protected.GET("/marketplace/orders/:id", api.GetOrder)
                        protected.PUT("/marketplace/orders/:id", api.UpdateOrder)

                        // Payments
                        protected.POST("/payments/mpesa/stk", api.InitiateMpesaSTK)
                        protected.GET("/payments/mpesa/status/:checkoutRequestId", api.GetMpesaTransactionStatus)

                        // Meetings
                        protected.GET("/meetings", api.GetMeetings)
                        protected.POST("/meetings", api.CreateMeeting)
                        protected.GET("/meetings/:id", api.GetMeeting)
                        protected.PUT("/meetings/:id", api.UpdateMeeting)
                        protected.DELETE("/meetings/:id", api.DeleteMeeting)
                        protected.POST("/meetings/:id/join", api.JoinMeeting)

                        // Loans
                        protected.GET("/loans", api.GetLoanApplications)
                        protected.POST("/loans/apply", api.CreateLoanApplication)
                        protected.GET("/loans/:id", api.GetLoanApplication)
                        protected.PUT("/loans/:id", api.UpdateLoanApplication)
                        protected.DELETE("/loans/:id", api.DeleteLoanApplication)
                        protected.POST("/loans/:id/approve", api.ApproveLoan)
                        protected.POST("/loans/:id/reject", api.RejectLoan)

                        // Reminders
                        protected.GET("/reminders", reminderHandlers.GetUserReminders)
                        protected.POST("/reminders", reminderHandlers.CreateReminder)
                        protected.GET("/reminders/:id", reminderHandlers.GetReminder)
                        protected.PUT("/reminders/:id", reminderHandlers.UpdateReminder)
                        protected.DELETE("/reminders/:id", reminderHandlers.DeleteReminder)

                        // Shares
                        protected.GET("/chamas/:id/shares", sharesHandlers.GetChamaShares)
                        protected.POST("/chamas/:id/shares", sharesHandlers.CreateShares)
                        protected.GET("/chamas/:id/shares/summary", sharesHandlers.GetChamaSharesSummary)

                        // Dividends
                        protected.GET("/chamas/:id/dividends", dividendsHandlers.GetChamaDividendDeclarations)
                        protected.POST("/chamas/:id/dividends", dividendsHandlers.DeclareDividend)

                        // Polls
                        protected.GET("/chamas/:id/polls", pollsHandlers.GetChamaPolls)
                        protected.POST("/chamas/:id/polls", pollsHandlers.CreatePoll)
                        protected.POST("/chamas/:id/polls/:pollId/vote", pollsHandlers.CastVote)

                        // Notifications
                        protected.GET("/notifications", api.GetNotifications)
                        protected.PUT("/notifications/:id/read", api.MarkNotificationAsRead)
                        protected.POST("/notifications/read-all", api.MarkAllNotificationsAsRead)

                        // Chat
                        protected.GET("/chat/rooms", api.GetChatRooms)
                        protected.POST("/chat/rooms", api.CreateChatRoom)
                        protected.GET("/chat/rooms/:id", api.GetChatRoom)
                        protected.GET("/chat/rooms/:id/messages", api.GetChatMessages)
                        protected.POST("/chat/rooms/:id/messages", api.SendMessage)

                        // Welfare
                        protected.GET("/welfare", api.GetWelfareRequests)
                        protected.POST("/welfare", api.CreateWelfareRequest)
                        protected.GET("/welfare/:id", api.GetWelfareRequest)
                        protected.PUT("/welfare/:id", api.UpdateWelfareRequest)
                        protected.POST("/welfare/:id/vote", api.VoteOnWelfareRequest)

                        // Contributions
                        protected.GET("/contributions", api.GetContributions)
                        protected.POST("/contributions", api.MakeContribution)
                        protected.GET("/contributions/:id", api.GetContribution)
                }</span>
        }

        <span class="cov0" title="0">return router</span>
}

// MakeRequest makes an HTTP request to the test server
func MakeRequest(router *gin.Engine, method, url string, body interface{}, headers map[string]string) *httptest.ResponseRecorder <span class="cov0" title="0">{
        var reqBody io.Reader
        if body != nil </span><span class="cov0" title="0">{
                jsonBody, _ := json.Marshal(body)
                reqBody = bytes.NewBuffer(jsonBody)
        }</span>

        <span class="cov0" title="0">req, _ := http.NewRequest(method, url, reqBody)
        if body != nil </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov0" title="0">for key, value := range headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        <span class="cov0" title="0">w := httptest.NewRecorder()
        router.ServeHTTP(w, req)
        return w</span>
}

// AssertSuccessResponse asserts that the response is successful
func AssertSuccessResponse(t *testing.T, w *httptest.ResponseRecorder, expectedStatus int) map[string]interface{} <span class="cov0" title="0">{
        assert.Equal(t, expectedStatus, w.Code)
        
        var response map[string]interface{}
        err := json.Unmarshal(w.Body.Bytes(), &amp;response)
        assert.NoError(t, err)
        assert.True(t, response["success"].(bool))
        
        return response
}</span>

// AssertErrorResponse asserts that the response is an error
func AssertErrorResponse(t *testing.T, w *httptest.ResponseRecorder, expectedStatus int) map[string]interface{} <span class="cov0" title="0">{
        assert.Equal(t, expectedStatus, w.Code)
        
        var response map[string]interface{}
        err := json.Unmarshal(w.Body.Bytes(), &amp;response)
        assert.NoError(t, err)
        assert.False(t, response["success"].(bool))
        
        return response
}</span>

// GetTestDataPath returns the path to test data files
func GetTestDataPath(filename string) string <span class="cov0" title="0">{
        return filepath.Join("testdata", filename)
}</span>

// CreateTestFile creates a test file with given content
func CreateTestFile(t *testing.T, filename, content string) string <span class="cov0" title="0">{
        tmpDir := t.TempDir()
        filePath := filepath.Join(tmpDir, filename)
        err := os.WriteFile(filePath, []byte(content), 0644)
        assert.NoError(t, err)
        return filePath
}</span>

// MockWebSocketService creates a mock WebSocket service for testing
func MockWebSocketService() *services.WebSocketService <span class="cov0" title="0">{
        return services.NewWebSocketService()
}</span>

// MockAuthService creates a mock auth service for testing
func MockAuthService() *services.AuthService <span class="cov0" title="0">{
        return services.NewAuthService("test-secret", 86400) // 24 hours in seconds
}</span>

// CleanupTestData removes test data from database
func (td *TestDatabase) CleanupTestData() <span class="cov8" title="1">{
        tables := []string{
                "transactions", "cart_items", "order_items", "orders", "products",
                "chama_members", "chamas", "wallets", "users", "reminders", "meetings",
                "loans", "notifications", "chat_rooms", "chat_messages", "welfare_requests",
                "contributions", "shares", "dividends", "polls", "votes",
        }

        for _, table := range tables </span><span class="cov8" title="1">{
                td.DB.Exec("DELETE FROM " + table)
        }</span>
}

// SetupTestEnvironment sets up the complete test environment
func SetupTestEnvironment(t *testing.T) (*TestDatabase, *gin.Engine, *TestConfig, func()) <span class="cov0" title="0">{
        cfg := NewTestConfig()
        db := SetupTestDatabase()
        router := SetupTestRouter(db.DB, cfg)

        cleanup := func() </span><span class="cov0" title="0">{
                db.Close()
        }</span>

        <span class="cov0" title="0">return db, router, cfg, cleanup</span>
}

// MockRequest represents a mock HTTP request for testing
type MockRequest struct {
        Method  string
        URL     string
        Body    interface{}
        Headers map[string]string
}

// ExecuteRequest executes a mock request and returns the response
func (mr MockRequest) Execute(router *gin.Engine) *httptest.ResponseRecorder <span class="cov0" title="0">{
        return MakeRequest(router, mr.Method, mr.URL, mr.Body, mr.Headers)
}</span>

// TestSuite represents a test suite with common setup
type TestSuite struct {
        DB     *TestDatabase
        Router *gin.Engine
        Config *TestConfig
        Users  map[string]TestUser
}

// NewTestSuite creates a new test suite
func NewTestSuite(t *testing.T) *TestSuite <span class="cov0" title="0">{
        db, router, cfg, _ := SetupTestEnvironment(t)
        
        // Create test users
        users := map[string]TestUser{
                "admin": {
                        ID:       "admin-user",
                        Email:    "admin@example.com",
                        Phone:    "+254700000001",
                        Role:     "admin",
                        Password: "password123",
                },
                "user": {
                        ID:       "regular-user",
                        Email:    "user@example.com",
                        Phone:    "+254700000002",
                        Role:     "user",
                        Password: "password123",
                },
                "chairperson": {
                        ID:       "chairperson-user",
                        Email:    "chairperson@example.com",
                        Phone:    "+254700000003",
                        Role:     "user",
                        Password: "password123",
                },
        }

        // Create users in database and generate tokens
        for key, user := range users </span><span class="cov0" title="0">{
                err := db.CreateTestUser(user)
                assert.NoError(t, err)

                token, err := GenerateJWTToken(user.ID, user.Role, cfg.JWTSecret)
                assert.NoError(t, err)
                user.Token = token
                users[key] = user
        }</span>

        <span class="cov0" title="0">return &amp;TestSuite{
                DB:     db,
                Router: router,
                Config: cfg,
                Users:  users,
        }</span>
}

// Cleanup cleans up the test suite
func (ts *TestSuite) Cleanup() <span class="cov0" title="0">{
        ts.DB.CleanupTestData()
        ts.DB.Close()
}</span>

// GetAuthHeaders returns authorization headers for a user
func (ts *TestSuite) GetAuthHeaders(userType string) map[string]string <span class="cov0" title="0">{
        user, exists := ts.Users[userType]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">return map[string]string{
                "Authorization": "Bearer " + user.Token,
        }</span>
}

// CreateTestChama creates a test chama for the test suite
func (ts *TestSuite) CreateTestChama(chamaID string) error <span class="cov0" title="0">{
        return ts.DB.CreateTestChama(chamaID, ts.Users["chairperson"].ID)
}</span>

// CreateTestWallet creates a test wallet for the test suite
func (ts *TestSuite) CreateTestWallet(walletID, ownerID, walletType string, balance float64) error <span class="cov0" title="0">{
        return ts.DB.CreateTestWallet(walletID, ownerID, walletType, balance)
}</span>

// CreateTestProduct creates a test product for the test suite
func (ts *TestSuite) CreateTestProduct(productID string) error <span class="cov0" title="0">{
        return ts.DB.CreateTestProduct(productID, ts.Users["user"].ID)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
